<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>minster&#39;s Blog</title>
  
  <subtitle>记录学习以及生活~</subtitle>
  <link href="https://minster.top/atom.xml" rel="self"/>
  
  <link href="https://minster.top/"/>
  <updated>2023-07-08T00:17:06.336Z</updated>
  <id>https://minster.top/</id>
  
  <author>
    <name>Minster</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap为什么通过(n - 1) &amp; hash 获取哈希桶数组下标？</title>
    <link href="https://minster.top/2023/07/07/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%9A%E8%BF%87(n%20-%201)%20&amp;%20hash%20%E8%8E%B7%E5%8F%96%E5%93%88%E5%B8%8C%E6%A1%B6%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%EF%BC%9F/"/>
    <id>https://minster.top/2023/07/07/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%9A%E8%BF%87(n%20-%201)%20&amp;%20hash%20%E8%8E%B7%E5%8F%96%E5%93%88%E5%B8%8C%E6%A1%B6%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%EF%BC%9F/</id>
    <published>2023-07-07T13:21:04.000Z</published>
    <updated>2023-07-08T00:17:06.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看过HashMap源码人应该都知道HashMap是如何根据hash值来计算哈希桶数组下标的，<strong>就是通过(n - 1) &amp; hash来计算的，为什么用的是位运算(&amp;)而不是取模运算(hash % n)呢？</strong></p><p>获取hash桶数组下标源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="位运算与取模运算效率比较"><a href="#位运算与取模运算效率比较" class="headerlink" title="位运算与取模运算效率比较"></a>位运算与取模运算效率比较</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polymorphic;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100000</span>; <span class="comment">// 数据集数量，初始定义为十万</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位运算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">bitwise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从十万开始，一直到Integer的最大值，计算所需时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> number; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            a &amp;= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> end - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;位运算时间为：&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取模运算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">module</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> number; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            a %= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> end - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;取模运算时间为：&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        t.bitwise();</span><br><span class="line">        t.<span class="keyword">module</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image01.jpg" alt="image01"></p><p>从测试结果我们可以看出，如果数据集足够的大，那么取模运算的时间将会是位运算时间的十几倍。</p><p>这只是一方面，如果数据集足够大的话，HashMap的初始容量肯定不够，这也触发了HashMap的扩容机制。所以<strong>采用二进制位操作 &amp;，相对于%能够提高运算效率。</strong></p><h2 id="位运算是如何保证索引不越界的？"><a href="#位运算是如何保证索引不越界的？" class="headerlink" title="位运算是如何保证索引不越界的？"></a>位运算是如何保证索引不越界的？</h2><p>讲到这，<strong>我们也就要想想为什么HashMap的容量是2的n次幂？</strong>两者之间有着千丝万缕的联系。</p><p>当 n 是2的次幂时， n - 1 通过 二进制表示即尾端一直都是以连续1的形式表示的。<strong>当(n - 1) 与 hash 做与运算时，会保留hash中 后 x 位的 1，这样就保证了索引值 不会超出数组长度。</strong></p><blockquote><p><strong>当n为2次幂时，即n&#x3D;2^k，那么(n-1)的二进制表示中，从最低位开始到k-1位，都是1。</strong></p><p>2^2-1 &#x3D; 3：0000 0000 0011</p><p>2^3-1 &#x3D; 7：0000 0000 0111</p><p>…</p><p>2^5-1 &#x3D; 31：0000 0001 1111</p><p>最低位是从0开始算的。</p><p>为什么当我们将一个哈希值与 n - 1 进行按位与运算时，结果会保留哈希值的后 x 位中的所有 1？</p><p>这是因为 n - 1 的二进制表示中，后 x 位都是 1，而哈希值的对应位如果是 1，则与 1 进行按位与运算结果仍为 1，如果是 0，则结果为 0。 </p><p>这就可以说明：我们进行位运算时，得到的结果永远小于或等于n-1</p></blockquote><p><strong>同时当n为2次幂时，会满足一个公式：(n - 1) &amp; hash &#x3D; hash % n。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;看过HashMap源码人应该都知道HashMap是如何根据hash值来计算哈希桶数组下标的，&lt;strong&gt;就是通过(n - 1) &amp;amp; hash来计算的，为什么用的是位运算(&amp;amp;)而不是取模运算(hash % n)呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获取hash桶数组下标源码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((p = tab[i = (n - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;amp; hash]) == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tab[i] = newNode(hash, key, value, &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java" scheme="https://minster.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://minster.top/tags/Java/"/>
    
    <category term="HashMap" scheme="https://minster.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Eureka中的负载均衡</title>
    <link href="https://minster.top/2023/07/03/Eureka%E4%B8%AD%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://minster.top/2023/07/03/Eureka%E4%B8%AD%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2023-07-03T13:21:04.000Z</published>
    <updated>2023-07-06T13:58:55.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Eureka中的负载均衡"><a href="#Eureka中的负载均衡" class="headerlink" title="Eureka中的负载均衡"></a>Eureka中的负载均衡</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Eureka是Netflix开发的一种用于构建分布式系统中的微服务架构的服务发现组件。</p><p>Ribbon是一个基于HTTP和TCP协议的客户端负载均衡工具，它是Netflix开源的一个组件，旨在提供客户端侧负载均衡算法和服务实例的自动发现功能，以实现对服务调用的负载均衡。</p><p>Spring官方提供了一个Spring Cloud LoadBalancer来替代Ribbon它是基于Netflix Ribbon的一个新的客户端负载均衡组件，提供更加灵活的扩展性和可配置性。</p><p>而在我们的Eureka中实现服务的远程调用则是通过Spring Cloud LoadBalancer来完成。本文将结合源码分析一下Euraka拉取服务以及远程调用服务的过程。</p><span id="more"></span><h3 id="Eureka与Ribbon的关系"><a href="#Eureka与Ribbon的关系" class="headerlink" title="Eureka与Ribbon的关系"></a>Eureka与Ribbon的关系</h3><p>Eureka组件只提供服务的注册和发现功能，它本身并不具备负载均衡的功能。但我们使用Eureka组件时却能实现服务请求的处理和分配（负载均衡），正是因为Eureka中集成了Ribbon负载均衡组件。</p><blockquote><p>Ribbon是Netflix开源的一种用于构建分布式系统中的微服务架构的客户端负载均衡组件。Ribbon支持多种负载均衡算法，例如轮询、随机、加权轮询、加权随机等，并且支持自定义负载均衡算法。Ribbon可以与Eureka、Consul等服务发现组件集成，也可以与Spring Cloud LoadBalancer等负载均衡器集成，提供更加灵活和可扩展的负载均衡功能。</p></blockquote><h3 id="为什么要使用Eureka"><a href="#为什么要使用Eureka" class="headerlink" title="为什么要使用Eureka"></a>为什么要使用Eureka</h3><p>现在有一个案例：在分布式的架构中，有两个节点order-service以及user-service。</p><p>在order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706170322077.png" alt="image-20230706170322077"></p><p>如果上图所示，我们在order-service服务中需要想user-service中发起一个请求，才能取到对应的用户信息。</p><p>要实现上述需求，我们可以这样做</p><ol><li><p>在order-service中注册RestTemplate</p><blockquote><p>RestTemplate是Spring框架提供的一个用于发送HTTP请求的客户端库，主要用于调用RESTful Web服务时发送请求并接收响应。它可以发送GET、POST、PUT、DELETE等HTTP请求，并接收相应的响应。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: minster</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PACKAGE</span>_NAME: cn.itcast.config</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@NAME</span>: RestConfiguration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2023/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改order-service中的order业务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">    <span class="comment">// 2. 远程查询user信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/user/&quot;</span> + order.getUserId();</span><br><span class="line">    <span class="comment">// 3. 通过restTemplate发起调用</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">    <span class="comment">// 4. 封装数据到order</span></span><br><span class="line">    order.setUser(user);</span><br><span class="line">    <span class="comment">// 5. 返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>测试：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706171645353.png" alt="image-20230706171645353"></p><p>如下图所示，我们的user-service提供了接口给外部使用，即服务提供者。而order-service使用了user-service，即服务消费者。</p><blockquote><p>服务提供者与服务消费者是相对的，一个服务既有可能是服务提供者，也有可能是服务消费者</p></blockquote><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706141607328.png" alt="image-20230706141607328"></p><p>虽然上述代码实现了需求，但是我们可以发现以下问题：</p><ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时该如何选择？</li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li></ul><p>上述问题都需要利用Spring Cloud中的注册中心来解决，其中Eureka便是一个注册中心。</p><p>下面我们使用一个案例，来演示基于Eureka组件的服务注册与发现以及服务调用请求的分配，分析Eureka是怎么解决上述三个问题的。</p><p>案例的架构如下：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706102828818.png" alt="image-20230706102828818"></p><p><strong>实现代码</strong></p><p>新建项目eureka-server</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706173731285.png" alt="image-20230706173731285"></p><p>导入服务端依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写配置信息。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里配置了eureka-server的端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># applicatio-name: 其实就是在注册中心的服务名字</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>开启EurekaServer服务功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.discovery.EurekaNamespace;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: minster</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PACKAGE</span>_NAME: cn.itcast</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@NAME</span>: EurekaApplication</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2023/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// @EnableEurekaServer 可以开启EurekaServer服务</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:10086/">Eureka</a></p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706174019102.png" alt="image-20230706174019102"></p><p>我们可以发现eureka-server服务已经成功注册到我们的Eureka注册中心</p><p>同时，我们将order-service、user-service服务也注册到我们的Eureka注册中心</p><p>步骤如下：</p><ol><li><p>导入客户端依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure></li></ol><p>注册步骤一样，这里不再演示。</p><p>同时，我们多启动一个user-service，构成一个user服务集群。</p><p>当前服务启动情况如下图所示：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706175121795.png" alt="image-20230706175121795"></p><p>刷新一下<a href="http://localhost:10086/">Eureka</a>，可以发现，我们都客户端服务都注册到我们的Eureka中</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706175230190.png" alt="image-20230706175230190"></p><p>下面我们修改order-service中的业务代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">    <span class="comment">// 2. 远程查询user信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br><span class="line">    <span class="comment">// 3. 通过restTemplate发起调用</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">    <span class="comment">// 4. 封装数据到order</span></span><br><span class="line">    order.setUser(user);</span><br><span class="line">    <span class="comment">// 5. 返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在order-service中的RestTemplate配置类中给Bean添加<code>@LoadBalanced</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用order服务接口，查看两个user-service中的控制台的日志</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706175757006.png" alt="image-20230706175757006"></p><p>我们可以发现，两个user-service服务都被调用到了！</p><p>Eureka是怎么做到的呢？我们可以通过下图分析</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706180452345.png" alt="image-20230706180452345"></p><p>在我们上述案例中，我们通过配置客户端配置文件中的</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>分别将我们的order-service、user-service注册到注册中心当中去。</p><p>当我们需要调用的时候，我们的服务消费者只需要去注册中心拉取我们的服务信息，然后再进行远程调用即可，这也就解释我们上面的第一个问题：<strong>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口的</strong></p><p>然后当我们的服务注册到Eureka注册中心之后，我们的注册中心会定期检查我们服务的一个健康状态的，通常是30s，这样也就能解决我们上述的第三个问题：<strong>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</strong></p><p>然后对于第二个问题：<strong>有多个user-service实例地址，order-service调用时该如何选择？</strong>在这里，我们可以看到在RestTemplate中加了一个注解<code>@LoadBalanced</code>，这个注解的作用其实就是做了一个负载均衡，具体的原理，如下图所示：</p><p> <img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706195504888.png" alt="image-20230706195504888"></p><h3 id="Ribbon负载均衡在SpringCloud中的实现（源码分析）"><a href="#Ribbon负载均衡在SpringCloud中的实现（源码分析）" class="headerlink" title="Ribbon负载均衡在SpringCloud中的实现（源码分析）"></a>Ribbon负载均衡在SpringCloud中的实现（源码分析）</h3><p>在上述案列中，我们只加了一个<code>@LoadBalanced</code>注解，就实现了负载均衡，这个注解到底做了什么呢？</p><p>下面我们通过源码追踪，分析一下SpringCloud是如何实现Ribbon负载均衡的。</p><p>我们先定位到<code>@LoadBalanced</code>注解所在的包，发现在同包下有一个<code>LoadBalancerInterceptor</code> 类。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706200720713.png" alt="image-20230706200720713"></p><p>顾名思义，这是一个负载均衡的拦截器，我们以这个类为起点，进行调试，源码追踪</p><p><strong>进入到我们的<code>LoadBalancerInterceptor</code> 类中，发现其中有一个<code>intercept</code> 方法，我们打个断点，调试</strong></p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706201039313.png" alt="image-20230706201039313"></p><p>可以发现，<code>intercept</code>方法将我们order-service中发送到服务提供者user-service的请求拦截下来了，并且解析了我们的请求url，获取我们服务提供者的主机名。</p><p>我们继续追踪，查看<code>loadBalancer.execute</code>方法到底做了什么，追踪到<code>LoadBalancerClient</code>的一个实现类<code>RibbonLoadBalancerClient</code> 中</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706201714764.png" alt="image-20230706201714764"></p><p>我们可以发现，主机名：userservice作为参数传递到了<code>getLoadBalancer</code>方法中，我们追踪该方法，看一下里面到底做了什么。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706204336667.png" alt="image-20230706204336667"></p><p><code>getLoadBalancer</code> 方法最终返回了一个Feign Client实例，通过这个Feign Client我们可以从Eureka中拉取对应我们的serviceId对应的服务，也就是userservice服务。</p><blockquote><p>在使用Feign Client进行服务调用时，Feign Client会通过负载均衡器来选择要调用的服务实例。</p></blockquote><p>我们继续往下调试</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706204944251.png" alt="image-20230706204944251"></p><p>在通过<code>getLoadBalancer(serviceId)</code> 方法获取到的返回值loadBalancer中，可以看到我们的userservice对应的端口！也就是说我们的拉取服务是在这里完成的。</p><p>我们继续追踪源码，看一个<code>execute</code> 方法中的<code>getServer()</code>到底做了什么。可以发现，后面<code>getServer()</code>会调用到<code>BaseLoadBalancer</code>类下的<code>chooseServer</code>方法中。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706210502196.png" alt="image-20230706210502196"></p><p>我们将这个方法分成两部分来看，分别解析：</p><p><strong>第一部分：</strong></p><blockquote><p>在这里，我们做了一个计数器的自增操作，因为我们在我们的负载均衡的轮询策略中，是按照一定的顺序来依次执行的。每次选择服务实例时，计数器会自增1，从而实现轮询的效果。</p><p>例如，假设我们有三个服务A，B，C，我们的负载均衡采取了轮询的策略来进行服务的调用。</p><p>当我们进行第一次进行服务选择时，负载均衡器会选择我们的第0个服务，也就是A；</p><p>当我们进行第二次进行服务选择时，负载均衡器会选择我们的第1个服务，也就是B；</p><p>当我们进行第三次进行服务选择时，负载均衡器会选择我们的第2个服务，也就是C；</p><p>当我们进行第四次进行服务选择时，由于已经选择了所有的服务实例，负载均衡器会重新从第0个服务实例开始选择。</p></blockquote><p><strong>第二部分：</strong></p><blockquote><p>在这里，我们会根据指定的负载均衡策略对应的算法，对我们的服务进行一个选择操作，如果我们没有指定负载均衡策略，则会使用Ribbon默认的负载均衡策略——轮询。</p></blockquote><p>上述的负载均衡策略是通过rule获取的，我们可以看一下，rule的类型以及实现类</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706212556355.png" alt="image-20230706212556355"></p><blockquote><p>拓展：IRule的实现类及其代表的含义如下</p><ol><li><strong>RoundRobinRule（轮询规则）：</strong>按照顺序依次选择可用的服务器进行请求分发，实现简单的轮询负载均衡。</li><li><strong>WeightedResponseTimeRule（加权响应时间规则）：</strong>根据每个服务器的平均响应时间和权重，选择一个性能较好的服务器进行请求分发。具有更低响应时间和较高权重的服务器将有更高的概率被选中。</li><li><strong>RandomRule（随机规则）：</strong>随机选择一个可用的服务器进行请求分发。具有平均负载分布的特点，适用于无需特定负载均衡策略的场景。</li><li><strong>RetryRule（重试规则）：</strong>在请求失败时，会尝试重新选择一个可用的服务器进行重试。该规则适用于具有容错需求的场景，可以增加系统的可靠性。</li><li><strong>AvailabilityFilteringRule（可用性过滤规则）：</strong>根据服务器的可用性和运行状态，选择一个可用的服务器进行请求分发。它会排除掉那些因为故障或超负荷而不可用的服务器。</li><li><strong>BestAvailableRule（最佳可用规则）：</strong>选择一个可用服务器中并发连接最低的服务器进行请求分发。这有助于减少请求被发送到负载较高的服务器上。</li><li><strong>ZoneAvoidanceRule：</strong>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</li></ol></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在最后，我们可以发现，我们使用SpringCloud整合Eureka注册中心实现服务的注册发现与处理分配时，其实就是通过我们的<code>LoadBalancerInterceptor</code>将我们的要调用的服务拦截下来，并获取我们服务请求url中的主机名，然后通过<code>Feign Client</code>和负载均衡器到我们的Eureka注册中心拉取服务列表。</p><p>拉取到服务列表之后，我们会调用<code>getServer()</code>方法去执行我们的负载均衡策略，通过我们设定的负载均衡策略（默认是轮询），执行对应的负载均衡算法，从而选择一个服务列表中选择一个适合的服务给我们的服务消费者使用 。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Eureka中的负载均衡&quot;&gt;&lt;a href=&quot;#Eureka中的负载均衡&quot; class=&quot;headerlink&quot; title=&quot;Eureka中的负载均衡&quot;&gt;&lt;/a&gt;Eureka中的负载均衡&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Eureka是Netflix开发的一种用于构建分布式系统中的微服务架构的服务发现组件。&lt;/p&gt;
&lt;p&gt;Ribbon是一个基于HTTP和TCP协议的客户端负载均衡工具，它是Netflix开源的一个组件，旨在提供客户端侧负载均衡算法和服务实例的自动发现功能，以实现对服务调用的负载均衡。&lt;/p&gt;
&lt;p&gt;Spring官方提供了一个Spring Cloud LoadBalancer来替代Ribbon它是基于Netflix Ribbon的一个新的客户端负载均衡组件，提供更加灵活的扩展性和可配置性。&lt;/p&gt;
&lt;p&gt;而在我们的Eureka中实现服务的远程调用则是通过Spring Cloud LoadBalancer来完成。本文将结合源码分析一下Euraka拉取服务以及远程调用服务的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Cloud" scheme="https://minster.top/categories/Spring-Cloud/"/>
    
    
    <category term="Spring Cloud" scheme="https://minster.top/tags/Spring-Cloud/"/>
    
    <category term="Ribbon" scheme="https://minster.top/tags/Ribbon/"/>
    
    <category term="Eureka" scheme="https://minster.top/tags/Eureka/"/>
    
    <category term="Spring Cloud LoadBalancer" scheme="https://minster.top/tags/Spring-Cloud-LoadBalancer/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题汇总（持续更新！）</title>
    <link href="https://minster.top/2023/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/"/>
    <id>https://minster.top/2023/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/</id>
    <published>2023-06-03T13:21:04.000Z</published>
    <updated>2023-07-08T00:38:20.390Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/moon-4919501_1920.jpg" alt="moon"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下是我对Java高频面试题的一个总结，后面我会持续更新，希望对你有所帮助。<br>当然，如果有哪道题目我理解错误了，或者是你有更好的见解，非常欢迎你在评论区中留下宝贵的意见！</p><span id="more"></span><h2 id="JavaSE基础"><a href="#JavaSE基础" class="headerlink" title="JavaSE基础"></a>JavaSE基础</h2><h3 id="1-JDK、JRE、JVM分别是什么，有什么区别"><a href="#1-JDK、JRE、JVM分别是什么，有什么区别" class="headerlink" title="1. JDK、JRE、JVM分别是什么，有什么区别"></a>1. JDK、JRE、JVM分别是什么，有什么区别</h3><ul><li><strong>JDK(Java Development Kit) ：</strong> 是Java标准开发包，它提供了编译、运行Java所需要的各种工具和资源，包括Java编译器、Java运行环境、以及常用的类库等</li><li><strong>JRE(Java Runtime Enviroment)：</strong>Java的运行环境，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件</li><li><strong>JVM(Java Virtual Mechinal)：</strong>Java虚拟机，是JRE的一部分，它用于编译执行字节码文件，是可运行Java字节码文件的虚拟计算机</li></ul><p><strong>区别</strong></p><ul><li>JDK用于开发，JRE用于运行Java程序，如果你只是为了运行一下Java程序的话，安装JRE即可，但是要开发Java程序的话，必须要安装JDK</li><li>JDK包含JRE，JDK、JRE中都有JVM</li><li>JVM是Java实现跨平台性的核心，它具有平台独立性能，它拥有类加载以及垃圾回收等机制。</li></ul><h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2. 重载和重写的区别"></a>2. 重载和重写的区别</h3><ul><li>重载发生在同一类中，当同一类中的两个或多个方法，方法名相同，参数列表不同，就构成了重载</li><li>重写发生在类的父子关系中，当一个类继承另一个类或者实现了某一个接口，就可以重写该类的非私有方法，从而实现功能的拓展；重写要求方法名、参数列表相同</li></ul><h3 id="3-x3D-x3D-和equals的区别是什么"><a href="#3-x3D-x3D-和equals的区别是什么" class="headerlink" title="3. &#x3D;&#x3D;和equals的区别是什么"></a>3. &#x3D;&#x3D;和equals的区别是什么</h3><p>&#x3D;&#x3D;对于基本类型来说就是值的比较，对于引用类型来说就是引用的比较。</p><p>而equals默认情况下是引用的比较，只是因为有很多类都重写了equals方法，比如String、Integer等类都把它变成了值的比较。</p><h3 id="4-什么是hashCode"><a href="#4-什么是hashCode" class="headerlink" title="4. 什么是hashCode()"></a>4. 什么是hashCode()</h3><p>hashCode()方法作用获取一个哈希码，即散列码，它实际上是一个int整数。哈希码可以确定该对象在哈希表中的索引位置。hashCode的定义在Object类中，所以java中任何类都包含了hashCode函数。</p><p>散列表其实就是用来存放键值对（key-value），我们可以通过key快速检索出对应的value。其中就使用了散列码。</p><h3 id="5-hashCode与equals有什么关系"><a href="#5-hashCode与equals有什么关系" class="headerlink" title="5. hashCode与equals有什么关系"></a>5. hashCode与equals有什么关系</h3><p>要搞清楚他们之间的关系，我们可以从hash表的结构出发，其实hash表是一个数组+链表或红黑树的结构，Java的集合容器就有使用到这种数据结构的，然后在我们要存储对象到容器时可以先通过hashCode方法返回了一个hash值，这个hash与数组长度取余之后就能获取到该对象的存放在数组结构的一个对应的下标，<strong>当两个对象有相同的hash值的时候，说明存放的数组下标是一样的（也就是产生了哈希冲突）</strong>，那么此时我们就需要通过equals方法判断这两个对象是不是相同的对象，如果不是则插入在链表中，所以我们可以得下面结论：</p><ol><li>当两个对象相同时，它们的hash值也相同，它们之间的互相调用equals方法结果为true</li><li>当两个对象有相同的hashCode的值，那么它们也不一定相等。</li></ol><blockquote><p>补充：</p><p>对于HashSet存放的自定义类型来说，如果是同一个对象会插入失败</p><p>对于HashMap存放的自定义类型来说，如果是同一个对象会覆盖掉原来的value</p></blockquote><h3 id="6-为什么重写equals方法必须重写hashCode方法呢"><a href="#6-为什么重写equals方法必须重写hashCode方法呢" class="headerlink" title="6. 为什么重写equals方法必须重写hashCode方法呢"></a>6. 为什么重写equals方法必须重写hashCode方法呢</h3><p>首先在java的一些容器中，是不允许存放两个相同的对象的，如果对象相同会覆盖掉，而在散列表中我们存放对象时，会首先判断两个对象的hash值是否相同，如果相同再通过equals方法来判断是否为相同对象，如果是相同对象就会在散列表中覆盖掉，否则就插入到相关链表中，那么如果我们只重写了equals方法，而不重写hashCode方法，那么那么相同对象的值就无法覆盖了。</p><h3 id="7-面向对象的特征"><a href="#7-面向对象的特征" class="headerlink" title="7. 面向对象的特征"></a>7. 面向对象的特征</h3><p>面向对象主要有三大特征：封装性、继承、多态</p><ol><li><p>封装性：封装性指的是我们在定义对象时，尽可能的把对象状态信息隐藏起来，只提供有限的接口的方法给外界交互使用，从而避免外界对对象内部属性进行破坏。</p></li><li><p>继承：继承其实就是一种能力，当一个类A继承了另外一个类B时，A类就可以使用B类公开的所有的属性和方法，并且可以在不修改父类的前提下对其功能进行拓展。当然，如果B类存在用private修饰的属性或方法，A类是无法使用的，这就是封装性的体现。</p></li><li><p>多态：多态是指同一对象的不同形式的展现，比如说我们到宠物店跟店说“我要一只宠物”，那么店员就可以给我一只小猫、小狗、或者小蜥蜴等等，那么此时我们所说的宠物对象就是多态一种展现了。</p><blockquote><p>多态是怎么形成的</p><p>其实java的引用变量有两种类型，一种是编译时类型、一种是运行时类型，而编译类型由引用变量在定义时的声明所决定，运行时类型由实际赋值给引用变量的类型所决定，当编译时类型与运行时类型不一样时，就会产生所谓的多态</p></blockquote></li></ol><h3 id="8-接口和抽象类的共同点和区别"><a href="#8-接口和抽象类的共同点和区别" class="headerlink" title="8. 接口和抽象类的共同点和区别"></a>8. 接口和抽象类的共同点和区别</h3><p><strong>共同点：</strong></p><ul><li>都不能被实例化</li><li>都可以包含抽象方法</li><li>都可以有默认实现的方法（在JDK1.8之后才可以用default定义接口中的默认方法的）</li></ul><p><strong>区别：</strong></p><ul><li>接口用于对类的行为进行约束，一个类实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系</li><li>一个类只能继承一个类，但是可以实现多个接口</li><li>抽象类中有构造方法，接口中没有构造方法</li><li>抽象类中的成员变量默认是default，可以被子类重新定义赋值，接口中的成员变量是常量，不能被修改且必须要有初始值</li></ul><h3 id="9-java中操作字符串的类有哪些？他们之间有什么区别"><a href="#9-java中操作字符串的类有哪些？他们之间有什么区别" class="headerlink" title="9. java中操作字符串的类有哪些？他们之间有什么区别"></a>9. java中操作字符串的类有哪些？他们之间有什么区别</h3><p>操作字符串的类有主要有String、StringBuffer、StringBuilder三种。</p><p>在jdk1.8及以前String、StringBuffer、StringBuilder底层都是char数组。</p><p>在jdk1.9及以后，三者的底层都是byte数组。</p><blockquote><p>使用byte[]还能存放中文的原因是因为他们的底层会有一个coder的值，该值可以是<code>LATIN1</code>和<code>UTF16</code>的一种，所以能存放中文字符</p></blockquote><p>因为String类是由Final修饰的，所以String类的长度是不会变化，每当我们新建一个String类时都需要new一个对象，让指针指向新的对象。而StringBuffer、StringBuilder都是继承于AbstractStringBuilder，而AbstractStringBuilder底层是使用一个可变数组来存放字符串的，所以他们存放的字符串内容是可变的。而且存在扩容机制。</p><blockquote><p>扩容机制：</p><p>因为他们都是继承了AbstractStirngBuilder类，而该类有一个方法会检测当前字符串类的byte的容量是否足够来存放新的字符串，如果不能，进行扩容</p><p>扩容的逻辑就是先判断是字符串是否含有中文，在根据相应的一个处理得到一个新的byte数组，最后通过Arrays.copyOf方法将原来byte数组的值复制到新的byte值当中去。</p></blockquote><p>然后StringBuffer和StringBuilder之间是有线程是否安全的区别的。</p><p>StringBuffer因为加了同步锁synchronized所以线程安全，因为synchronized同步锁会有一个获取锁和释放锁的操作，所以StringBuffer的效率更低。</p><blockquote><p>为什么StringBuffer加了锁就效率更低呢？</p><p>因为synchronized锁其实是会有四种状态的升级和优化的。分别是：无锁、偏向锁、轻量级锁、重量级锁四种</p><p>偏向锁就是当一段同步代码或者是资源被同一个线程多次访问的时候，那么该线程就会自动获取锁，降低获取锁的代价。</p><p>而当锁是偏向锁时，如果有其他线程访问该锁时，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式来获取锁，不会阻塞，提高性能。</p><p>当前锁是轻量级锁时，另外一个线程不会一直自旋，当其自旋到一定次数后，轻量级锁会升级为重量级锁，其他线程进入阻塞状态，性能降低。因为线程自旋需要消耗cpu性能，所以自旋到一定次数后轻量级锁会膨胀成重量级锁。</p></blockquote><p>StringBuilde因为没有加锁，所以效率更高。</p><h3 id="10-String为什么要设计成不可变的？"><a href="#10-String为什么要设计成不可变的？" class="headerlink" title="10. String为什么要设计成不可变的？"></a>10. String为什么要设计成不可变的？</h3><p>String设计成不可变的原因主要有以下四点：</p><ol><li><p>便于实现字符串池（String pool）</p><p>因为在实际开发中，我们会大量的使用String常量，如果每次声明一个String类型都创建一个String对象的话，那将会造成极大的空间资源浪费。所以Java提出了String pool的概念，并且在堆中开放了一块专门用来存放String常量的字符串常量池(String Pool)。当我们初始化一个String变量时，JVM会先去查找字符串常量池是否已经存在该字符串了，如果存在则直接引用，如果不存在则新建一个字符串对象。</p><p>如果String是可以变的，那么一个字符串变量改变了他的值，都会指向一个新的String对象了，而String Pool也无法实现了</p></li><li><p>线程安全</p><p>在多线程环境下如果对同一个资源同时进行写操作时会引发一个线程安全的问题，而String设计成了不可变，确保了String对象不能被写，所以保证了多线程的安全。</p></li><li><p>避免安全问题</p><p>在网络连接和数据库连接中字符串常常作为参数，例如，网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。</p></li><li><p>加快字符串处理速度</p><p>由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。所以HashMap中的键往往都使用String。</p></li></ol><p>总体来说，String不可变的原因要包括 设计考虑，效率优化，以及安全性这三大方面。</p><h3 id="11-深克隆与浅克隆的区别（深拷贝和浅拷贝）"><a href="#11-深克隆与浅克隆的区别（深拷贝和浅拷贝）" class="headerlink" title="11. 深克隆与浅克隆的区别（深拷贝和浅拷贝）"></a>11. 深克隆与浅克隆的区别（深拷贝和浅拷贝）</h3><p>浅克隆（默认）</p><ul><li><p>拷贝出的新对象，与原对象中的数据一模一样（引用类型拷贝的是地址）</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230509175906576.png" alt="shallow-copy"></p></li></ul><p>深克隆（避免新对象修改其他对象内容时，影响原对象的对象内容）</p><ul><li><p>对象中基本类型的数据直接拷贝</p></li><li><p>对象中的字符串数据拷贝的还是地址</p></li><li><p>对象中还包含的其他对象，不会拷贝地址，会创建新对象</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230509175922784.png" alt="deep-copy"></p></li></ul><h3 id="12-Java-是编译执行的语言，还是解释执行的语言"><a href="#12-Java-是编译执行的语言，还是解释执行的语言" class="headerlink" title="12. Java 是编译执行的语言，还是解释执行的语言?"></a>12. Java 是编译执行的语言，还是解释执行的语言?</h3><p><strong>Java即是编译型的，也是解释型语言，总的来说Java更接近解释型语言</strong></p><ul><li>可以说它是编译型的。因为所有的Java代码都是要编译的，Java不经过编译就什么用都没有。同时围绕JVM的效率问题，会涉及一些如JIT、AOT等优化技术，例如JIT技术，会将热点代码编异成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码</li><li>可以说它是解释型的。因为Java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的。</li></ul><h3 id="13-jdk1-8的新特性"><a href="#13-jdk1-8的新特性" class="headerlink" title="13. jdk1.8的新特性"></a>13. jdk1.8的新特性</h3><ol><li><p>Lambda表达式</p><p>Lambda 允许把函数作为一个方法的参数</p></li><li><p>方法引用</p><p>方法引用允许直接引用已有Java类或对象的方法或构造方法</p></li><li><p>函数式接口</p><p>只有一个抽象方法的接口就叫函数式接口，函数式接口可以被隐式转换为Lambda表达式。通常函数式接口上回添加一个<code>@FunctionalInterface</code>注解</p></li><li><p>接口允许定义默认方法和静态方法</p><p>从JDK8开始，允许接口存在一个或多个默认非抽象方法和静态方法</p></li><li><p>Stream API（Stream流）</p><p>Stream API把真正的函数式编程风格引入到Java中。</p><p>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等</p></li><li><p>日期&#x2F;时间类改进</p><p>在JDK8之前，我们JDK提供的日期处理类非常不方便，我们在处理的时候通常是使用第三方工具包，比如<code>commons-lang</code> 包等。</p><p>在JDK8之后，因为LocalDateTime的出现，日期时间的创建、比较、调整、格式化、时间间隔等操作都比以往简单很多。</p></li><li><p>Optional 类</p><p>Optional 类是一个可以为null的容器对象。如果值存在则 <code>isPresent()</code> 方法会返回true，调用 <code>get()</code> 方法会返回该对象</p></li><li><p>Java8 Base64实现</p><p>Java8内置了 Base64 编码的编码器和解码器</p></li></ol><h3 id="14-Final有什么作用"><a href="#14-Final有什么作用" class="headerlink" title="14. Final有什么作用"></a>14. Final有什么作用</h3><p>Final是一个关键字修饰符，被Final修饰的类或成员变量有以下特点</p><ul><li><p>被final修饰的类不可以被继承</p></li><li><p>被final修饰的方法不可以被重写</p></li><li><p>被final修饰的变量不可以被改变</p><blockquote><p><strong>被final修饰的变量不可变的是变量的引用，而不是引用指向的内容，引用指向的内容时可以改变的</strong></p></blockquote></li></ul><h3 id="15-什么是反射机制"><a href="#15-什么是反射机制" class="headerlink" title="15. 什么是反射机制"></a>15. 什么是反射机制</h3><p>Java反射机制是在运行状态中，对于任意一个类，都能够获取到这个类的所有属性和方法的信息；对于任意一个对象，都能够调用它的任意一个方法和属性；</p><p>在Java中，这种动态获取类的信息以及动态调用对象的方法的功能被称为反射机制</p><h3 id="16-反射机制的优缺点"><a href="#16-反射机制的优缺点" class="headerlink" title="16. 反射机制的优缺点"></a>16. 反射机制的优缺点</h3><p>优点：运行期类型的判断，动态加载类，提高代码灵活度</p><p>缺点：性能瓶颈：反射相当于一系列解释操作，通知JVM要做的事情，性能比直接的Java代码要慢很多</p><h2 id="JavaSE进阶-IO"><a href="#JavaSE进阶-IO" class="headerlink" title="JavaSE进阶-IO"></a>JavaSE进阶-IO</h2><h3 id="1-BIO-NIO-AIO有什么区别？"><a href="#1-BIO-NIO-AIO有什么区别？" class="headerlink" title="1. BIO NIO AIO有什么区别？"></a>1. BIO NIO AIO有什么区别？</h3><ul><li><p>BIO：Block IO 同步阻塞式IO，就是我们平常使用的传统ID，它的特点是模式简单使用方便。但是并发处理能力低。</p></li><li><p>NIO：New IO 同步非阻塞IO，是传统IO的升级，客户端和服务端通过Channel（通道）通讯，实现了多路复用</p><blockquote><p>IO多路复用模型</p><p>该模型是有一个多路复用器，也就是一个选择器(Selector)，通过这个选择器，我们只需要一个线程便可以管理多个客户端连接。当用户数据到了之后才会为其服务</p></blockquote></li><li><p>AIO：Asynchronous IO 是NIO的升级，也叫NIO2，实现了一部非阻塞IO，一部IO的操作基于事件和回调机制</p></li></ul><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/BIO_NIO_AIO.png" alt="BIO_NIO_AIO"></p><h2 id="JavaSE进阶-异常"><a href="#JavaSE进阶-异常" class="headerlink" title="JavaSE进阶-异常"></a>JavaSE进阶-异常</h2><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230611074554345.png" alt="image-20230611074554345"></p><p><strong>Throwable是所有Java程序中错误处理的父类，他有两种子类：Error和Exception</strong></p><h3 id="1-Error-和-Exception-区别是什么"><a href="#1-Error-和-Exception-区别是什么" class="headerlink" title="1. Error 和 Exception 区别是什么"></a>1. Error 和 Exception 区别是什么</h3><ul><li><p><strong>Error</strong> </p><p>表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，最多只是显示错误信息</p></li><li><p><strong>Exception：</strong> 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<code>Exception</code> 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和一般异常(又叫受检查异常) 。</p></li></ul><h3 id="运行时异常（非受检查异常）和一般异常（受检查异常）的区别"><a href="#运行时异常（非受检查异常）和一般异常（受检查异常）的区别" class="headerlink" title="运行时异常（非受检查异常）和一般异常（受检查异常）的区别"></a>运行时异常（非受检查异常）和一般异常（受检查异常）的区别</h3><p><strong>运行时异常：</strong>包括 <code>RunTimeException</code> 类及其子类，表示JVM在运行期间可能出现的异常。Java编译器不会检查运行时异常。</p><blockquote><p>常见的运行时异常有：</p><p><code>NullPointException(空指针)</code>、<code>NumberFormatException（字符串转换为数字）</code>、<code>IndexOutOfBoundsException(数组越界)</code>、<code>ClassCastException(类转换异常)</code>、<code>ArrayStoreException(数据存储异常，操作数组时类型不一致)</code>等</p></blockquote><p><strong>一般异常(受检查异常)：</strong>是Exception中除 <code>RuntiemException</code> 及其子类紫外的异常。 Java编译器会检查一般异常（受检查异常）。</p><blockquote><p>常见的一般异常有：</p><p>IO相关的异常、<code>ClassNotFoundException</code> 、 <code>SQLException</code>等</p></blockquote><p><strong>两者之间的区别：</strong> 它们之间的区别就是是否在编译阶段就能检查到。</p><h2 id="JavaSE进阶-集合"><a href="#JavaSE进阶-集合" class="headerlink" title="JavaSE进阶-集合"></a>JavaSE进阶-集合</h2><h3 id="1-Array-和-ArrayList-有什么区别？"><a href="#1-Array-和-ArrayList-有什么区别？" class="headerlink" title="1. Array 和 ArrayList 有什么区别？"></a>1. Array 和 ArrayList 有什么区别？</h3><ul><li><p>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</p></li><li><p>Array 大小是固定的，ArrayList 的大小是动态变化的。</p></li><li><p>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</p></li></ul><h3 id="2-常见的集合类有哪些"><a href="#2-常见的集合类有哪些" class="headerlink" title="2. 常见的集合类有哪些"></a>2. 常见的集合类有哪些</h3><p>Java的集合容器有单列集合和双列集合两种，单列集合指的是Collection接口下的派生类：List、Set、Queue（JDK5 新增的队列）；双列集合则是Map接口下的派生类。</p><blockquote><p><strong>注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口</strong>。</p></blockquote><p>在集合体系中，List集合代表了可重复集合，他们是有索引的；Set集合代表无序不可重复的集合，只能根据元素本身来访问（无索引）。Queue集合是一个队列集合。</p><p>Map集合时可以存放key-value键值对的集合，他的key是不可重复的，value是可以重复的。</p><p>List集合常用的有ArrayList、LinkedList</p><p>Set集合中常用的有HashSet、TreeSet</p><p>Queue集合常用的有ArrayQueue</p><p>Map集合中常用的有HashMap、TreeMap、ConcurrentHashMap</p><h3 id="3-ArrayList与LinkedList的异同"><a href="#3-ArrayList与LinkedList的异同" class="headerlink" title="3. ArrayList与LinkedList的异同"></a>3. ArrayList与LinkedList的异同</h3><ul><li><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> Arraylist 底层使用的是Object数组（动态数组）；LinkedList 底层使用的是双向循环链表数据结构；</li><li><strong>插入和删除是否受元素位置的影响：</strong> <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。  <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li><li><strong>是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h3 id="4-ArrayList的扩容机制"><a href="#4-ArrayList的扩容机制" class="headerlink" title="4. ArrayList的扩容机制"></a>4. ArrayList的扩容机制</h3><p>因为ArrayList底层维护的是一个数组，所以ArrayList的扩容机制是基于Arrays.copyOf方法实现的。</p><p>当我们用默认的无参构造方法创建ArrayList集合的时候，ArrayList的初始长度为0。<strong>当我们向集合添加第一个元素的时候，ArrayList集合的长度为10；</strong></p><p>当我们向集合添加元素时都会有一个判断，就是查看当前容量是否可以继续添加元素，<strong>如果集合的容量够就添加到集合中，如果容量不够则触发扩容机制，扩容的大小为原集合容量的1.5倍。</strong></p><blockquote><p>1.5倍是因为新的集合容量为<strong>原集合容量</strong>与<strong>其右移一位之后</strong>的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure></blockquote><p>当我们使用有参构造去创建ArrayList集合时，扩容机制也与上面的一样，不过需要注意的是他扩容的大小为你传进去的参数的1.5倍</p><h3 id="5-HashMap的底层数据结构是什么"><a href="#5-HashMap的底层数据结构是什么" class="headerlink" title="5. HashMap的底层数据结构是什么"></a>5. HashMap的底层数据结构是什么</h3><p><strong>在JDK1.8以前，HashMap底层维护的是一个”数组+链表“的结构</strong>，数组是HashMap的主体，链表是为了解决哈希冲突而存在的。</p><p><strong>在JDK1.8之后，HashMap的底层变成了”数组+链表+红黑树“的数据结构了</strong>。</p><p>在JDK1.8之前，如果我们使用HashMap存放大量数据时，会使HashMap的链表结构变得非常长，这样会导致我们的查询效率变慢，严重的影响了HashMap的性能。</p><p>因此，在JDK1.8之后对数据结构做了进一步的优化，引进了红黑树，链表和红黑树会在达到一定条件时会进行转换：</p><ul><li>当链表长度达到了8，且数组的长度达到64时才会发生转换</li><li>因为在触发树化机制的时候，HashMap的底层会进行判断，如果当前数组的长度没有达到64，会优先对数组进行扩容，而不是进行树化，这样可以节省查询时间。</li></ul><blockquote><p><strong>面试官也许还会问：</strong></p><p>如你上面所说，为什么HashMap在JDK8之后不直接采取数组+红黑树的结构，而是使用数组+链表+红黑树的数据结构呢？</p><p>首先因为红黑树会在每次添加元素时进行一个左旋、右旋、变色等操作来保持平衡，链表则不会，因此链表插入数据的效率会比红黑树快。</p><p>所以在数据量很少的时候，链表的效率会比红黑树高；</p><p>但是当数据量多了之后，因为红黑树搜索的时间复杂度为O(log n)，而链表的是O(n)，因此选择红黑树可以增加的查询效率，但是新增的效率变慢了。</p><p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p></blockquote><h3 id="6-HashMap的扩容机制"><a href="#6-HashMap的扩容机制" class="headerlink" title="6. HashMap的扩容机制"></a>6. HashMap的扩容机制</h3><ul><li>HashMap底层维护了Node类型的数组table，默认为null，链表与红黑树是为了解决哈希冲突而存在的。</li><li>当创建对象时，将加载因子(loadfactor)初始化为0.75；</li><li>当添加key-value时，通过<strong>key</strong>的hash值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换<strong>value</strong>；<strong>如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。</strong></li><li>第一次添加时，会将需要扩容的table容量扩容到16，临界值(threshold)为12</li><li>如果需要再次扩容，会将需要扩容的table容量扩容到原来的2倍（32），临界值为原来的2倍（24） 依次类推。</li><li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），<strong>否则任然采用数组扩容机制</strong></li></ul><blockquote><p>HashSet的底层就是HashMap，唯一区别是HashSet的value值为一个常量，所以当同一hash值中的key相同时，会添加失败；而HashMap会替换掉key对应的value。</p></blockquote><h3 id="7-ConcurrentHashMap的实现原理是什么"><a href="#7-ConcurrentHashMap的实现原理是什么" class="headerlink" title="7. ConcurrentHashMap的实现原理是什么?"></a>7. ConcurrentHashMap的实现原理是什么?</h3><blockquote><p>ConcurrentHashMap的底层数据结构</p></blockquote><p>ConcurrentHashMap 在JDK1.7和JDK1.8的实现方式是不同的。</p><p><strong>JDK1.7</strong></p><p>ConcurrentHashMap在JDK1.7是由<code>segment</code> 和 <code>HashEntry</code> 组成的。**<code>ConcurrentHashMap</code>会把哈希桶切分成小数组（segment）**，每一个<code>segment</code> 都包含了n个<code>HashEntry</code> , 也就是我们<code>HashMap</code>的一个结构。</p><p><code>ConcurrentHashMap</code>能实现线程安全其实就是在每一个<code>segment</code> 中加了一个可重入锁（也就是说每一段数据都会有锁），当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。</p><p>底层结构图如下图所示</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/JDK_7_ConcurrentHashMap.png" alt="JDK_7_ConcurrentHashMap"></p><blockquote><p>补充：</p><p><code>segment</code>是<code>ConcurrentHashMap</code>的一个内部类，<strong>它继承了<code>ReentrantLock</code>可重入锁</strong>，扮演锁的角色（构成了分段锁）。所以<code>segment</code>锁也是可重入的。</p></blockquote><p><strong>JDK1.8</strong></p><p>在数据结构上，JDK1.8中<code>ConcurrentHashMap</code>选择了与HashMap相似的Node数组+链表+红黑树的数据结构，这样可以使<code>ConcurrentHashMap</code>的数据结构不再像JDK1.7那么的臃肿，使用起来更为方便；在锁的实现上，抛弃了原有的 <code>Segment</code> 分段锁，<strong>采用了<code>CAS+Synchronized</code>实现更加细粒度的锁</strong>。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230621195606507.png" alt="image-20230621195606507"></p><p>在JDK8中，<code>ConcurrentHashMap</code> 将锁的级别控制在了更细粒度的哈希桶数组元素级别，也就是说<strong>我们只需要在链表的头结点或者红黑树的根节点上加锁</strong>，就不会影响其他哈希桶数组元素的读写，从而实现了并发。</p><blockquote><p><strong>也许面试官还会问：为什么JDK8使用了<code>Synchronized</code>锁替换可重入锁<code>ReentrantLock</code>呢？</strong></p><ul><li>在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步转换。</li><li>减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</li></ul></blockquote><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-描述一下jvm加载-class文件的过程吗？（类加载过程）"><a href="#1-描述一下jvm加载-class文件的过程吗？（类加载过程）" class="headerlink" title="1. 描述一下jvm加载.class文件的过程吗？（类加载过程）"></a>1. 描述一下jvm加载.class文件的过程吗？（类加载过程）</h3><p>因为Class文件需要加载到虚拟机中才能运行和使用，所以就有了类加载的过程</p><p>类在JVM中的生命周期主要有：<strong>加载、连接、初始化、使用、卸载五部分组成。</strong></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong></p><p><strong>加载过程</strong>指的是JVM将经过javac编译的字节码文件加载到内存当中的过程。</p><p><strong>连接阶段分别由验证、准备、解析三个阶段组成。</strong></p><ul><li><p>验证阶段会对字节码文件的格式、元数据格式等进行验证，确保字节码文件没有损害JVM的内容，是保护JVM的一个阶段。</p></li><li><p>准备阶段会为class文件的静态变量分配内存，并赋予初始值，此时的初始值指的是0</p></li><li><p>解析阶段会将符号引用转换为直接引用</p></li></ul><p><strong>连接阶段完成之后会到初始化阶段</strong>，该阶段开始执行java中定义的代码，为变量赋予真正的初始值，指的是代码中程序员想要赋的值</p><blockquote><p>类加载是由类加载器完成的，类加载器分别有：启动类加载器、扩展类加载器、系统类加载器、自定义加载器等</p></blockquote><h3 id="2-什么是双亲委派模型，为什么要使用"><a href="#2-什么是双亲委派模型，为什么要使用" class="headerlink" title="2. 什么是双亲委派模型，为什么要使用"></a>2. 什么是双亲委派模型，为什么要使用</h3><p>双亲委派原则指的是类加载器在接收到类加载的一个请求时，不会立刻加载，会先委派该类的父类加载器去加载，只有当父类加载器在他的搜索范围内没有搜索到该类时，子类的加载器才会对该类进行加载。</p><p>这样做可以防止内存中出现多个相同的字节码文件；因为如果没有双亲委派模型的话，那么用户自己再定义了一个java.lang.String的类，就无法保证类的唯一性了。</p><h3 id="3-可达性算法"><a href="#3-可达性算法" class="headerlink" title="3. 可达性算法"></a>3. 可达性算法</h3><p>可达性算法的逻辑就是，在以一个GC Root为根节点的对象作为起点开始搜索，能遍历到的对象，也就是说该对象的引用还存在，就是可达的对象。而不能遍历到的对象，说明对象的引用已经不存在了，所以是不可达对象，也就是被GC回收的对象。</p><p>可以作为GC Roots的对象有哪些呢？</p><blockquote><ul><li>在栈帧的局部变量引用的对象</li><li>在本地方法区JNI引用的对象</li><li>在方法区（元空间）的静态变量或常量引用的对象</li></ul></blockquote><h3 id="4-你能说一下垃圾回收机制吗？"><a href="#4-你能说一下垃圾回收机制吗？" class="headerlink" title="4. 你能说一下垃圾回收机制吗？"></a>4. 你能说一下垃圾回收机制吗？</h3><p>首先我们要理解JVM的一个内存模型，因为JVM的内存模型是由栈、本地方法区、程序计算器、元空间、堆这5部分组成。</p><p>然后因为我们创建的对象，是存放在堆的，然后当我们一段代码执行完成之后，只有存放在栈的局部变量可以自动删除，而存放在堆的对象仍然存在，这时候就需要垃圾回收机制来回收堆的内存了。</p><p>然后垃圾回收的算法主要有三种</p><ul><li><p>标记清理法：就是先遍历一次堆里面的所有对象，把要删除的对象标记，然后再遍历一次，把第一次遍历标记的对象都删除掉，就完成了，但是有一个缺点，就是会存在内存碎片</p><blockquote><p>什么是内存碎片？</p><p>内存碎片我是这样理解的，比如我们在堆中的两个不相连的位置中分别有一个1KB大小的对象，然后我们通过标记清理法把他们删除了，那么堆中就挤出来2KB的内存空间了，如果我们这个时候新建一个2KB大小的对象，是无法存放在堆中的，因为上面清理出来的2KB空间不是连续的，所以就会产生内存碎片问题</p></blockquote></li><li><p>标记-整理法：他跟标记清理法原理是差不多的，但是他会在删除对象后，把后面的对象往前推，这样子就解决了内存碎片的问题，但是由于每删一个对象都需要移动一次后面的对象，会导致性能会有所降低，而且这样做的代价太大了。</p></li></ul><ul><li>复制法：复制法会把内存分成两块大小一样的内存，首先把其中一块内存通过GC ROOT标记，再把标记过后存活的对象复制到另一块内存中去，最后把存放垃圾对象的内存清理掉，缺点就是需要双倍的内存，太消耗内存了。</li></ul><p>所以GC综合了上面三个算法，创建了一个分代收集的算法出来</p><p>分代收集算法就是先把内存分为young区跟old区两块，分别代表年轻代和老年代。</p><p>然后再young区那一块内存中，又分为E空间、S0空间、S1空间；</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/hotspot-heap-structure.png" alt="hotspot-heap-structure"></p><p><strong>简单的概括就是：</strong></p><p>大部分情况，对象都会首先在 Eden 区域分配。</p><p>然后在一次GC之后，E空间和S0空间存活的对象会移到S1空间去，再回收E空间和S0空间的垃圾对象</p><p>在下一次GC完成后，E空间和S1空间存活的对象会移到S0空间去，然后回收E空间和S1空间的垃圾对象</p><p>每一次被标记存活的对象，都会有一个类似于age的变量，都会加一，当age&gt;一个阈值时，他会晋升到老年代去。需要注意的是，大对象（需要大量内存的对象，例如集合、数组）会直接存放在老年代</p><blockquote><p>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置），<strong>取这个年龄和 MaxTenuringThreshold 中更小的一个值</strong>，作为新的晋升年龄阈值”</p></blockquote><p><strong>补充：垃圾回收机制中会触发的几种GC方式的区别以及详解</strong></p><blockquote><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p></blockquote><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/rf-hotspot-vm-gc.png" alt="rf-hotspot-vm-gc"></p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="1-你能说一下创建线程的方法有哪些吗"><a href="#1-你能说一下创建线程的方法有哪些吗" class="headerlink" title="1. 你能说一下创建线程的方法有哪些吗"></a>1. 你能说一下创建线程的方法有哪些吗</h3><p>创建线程的方式有四种，分别是</p><ol><li>继承Thread类并重写run方法创建线程，虽然实现简单，但是不可以继承其他类</li><li>实现Runnable接口并重写run方法方法。避免了单继承的局限性，编程更加灵活，很好的实现了解耦合</li><li>实现Callable接口并重写call方法，创建线程，通过该方法可以获取线程执行结果的返回值，并且可以抛出异常。</li><li>通过线程池创建。（使用java.util.concurrent.Executor接口）</li></ol><h3 id="2-Runnable接口和Callable接口的区别"><a href="#2-Runnable接口和Callable接口的区别" class="headerlink" title="2. Runnable接口和Callable接口的区别"></a>2. Runnable接口和Callable接口的区别</h3><p>Runnable接口的run方法没有返回值，Callable接口的call方法有返回值，并且支持泛型</p><p>Runnable接口的run方法只能抛出运行时异常，且其他异常只能在内部处理异常，而Callable接口可以抛出所有的异常，以及在内部处理。</p><h3 id="3-sleep方法和yield方法有什么区别"><a href="#3-sleep方法和yield方法有什么区别" class="headerlink" title="3. sleep方法和yield方法有什么区别"></a>3. sleep方法和yield方法有什么区别</h3><ol><li>sleep方法不会考虑优先级问题，然后优先级低的线程也能拿到CPU资源，而yield方法会考虑优先级的问题，调用该方法只会给同等优先级或高优先级的线程CPU资源</li><li>Sleep方法有声明InterruptedExcetion异常抛出，yield是没有异常抛出的</li><li>sleep方法执行后线程会进入阻塞状态，而yield方法执行后会进入就绪状态</li><li>sleep比yield具有更好的移植性</li></ol><h3 id="4-线程中sleep和wait方法有什么区别"><a href="#4-线程中sleep和wait方法有什么区别" class="headerlink" title="4. 线程中sleep和wait方法有什么区别"></a>4. 线程中sleep和wait方法有什么区别</h3><p>首先sleep()方法是线程类的一个静态方法，调用该方法可以让线程暂停指定的一段时间，暂停的线程会把CPU资源让出来给其他线程使用，但是对象的锁依然保存，所以当暂停时间到后，该线程会自动恢复到就绪状态。而wait方法是Object类一个方法，调用对象的wait方法可以让当前线程放弃对象的锁，即进入暂停状态，然后当前线程会进入到对象的等待池，知道对象调用notice方法时才能唤醒等待池中的线程进入等锁池，如果线程重新获得对象的锁就可以进入到就绪状态。</p><h3 id="5-线程的run方法和start方法有什么区别"><a href="#5-线程的run方法和start方法有什么区别" class="headerlink" title="5. 线程的run方法和start方法有什么区别"></a>5. 线程的run方法和start方法有什么区别</h3><p>调用start()方法可以让启动一个线程，并进入到就绪状态，而调用run()方法只是调用了一个对象的方法，并没有开启新的线程。</p><p>就比如说你在主线程中调用了run()方法，那么你要等run()方法执行完之后才会继续执行下面的代码，而调用了start()方法，会开启一条线程去执行Thread对象中对应的run方法，即使run方法没有执行完，主线程中还会执行start()下面的代码。</p><h3 id="6-线程有哪几种状态？（线程的生命周期）"><a href="#6-线程有哪几种状态？（线程的生命周期）" class="headerlink" title="6. 线程有哪几种状态？（线程的生命周期）"></a>6. 线程有哪几种状态？（线程的生命周期）</h3><p>Java线程在运行的生命周期中的指定时刻只可能处于下面6中不同状态的其中一个状态</p><ul><li><strong>NEW</strong>：线程初始状态，线程被创建出来但没有被调用start()方法的状态</li><li><strong>RUNNABLE</strong>：运行状态，线程被调用了start()等待运行的状态。<code>RUNNABLE</code>状态细分一下会有一个<code>RUNNING</code>状态以及<code>READY</code>状态的</li><li><strong>BLOCKED</strong>：阻塞状态，需要等待锁释放。</li><li><strong>WAITING</strong>：等待状态，调用wait方法后的一个状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）</li><li><strong>TIME_WAITING</strong>：超时等待状态，调用wait方法并且传入了一个时间之后的状态，可以在指定的时间后自行返回而不是想WAITING那样一直等待。</li><li><strong>TERMINATED</strong>：终止状态，表示该线程已经运行完毕</li></ul><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间转换。</p><p><img src="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/640.png" alt="Java-thread-status"></p><h3 id="7-线程相关的基本方法都有哪些"><a href="#7-线程相关的基本方法都有哪些" class="headerlink" title="7. 线程相关的基本方法都有哪些"></a>7. 线程相关的基本方法都有哪些</h3><p>线程相关的基本方法有6种，分别是wait、sleep、notifyAll、notify、join、yield</p><ol><li><p><strong>wait方法（线程等待）：</strong></p><p>线程调用<code>wait</code>方法并且没有传入参数时，会让该线程进入到一个<code>WAITING</code>状态，<strong>并且释放锁资源</strong>，直至被其他线程调用<code>notify</code>或<code>notifyAll</code>方法才会进入就绪状态重新竞争锁资源；如果调用<code>wait</code>方法并传入一个指定的时间，该线程会进入到<code>TIMED_WAITING</code>状态，如果指定超过的时间还没获取到锁资源，该线程就会直接返回到就绪状态，不会一直在等待通知</p></li><li><p><strong>sleep方法（线程睡眠）</strong>：</p><p>sleep方法会导致当前线程休眠，与wait方法不同的是<strong>sleep不会释放锁资源</strong>，然后sleep会导致线程进入TIMED_WAITING状态，当休眠时间过去之后，当前线程会自动唤醒并且继续执行。这个过程中其他线程处于阻塞状态</p></li><li><p><strong>yield方法（线程让步）</strong>：</p><p>yield方法会让当前线程让出CPU时间片（资源），同时让当前线程重新与其他线程竞争CPU时间片，一般来说优先级高的线程会比较容易获得CPU时间片。但不是绝对的，有一些操作系统对线程优先级不敏感。</p></li><li><p><strong>interrupt（线程中断）：</strong></p><p>该方法可以中断一个线程，该方法会将线程中的一个标识符设置为true，表示中断该线程，但是<strong>线程中断之后并不会释放锁资源</strong>，需要结合wait方法的使用才会释放锁资源。这个过程中线程的状态不会发生改变</p></li><li><p><strong>join方法（等待其他线程终止）：</strong></p><p>在当前线程调用另外一个线程的join()方法时，会让<strong>当前线程进入到阻塞状态，直到另一个线程执行结束</strong>，当前线程才会由阻塞状态转换为就绪状态并且重新竞争锁资源。</p></li><li><p><strong>notify方法（线程唤醒）：</strong></p><p>Object类上的notify方法，可以唤醒在此对象监视器上等待的线程（可以理解为在当前锁对象外面等待的资源），如果所有的线程都在这个对象上等待，则会唤醒任意一个线程。</p><p>在调用notify()方法之后，线程并不会立即释放该对象的锁。它会继续执行同步代码块，<strong>直到离开同步代码块或调用wait()方法时才会释放锁</strong>，从而使等待的线程有机会获取锁并执行。</p><p>在使用wait()和notify()方法进行线程间通信时，<strong>需要确保等待线程和唤醒线程都使用相同的对象作为锁</strong>，以避免死锁等问题。</p></li></ol><h3 id="8-wait-和sleep-的区别"><a href="#8-wait-和sleep-的区别" class="headerlink" title="8. wait() 和sleep()的区别"></a>8. wait() 和sleep()的区别</h3><p>wait()方法与sleep()方法的区别主要有一下四点</p><ol><li><p>它们来自不同的类</p><p>wait()来自Object类</p><p>sleep()来自Thread类</p></li><li><p>调用wait方法会释放锁资源，调用sleep方法不会释放锁资源</p></li><li><p>wait方法必须要在同步代码块中使用，sleep方法可以在任何地方使用</p></li><li><p>wait方法不需要捕获异常，sleep方法需要捕获异常</p></li></ol><h3 id="9-Java中常用的线程池有哪些"><a href="#9-Java中常用的线程池有哪些" class="headerlink" title="9. Java中常用的线程池有哪些"></a>9. Java中常用的线程池有哪些</h3><p>常用的线程池主要有6种，分别是：</p><ol><li><strong>newFixedThreadPool：</strong>创建一个定长线程池（核心线程数与最大线程数都为指定参数的线程池），可以控制线程最大并发数，超出的线程会在队列中等待。</li><li><strong>newCacheThreadPool：</strong>创建一个可缓存线程池（核心线程数为0，最大线程数为Integer.MAX_VALUE的线程池），如果线程池的长度超过处理需要，可以灵活的回收空闲线程，若无可回收，则创建新线程。这种方式可能会创建大量的线程，造成OOM。</li><li><strong>newScheduledThreadPool：</strong>创建一个定长的线程池（核心线程数与最大线程数都为指定参数的线程池），支持定时及周期性任务执行。</li><li><strong>newSingleThreadExecutor：</strong>创建一个单线程化的线程池（核心线程数与最大线程数都为1的线程池），它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行</li><li><strong>newSingleScheduledThreadPool：</strong>创建一个单线程化的线程池（核心线程数为1、最大线程数为Integer.MAX_VALUE的线程池），它可安排在给定延迟后运行命令或者定期执行</li><li><strong>newWorkStealingPool</strong>：创建一个带并<strong>行级别的线程池</strong>，并行级别决定了同<strong>一时刻</strong>最多有<strong>多</strong>少个；线程在执行<strong>，如不传并行级别参数，将默认为当前系统的</strong>CPU<strong>核心数</strong>*<strong>2</strong>。该线程池是在JDK1.8才出现的，底层是基于一个工作窃取算法实现的，该算法的核心思想就是让空闲的线程从其他线程的任务队列中“窃取”任务来执行。</li></ol><h3 id="10-Java线程池的核心参数有哪些（创建的时候）"><a href="#10-Java线程池的核心参数有哪些（创建的时候）" class="headerlink" title="10. Java线程池的核心参数有哪些（创建的时候）"></a>10. Java线程池的核心参数有哪些（创建的时候）</h3><blockquote><p>corePoolSize：线程池的核心线程数量</p><p>maxNumPollSiza：线程池中最大的线程数</p><p>KeepAliveTime：当线程数大于核心线程数时，多余的空闲线程存活的最长时间</p><p>unit：时间单位</p><p>WorkQueue：阻塞队列&#x2F;任务队列，用来储存等待执行任务的队列</p><p>threadFartoty：线程工厂，用来创建线程，一般默认即可</p><p>handler：拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</p></blockquote><h3 id="11-线程池的执行流程"><a href="#11-线程池的执行流程" class="headerlink" title="11. 线程池的执行流程"></a>11. 线程池的执行流程</h3><p><img src="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230602143058557.png" alt="image-20230602143058557"></p><ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><h3 id="12-Synchronized底层实现原理"><a href="#12-Synchronized底层实现原理" class="headerlink" title="12. Synchronized底层实现原理"></a>12. Synchronized底层实现原理</h3><p>我们可以结合JVM和字节码来分析一下Synchronized底层实现原理</p><h3 id="13-Synchronized与Volatile的区别"><a href="#13-Synchronized与Volatile的区别" class="headerlink" title="13. Synchronized与Volatile的区别"></a>13. Synchronized与Volatile的区别</h3><p><code>Volatile</code>关键字可以保证变量的可见性。使用Volatile关键修饰的标量其实就是相当于指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><code>Synchronized</code>关键字其实就是我们的同步锁，主要用于解决多个线程之间资源访问的同步性，被它修饰的方法或者代码块在任意时刻只能有一个线程执行。如果使用Synchronized修饰变量的话，就是将变量锁定了，当前线程可以访问该变量，其他线程被阻塞。 </p><p>它们之间的区别主要有以下四点：</p><ul><li><code>Volatile</code>关键字是线程同步的轻量级实现，所以<code>Volatile</code> 性能肯定要比<code>Synchronized</code> 关键字要好。但是<code>Volatile</code> 只能作用于变量，而<code>Synchronized</code> 可以作用在变量、方法、类中</li><li><code>Volatile</code> 关键字可以保证数据的可见性，但不能保证数据的原子性。<code>Synchronized</code> 关键字两者都能保证</li><li><code>Volatile</code> 关键字主要用于解决变量在多个线程之间的可见性，而<code>Synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li></ul><blockquote><p><strong>Volatile除了可以保证标量的可见性之外，还有一个重要的作用就是防止 JVM 的指令重排序。</strong></p><p>如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><p>面试官可能会问：“了解单例模式吗？请你用懒汉双检锁的方式给我写一个单例模式，并且解释一下”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个单例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">// 构造器私有化，保证单例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 提供一个公开的方法，供外界获取单例实例</span></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查，避免单例已经被创建的时候，其他线程都去竞争锁，从而导致阻塞</span></span><br><span class="line">       <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">// 加同步锁锁住类，防止高并发场景下创建多个实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line"><span class="comment">// 第二次检查，确保实例是没有被创建的</span></span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span> )&#123;</span><br><span class="line">                    <span class="comment">// 创建实例</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>uniqueInstance</code> 变量使用了<code>volatile</code> 修饰符声明，是为了防止JVM的指令重排序。比方说我们创建<code>Singleton</code> 实例的那一行代码<code>uniqueInstance = new Singleton();</code>  ，其实在JVM中是分三步完成的</p><ol><li>为<code>Singleton</code> 类的实例对象分配内存空间。</li><li>初始化<code>Singleton</code> 类的实例对象</li><li>将<code>uniqueInstance</code> 变量指向<code>Singleton</code> 类的实例对象所在的内存地址。</li></ol><p>正常来说我们上面的代码执行顺序就是<code>1-&gt;2-&gt;3</code> ，<strong>但是在JVM指令重排序的影响下，执行顺序可能会是<code>1-&gt;3-&gt;2</code></strong> ，这样做可以提高程序的性能，因为<strong>在执行步骤3之前，对象已经被创建，可以被其他线程访问</strong>，而步骤2中的初始化操作不影响对象的可见性和安全性。</p><p>在单线程环境下，这样做并不会产生什么问题，因为最终得到的都是一个初始化过后的实例对象嘛。</p><p>但是在并发环境下，如果线程A的执行顺序是<code>1-&gt;3-&gt;2</code> ，而在3这一步的时候，线程B进来了发现<code>uniqueInstance</code>不为null，这个时候他就会直接返回<code>uniqueInstance</code>，而这个时候线程B得到的<code>uniqueInstance</code>是一个<strong>还未初始化的实例对象</strong></p><h3 id="14-ThreadLocal是什么？"><a href="#14-ThreadLocal是什么？" class="headerlink" title="14. ThreadLocal是什么？"></a>14. ThreadLocal是什么？</h3><p><code>ThreadLocal</code>其实就是线程的一个局部变量。通常情况下，我们创建的变量，在多线程环境下都是共享的。如果我们想要给每个线程都创建一个属于自己的本地变量的话，我们就需要使用JDK中自带的<code>ThreadLocal</code>类了。**<code>ThreadLocal</code>类会为每一个线程创建一个独自的变量副本，这个变量副本在同一个线程内是可以传递的，在不同的线程中是隔离开的。每个线程可以通过ThreadLocal提供的get()、set()方法来获取到副本中的值。**</p><p>其实我们可以这样理解ThreadLocal：比方说有两个人去宝屋收集宝物，如果两个人都共用一个袋子的话，他们是不是有可能会发生争执，那么如果给他们各自分配一个袋子的话，是不是就避免了这个问题。<strong>我们把这两个人比作线程的话，就是他们有可能发生并发问题吧，那么ThreadLocal其实就是上面分发袋子的一个机制，用来避免（不是解决，是避免！）他们发生并发问题的。</strong></p><blockquote><p>ThreadLocal的底层实现原理：</p><p>在Thread类中，有两个<code>ThreadLocal.ThradLocalMap</code> 类型的属性，而<code>ThreadLocalMap</code> 它是<code>ThreadLocal</code> 下的一个静态内部类，它的结构与<code>HashMap</code> 类似，我们可以理解成它是<code>ThradLocal</code> 定制的一个<code>HashMap</code> 。因为它的key其实就是我们的<code>ThreadLocal</code>的一个弱引用，然后<code>value</code>就是我们要存放到线程变量副本中的值，比如我们业务中要传递的登录数据就是这个<code>value</code>了。</p><p>然后当我们需要获取这个<code>value</code>的时候，我们只需要通过调用<code>ThreadLocal</code>中的<code>get()，set()</code>方法即可，因为实际上调用这两个方法时，我们调用的是<code>ThradLocalMap</code>类对应的<code>get()、set()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说<code>ThreadLoca</code>的实现原理就是：</p><p><strong>每个<code>Thread</code>中度具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为key，<code>object</code>为value的键值对，我们要获取或存储变量副本的值，只需要调用<code>ThreadLocal</code> 的<code>get()/set()</code> 方法即可</strong></p></blockquote><h3 id="15-ThreadLocal的内存泄漏是怎么导致的？怎么避免？"><a href="#15-ThreadLocal的内存泄漏是怎么导致的？怎么避免？" class="headerlink" title="15. ThreadLocal的内存泄漏是怎么导致的？怎么避免？"></a>15. ThreadLocal的内存泄漏是怎么导致的？怎么避免？</h3><p>首先，<code>ThradLocal</code>为每个线程提供变量副本是基于<code>ThreadLocalMap</code>  实现的，**<code>ThreadLocalMap</code> 中的key是<code>ThradLocal</code> 的一个弱引用，如果<code>ThradLocal</code> 没有被外部强引用的话，那么就JVM发生GC的时候，key就会被清理掉，而value不会被清理掉。**</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的entry，如果不加以处理的话，<strong>value是不是就永远都不会被GC给清理掉，这个时候就会造成内存泄漏了。</strong></p><blockquote><p><strong>如何避免</strong></p><p><code>ThreadLocalMap</code> 的实现中已经考虑了内存泄漏的问题了，在调用它的<code>get()、set()、remove()</code> 方法的时候，会清理掉key为null的记录。当然，我们在使用完<code>ThreadLocal</code>之后最好还是调用一下<code>remove()</code>方法手动去释放一下比较好。</p></blockquote><h3 id="16-ThreadLocal的应用场景有哪些"><a href="#16-ThreadLocal的应用场景有哪些" class="headerlink" title="16. ThreadLocal的应用场景有哪些"></a>16. ThreadLocal的应用场景有哪些</h3><ul><li><p>应用场景一：</p><p>在我们的业务中，有一些业务是需要获取我们的当前用户的一些信息嘛。然后并发环境下，我们可以在做登录校验的时候，把一些用户相关的信息存放到我们的threadLocal中，那么当前线程的业务中，如果我们想要获取用户相关的信息，直接去threadLocal中取就行了。</p></li><li><p>应用场景二：</p><p>Spring事务管理的实现就有用到<code>ThreadLocal</code> 。</p><p>首先我们Java操作数据库的一个连接技术其实就是jdbc嘛，然后jdbc在操作数据库时，是需要获取数据库连接对象connection的，而我们对数据库的事务的开启、提交、回滚操作都是可以通过connection对象来完成的。</p><p>在Spring中，假设我们使用声明式事务来做事务管理，也就是使用<code>@Transactional</code>注解，我们的业务层的一个方法使用了@Transaction注解开启事务嘛，然后这个业务层方法分别调用了mapper层的两个操作数据库的方法test01，test02。</p><p>然后在我们的事务开启前，我们是需要从数据库连接池中获取一个connection对象的，并且把我们关闭掉事务自动提交。然后这个connection对象会存放到我们的ThreadLocal中。然后再开启事务，当我们执行test01的时候，spring会先从threadlocal中获取connection对象，然后再去执行我们的数据库操作。执行test02时也是同样的一个操作。当两个方法执行完之后，spring会从threadlocal中获取connection对象，并且判断是否发生异常，如果发生了异常就使用connection.rollback回滚，否则使用connection.commit提交事务。</p></li></ul><h3 id="17-Java加锁的方式有哪些"><a href="#17-Java加锁的方式有哪些" class="headerlink" title="17. Java加锁的方式有哪些"></a>17. Java加锁的方式有哪些</h3><p>首先在Java中是有两种类型的锁的，<strong>悲观锁和乐观锁。</strong></p><p><strong>悲观锁</strong></p><p>其中，悲观锁从字面上理解就是它是很悲观的，总是假设最坏的情况；指的就是在并发环境下，<strong>无论如何，对共享资源的访问都一定会发生并发安全问题</strong>，所以在每次获取资源操作的时候都会上锁，其他线程想拿到这个资源就必须去竞争锁。也就是说，<strong>共享资源每次只能让一个线程使用，其他线程都会进入到阻塞状态，直到获得了共享资源的线程释放掉资源，其他线程才会重新去竞争锁。</strong></p><p><strong>悲观锁思想的常见实现有：</strong></p><ul><li>Synchronized关键字实现的同步锁</li><li>Lock接口的实现子类：ReentrantLock可重入锁、ReentrantReadWriteLock可重入读写锁等。</li></ul><p><strong>乐观锁</strong></p><p>乐观锁从字面上理解就是很乐观，总是假设最好的情况。<strong>它认为在并发环境下，每次对共享资源的访问都不会发生并发安全问题，线程可以不停的执行，无需加锁也无需等待。</strong>只有在提交修改的时候去验证对应的资源（数据）是否被其他线程修改了即可（可以通过版本号机制或CAS算法实现）。</p><p>在Java中<code>atomic</code> 包下面有两个原子变量类（比如<code>AtmoicInteger</code>、<code>LongAdder</code>），就是使用了乐观锁中的一种实现方式CAS算法实现的。</p><p><strong>乐观锁思想的常见实现有：</strong></p><ul><li><p>版本号机制</p><blockquote><p>版本号机制指的就是在数据库表中加一个version字段，表示被修改的次数。当我们要执行更新操作时，就要先读取数据嘛，在读取数据时我们把version字段的值也读取，然后在提交更新的时候，只有数据库的当前版本号跟我们读取到版本号的一致时，才会更新成功，否则重试更新操作，直至更新成功</p></blockquote></li><li><p>CAS算法，CAS算法用的比较多</p><blockquote><p>CAS算法其实就是<code>Compare And Swap(比较与交换)</code>，</p></blockquote></li></ul><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="1-网络的7层架构"><a href="#1-网络的7层架构" class="headerlink" title="1. 网络的7层架构"></a>1. 网络的7层架构</h3><blockquote><p>OSI七层模型是什么？每一层的作用是什么？</p></blockquote><p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230603073012982.png" alt="image-20230603073012982"></p><h3 id="2-TCP与UDP的区别"><a href="#2-TCP与UDP的区别" class="headerlink" title="2. TCP与UDP的区别"></a>2. TCP与UDP的区别</h3><ol><li><strong>是否面向连接：</strong>UDP在传送数据之前不需要先建立连接。而TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接</li><li><strong>是否是可靠传输：</strong>远地主机在收到UDP报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP提供可靠的传输服务，TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制等机制。通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达</li><li><strong>是否有状态：</strong>与”是否可靠“相对应，TCP传输是有状态的，这个有状态说的是TCP会去记录自己发送消息的状态，比如消息是否发送了、是否被接收了等等。为此TCP需要维持复杂的连接状态表。而UDP是无状态服务，简单来说就是不管发出去之后的事情了（渣男行为）</li><li><strong>传输效率：</strong>TCP进行传输时多了连接、确认、重传等机制，所以TCP传输效率要比UDP低很多</li><li><strong>传输形式</strong>：TCP是面向字节流的，UDP是面向报文的</li><li><strong>首部开销</strong>：TCP首部开销（20~60字节）比UDP首部开销（8字节）要大</li><li><strong>是否提供广播或多播服务：</strong>TCP只支持点对点通信；UDP支持一对一、一对多、多对一、多对多通信。</li></ol><p>总结起来就是：</p><table><thead><tr><th>条件</th><th>TCP</th><th>TCP</th></tr></thead><tbody><tr><td>是否面向连接</td><td>是</td><td>否</td></tr><tr><td>是否可靠</td><td>是</td><td>否</td></tr><tr><td>是否有状态</td><td>是</td><td>否</td></tr><tr><td>传输效率</td><td>较慢</td><td>较快</td></tr><tr><td>传输形式</td><td>字节流</td><td>数据报文段</td></tr><tr><td>首部开销</td><td>20 ～ 60 bytes</td><td>8 bytes</td></tr><tr><td>是否提供广播或多播服务</td><td>否</td><td>是</td></tr></tbody></table><h3 id="3-TCP与UDP的运用场景"><a href="#3-TCP与UDP的运用场景" class="headerlink" title="3. TCP与UDP的运用场景"></a>3. TCP与UDP的运用场景</h3><ul><li><strong>UDP 一般用于即时通信</strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li><li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li></ul><h3 id="4-TCP的三次握手和四次挥手"><a href="#4-TCP的三次握手和四次挥手" class="headerlink" title="4. TCP的三次握手和四次挥手"></a>4. TCP的三次握手和四次挥手</h3><blockquote><p>这个问题可以衍生出很多经典面试题，详细见下面链接</p><p><a href="https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/network/tcp-connection-and-disconnection">TCP 三次握手和四次挥手（传输层）</a></p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>算法篇详情见</p><ul><li><a href="https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/algorithms/10-classical-sorting-algorithms">十大经典排序算法</a></li></ul></blockquote><h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><h3 id="1-Get和Post的区别？"><a href="#1-Get和Post的区别？" class="headerlink" title="1. Get和Post的区别？"></a>1. Get和Post的区别？</h3><p>Get和Post都是前后端交互的请求方式，它们之前的区别有以下四点</p><ol><li>Get是不安全的，因为在传输过程，数据被放在请求的URL中；而Post的请求数据是放在请求体中的，也就是对用户来说都是不可见的，所以Post是安全的</li><li>Get传送的数据量较小，一般传输数据大小在1k-18k之间（根据浏览器不同，限制不一样，但相差不大，主要是因为受URL长度限制）而Post传输的数据量较大，一般被默认为不受限制</li><li>Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集</li><li>Get请求效率比Post方法好。Get是form表单提交的默认方法。</li></ol><h3 id="2-HTTP中重定向和请求转发的区别？"><a href="#2-HTTP中重定向和请求转发的区别？" class="headerlink" title="2. HTTP中重定向和请求转发的区别？"></a>2. HTTP中重定向和请求转发的区别？</h3><p>它们之间的区别主要有以下四点：</p><ol><li>重定向会发送两次请求，请求转发发送一次请求</li><li>重定向地址栏会变，请求转发地址栏不变</li><li>重定向是浏览器跳转的，请求转发是服务器跳转</li><li>重定向可以跳转到任意网址，请求转发只能跳转当前项目的</li></ol><blockquote><p>两者的实现也不同</p><ul><li><p>请求转发：用request的getRequestDispatcher()方法得到RequestDispatcher对象，在调用他的forward()方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">&quot;other.jsp&quot;</span>).forword(request,response);</span><br></pre></td></tr></table></figure></li><li><p>重定向：调用response的sendRedirect()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;other.jsp&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="3-Jsp和Servlet的区别"><a href="#3-Jsp和Servlet的区别" class="headerlink" title="3. Jsp和Servlet的区别"></a>3. Jsp和Servlet的区别</h3><p><strong>相同点</strong></p><ul><li>jsp经编译后就变成了servlet，jsp本质就是servlet，jvm只能识别java的类，不能识别jsp代码，web容器将jsp的代码编译成jvm能够识别的java类。</li><li>其实就是当你通过 http 请求一个 JSP 页面时，首先 Tomcat 会将JSP翻译并编译成为 Servlet，然后执行 Servlet的生命周期方法处理请求与响应。</li></ul><p><strong>不同点</strong></p><ul><li><p>JSP侧重视图展现数据，Sevlet主要用于控制逻辑获取数据。</p></li><li><p>Servlet中没有内置对象 。</p></li><li><p>JSP中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</p></li></ul><h3 id="4-cookie和session的区别？"><a href="#4-cookie和session的区别？" class="headerlink" title="4. cookie和session的区别？"></a>4. cookie和session的区别？</h3><ol><li><p>存储位置不同</p><p>cookie的数据信息存放在客户端浏览器上。</p><p>session的数据信息存放在服务器上。</p></li><li><p>存储容量不同</p><p>单个cookie保存的数据&lt;&#x3D;4KB，一个站点一般保存20~50个Cookie（不同浏览器不一样，Sarafi和Chrome对每个域的Cookie数目没有严格限制）</p><p>对于session来说并没有数据上限，但出于对服务器端性能考虑，session内不要存放过多的东西，并且设置session删除机制（或者采用缓存技术代替session）</p></li><li><p>存储方式不同</p><p>cookie只能保存ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</p><p>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</p></li><li><p>隐私策略不同</p><p>cookie对客户端是可见的，容易被分析本地cookie并且进行cookie欺骗，所以不安全。</p><p>session存储在服务器上，不存在敏感信息泄露的风险。</p></li><li><p>有效期上不同</p><p>开发者可以通过设置cookie的属性，达到是cookie长期有效的效果。</p><p>session依赖于名为<code>JSESSIONID</code>的cookie，而且设置了过期时间默认为-1，只需要关闭窗口该session就会失效，因而session不能达到长期有效的效果</p></li><li><p>服务器压力不同</p><p>cookie存储在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</p><p>session是保管在服务端的，每个用户都会产生一个session。加入并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</p></li></ol><h3 id="5-什么是Ajax，Ajax有什么优点"><a href="#5-什么是Ajax，Ajax有什么优点" class="headerlink" title="5. 什么是Ajax，Ajax有什么优点"></a>5. 什么是Ajax，Ajax有什么优点</h3><p>Ajax全称为”Asynchronous JavaScript And XML”（异步 JavaScript 和 XML），是指一种创建交互方式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更快更新部分网页的技术。</p><p>优点：</p><ul><li>通过异步模式，可以提升用户的体验</li><li>优化了浏览器和服务器之前的传输，减少了不必要的数据往返，减少了带宽占用。</li></ul><h3 id="5-JavaWeb的三大组件"><a href="#5-JavaWeb的三大组件" class="headerlink" title="5. JavaWeb的三大组件"></a>5. JavaWeb的三大组件</h3><ul><li>Servlet：用于处理请求与响应</li><li>Filter：用于拦截请求与响应</li><li>Lisenter：用于监听三大域对象request、session、servletContext的创建与销毁，和域中数据发生变化的时候会调用监听器实现逻辑控制。</li></ul><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="1-IOC、DI、AOP"><a href="#1-IOC、DI、AOP" class="headerlink" title="1. IOC、DI、AOP"></a>1. IOC、DI、AOP</h3><p>IOC和AOP是Spring的两大核心。</p><ul><li><p><strong>IOC(Inversion of Control)：</strong>IOC其实是一种设计思想，是指我们在创建对象的时候，将对象的控制权交给Spring容器来管理。在这之前，我们创建对象的主动权和时机都是由自己去决定的，而现在这种全力转移到Spring容器中，并由容器根据配置文件或者注解去创建实例和管理各个实例之间的依赖关系了，这样做可以在一定程度上降低对象与对象之间的耦合性，同时也提高了功能的复用<strong>（创建对象的解耦）。</strong></p><blockquote><p>比如：在没有IOC之前，我们业务层bookService要调用dao层的实现方法bookDaoImplA时，我们只需要new一个bookDaoImplA的实例对象即可。但是在某一天我们收到一个需求，要将bookDaoImpA的实现换成bookDaoImplB了，我们就要去修改bookService中的对应的实现，牵一发而动全身，每次修改都有可能要修改大量的代码，这样的设计耦合性太高了，所以才有IOC的出现。</p></blockquote></li><li><p><strong>DI：</strong>DI其实就是IOC的一种实现方式，即应用程序在运行时依赖IOC容器来动态的注入外部资源<strong>（赋值或使用对象的解耦）。</strong></p></li><li><p><strong>AOP(Aspect Oriented Programming)：</strong>AOP指的是面向切面编程，在开发中，会有一些与业务无关但每个业务的需要的逻辑方法，例如日志记录、事务控制、异常处理等。在AOP中，我们可以将这个逻辑代码分别抽取并封装成不同的模块，这些模块在AOP中也被称为“切面”。这样做可以减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring 的AOP是基于动态代理和cglib代理模式的，如果要代理的对象是一个接口，我们就可以通过JDK动态代理来给该对象创建一个代理对象。而如果我们要代理的对象是一个类，我们就要使用cglib代理来创建代理对象了。</p></li></ul><h3 id="2-Spring框架中用到了哪些设计模式？"><a href="#2-Spring框架中用到了哪些设计模式？" class="headerlink" title="2. Spring框架中用到了哪些设计模式？"></a>2. Spring框架中用到了哪些设计模式？</h3><p><strong>工厂设计模式：</strong>Spring使用工厂模式通过<code>BeanFactory</code>、<code>ApplicationContext</code> 创建Bean对象</p><p><strong>代理设计模式：</strong>Spring Aop功能就是基于代理模式实现的，如果要代理的对象实现了某个接口，Spring 会使用JDK动态代理来创建代理对象；对于没有实现接口的对象，Spring会使用cglib代理生成一个被代理对象的子类；</p><blockquote><p><strong>因为JDK动态代理创建代理对象时，是基于实现<code>$Proxy</code>类来创建的</strong></p></blockquote><p><strong>单例设计模式：</strong>Spring中的Bean默认都是单列的。Spring在底层是通过<code>ConcurrentHashMap</code> 实现单例注册表的特殊方式来实现单例模式的。</p><p><strong>模板方法设计模式：</strong> 所谓模板方法设计模式就是将一些通用的代码抽取抽来，作为一个模板，然后提供一些通用的方法给外界使用。就比如说<code>jdncTemplate</code> 、<code>RedisTemplate</code> 等以Template结尾的类，都是用到了模板方法设计模式的。</p><p><strong>包装器设计模式：</strong> </p><p><strong>观察者模式：</strong> Spring事件驱动模型就是观察者模式很经典的一个应用。</p><p><strong>适配器模式：</strong>大家都知道SpringAOP是基于动态代理实现的，但是SpringAOP中的增强是使用到了适配器模式的；</p><p>所谓适配器模式，指的是将一个类或接口转换成我们希望的的另外一个接口，适配器模式通俗点来说就是用来做兼容的，就好比如说我们生活中大家都有可能用到的一拖三充电线其实就是适配器模式的一种体现。</p><p>而SpringAOP中，BeforeAdvice、AfterAdvice、ThrowAdvice三种类型的通知都是基于适配器模式实现的。</p><blockquote><p>因为上述的几个类型的通知，</p></blockquote><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="1-MyISAM和InnoDB有什么区别"><a href="#1-MyISAM和InnoDB有什么区别" class="headerlink" title="1. MyISAM和InnoDB有什么区别?"></a>1. MyISAM和InnoDB有什么区别?</h3><p>在MySQL5.5之前，MyISAM是MySQl的默认存储引擎。虽然MyISAM的性能还行，各种特性也还不错(比如全文所以、压缩、空间函数等)。但是，由于MyISAM不支持事务以及行级锁，并且最大的缺陷就是崩溃后无法安全恢复。InnoDB正好解决了这些问题。</p><p>所以MySQL5.5之后，InnoDB是MySQL的默认存储引擎</p><p>两者的区别主要有七点</p><ol><li><p>是否支持行级锁</p><p>MyISAM只支持表级锁，而InnoDB支持表级锁以及行级锁，默认是行级锁。</p><p>也就说，MyISAM一锁就会锁住了整张表，而InnoDB可以根据具体的场景选择锁整张表还是锁住一行，这也是InnoDB在并发写时厉害之处。</p></li><li><p>是否支持事务</p><p>MyISAM不提供事务支持。</p><p>InnoDB提供事务支持，实现了SQL标准定义的四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。InnoDB默认使用的是<code>REPEATABLE-READ</code>（可重复读）的隔离级别，而InnoDB基于MVCC(多版本并发控制)控制和Next-Key Lock解决了幻读问题</p><blockquote><p>Next-Key Lock</p><p>Next-Key Lock是行级锁的基本单位，它是记录锁(Record Lock)和间隙锁(Gap Lock)的结合体。</p></blockquote></li><li><p>是否支持外键</p><p>MyISAM不支持外键，而InnoDB支持外键</p><p>虽然外键对于维护数据的一致性非常有帮助，但是对性能有一定的损耗的。</p><p>一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p></li><li><p>是否支持数据库异常崩溃后的安全恢复</p><p>MyISAM不支持，而InnoDB支持。</p><p>使用InnoDB的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。而这个恢复的过程是依赖于<code>redo log</code>。</p></li><li><p>是否支持MVCC</p><p>MyISAM不支持，而InnoDB支持。</p><p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p></li><li><p>索引的实现不一样</p><p>虽然MyISAM引擎和InnoDB引擎都是使用B+Tree作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB引擎中，其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的。</p></li><li><p>性能有差别。</p><p>InnoDB的性能比MyISAM更强大，不管是在读写混合模式下还是只读模式下，随着CPU核数的增加，InnoDB的读写能力呈线性增长。MyISAM因为读写不能并发，它的处理能力跟核数没有关系。</p></li></ol><p><strong>总结：</strong></p><ul><li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li><li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li><li>MyISAM 不支持外键，而 InnoDB 支持。</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>InnoDB 的性能比 MyISAM 更强大。</li></ul><h3 id="2-你知道ACID吗（事务的特性）"><a href="#2-你知道ACID吗（事务的特性）" class="headerlink" title="2. 你知道ACID吗（事务的特性）"></a>2. 你知道ACID吗（事务的特性）</h3><p>ACID是事务的四个特性，分别是：原子性、一致性、隔离性、持久性。</p><ul><li><strong>原子性(Atomicity)：</strong>事务值最小的执行单位，不允许分割。事务的原子性确保动作要么全部被执行，要么全部不起作用。</li><li><strong>一致性(Consistency)：</strong>事务实行前后，数据要保持一致。比如说在转账业务中，无论事务成功与否，转账者和收款人的总额是不变的。</li><li><strong>隔离性 (Isolation)：</strong>在并发访问数据库时，会产生多个事务，在这个过程中，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库时独立的。</li><li><strong>持久性(Durability)：</strong>一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库产生故障也不应该对其有任何影响</li></ul><blockquote><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p></blockquote><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ol><li><strong>读未提交（read Uncommited）：</strong>最低的隔离界别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、或不可重复度</li><li><strong>读已提交（READ-COMMITTED）：</strong>大多数数据库的默认隔离级别，该隔离级别允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复度仍有可能发生。</li><li><strong>可重复读（REPEATABLE-READ）：</strong>指的是对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复度，但幻读仍有可能发生，因为幻读是发生在DQL中的。这个隔离级别是MySQL默认的隔离级别，<strong>而MySQL在使用InnoDB数据库引擎后利用了MVCC（多版本并发控制机制）以及Next-Key lock 锁解决了幻读的问题。</strong></li><li><strong>可串行化（SERIALIZABLE）：</strong>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。虽然该隔离级别可以防止脏读、不可重复读以及幻读，但是需要付出的代价太高了，因为他是在每个读的数据行上加锁的，可能会导致大量的超时现象和锁竞争，一般为了提升程序的吞吐量不会采用这个；</li></ol><h3 id="3-脏读、幻读、不可重复读"><a href="#3-脏读、幻读、不可重复读" class="headerlink" title="3. 脏读、幻读、不可重复读"></a>3. 脏读、幻读、不可重复读</h3><ul><li><p><strong>脏读（Dirty read）</strong></p><p>当一个事务读取数据并且对数据进行了修改时，这个修改对其他事务来说是可见的，即使当前事务还没有提交。这时，如果另外一个事务读取了这个还未提交的数据，并且第一个事务突然回滚，导致数据并没有被提交到数据库，那么第二个事务读取到的就是一个脏数据了，这也是脏读的由来</p><blockquote><p>例如：事务1读取某表中的数据A &#x3D; 20， 然后事务1修改A &#x3D;A-1，也就是19。在这个时候，事务2也读取这张表的数据A ，并且读取到的数据是A &#x3D; 19，如果此时事务1突然回滚了，也就是A修改的数据没有被提交到数据库，即A &#x3D; 20，但是事务2读取到的还是19，这就是脏读。</p></blockquote></li><li><p><strong>不可重复读（Unrepeatable read）</strong></p><p>在一个事务内读取同一个数据时，如果在这个事务还没结束的时候，有另外一个事务也访问了这个数据，那么在第一个事务的两次读取这个数据之间，由于第二个事务对数据的修改，会导致第一个事务两次读取到的数据可能不太一样。这就发生了一个事务内连续读取到的数据不一样的情况，因此称为不可重复读。</p><blockquote><p>例如：事务1读取了某表的数据A &#x3D; 20，在事务1还没结束的时候，事务2也读取了这个数据A &#x3D; 20，同时对A进行了修改 A &#x3D; 19，并且提交了事务2。而这时如果事务1再次读取数据A，读取到的数据会为A &#x3D; 19，也就是说两次读取的数据都是不一样的。</p></blockquote></li><li><p><strong>幻读（Phantom read）</strong></p><p>幻读其实可以看作不可重复读的一种。它发生在一个事务读取了几行数据，接着另外一个并发事务插入了一些数据时。在随后的查询中，第一个失误就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称之为幻读。</p><blockquote><p>例如：事务2想要统计某张表的一个数据，就比如说一开始的count(*) &#x3D; 20嘛，然后这个时候事务1在这张表中插入了新的数据，那么这个时候事务2再次统计的count(*)&#x3D;21了，也就是说他啥也不知道，就读到多一行数据了</p></blockquote></li></ul><h3 id="4-连接查询"><a href="#4-连接查询" class="headerlink" title="4. 连接查询"></a>4. 连接查询</h3><p>在MySQL中，连接查询可以分为内连接和外连接。</p><p>内连接：内连接有隐式内连接和显示内连接两种</p><ul><li>隐式内连接：隐式内连接其实就是指我们连接查询时在from后面用逗号分隔两张变的连接查询</li><li>显示内连接：显示内连接指的就是我们是用inner join…on进行表连接的一个操作</li></ul><p>外连接：有左外连接和右外连接两种</p><ul><li>左外连接指的就是我们在连接查询时，以左表为基准去连接我们的另外一张表，然后他们的连接后的结果集就是左表的全部内容加上左表与右表的一个交集。连接的关键字为<code>left join...on</code></li><li>右外连接指的就是我们在连接查询时，以右表为基准去连接我们的另外一张表，然后他们的连接后的结果集就是右表的全部内容加上左表与右表的一个交集。连接的关键字为<code>right join...on</code></li></ul><h3 id="5-聚合函数"><a href="#5-聚合函数" class="headerlink" title="5. 聚合函数"></a>5. 聚合函数</h3><p>SQL中提供聚合函数有五种：</p><ol><li>COUNT：统计行数量</li><li>SUM：获取某个列的合计值</li><li>AVG：计算某个列的平均值</li><li>MAX：计算列的最大值</li><li>MIN：计算列的最小值</li></ol><h3 id="6-SQL关键字以及执行顺序"><a href="#6-SQL关键字以及执行顺序" class="headerlink" title="6. SQL关键字以及执行顺序"></a>6. SQL关键字以及执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">... </span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">...<span class="built_in">avg</span>()<span class="operator">/</span><span class="built_in">sum</span>()</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">...</span><br><span class="line">SELETE</span><br><span class="line">...</span><br><span class="line"><span class="keyword">distinct</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">...</span><br><span class="line">limit</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="7-有了解过MySQL的所有嘛"><a href="#7-有了解过MySQL的所有嘛" class="headerlink" title="7. 有了解过MySQL的所有嘛?"></a>7. 有了解过MySQL的所有嘛?</h3><p>MySQL中的索引主要有单列索引、组合索引、空间索引三种。用的比较多的是单列索引和组合索引，空间索引我这边目前还没有用过</p><p><strong>单列索引：</strong> 在MySQL表中的某一个列上创建的索引叫做单列索引。单列索引还分为：普通索引、唯一索引、主键索引、全文索引四种。</p><ul><li>普通索引：是MySQL基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹是为了提升查询效率。</li><li>唯一索引：唯一索引的索引列必须的值必须是唯一的，但是允许有控制</li><li>主键索引：主键索引其实就跟我们主键的特性类似嘛，需要确保索引列中的值时唯一的且不能为null</li><li>全文索引：全文索引比较特殊，只有在MyISAM引擎、InnoDB上才能使用，并且只能在CHAR、VARCHAR、TEXT类型的字段上才能使用。</li></ul><p><strong>组合索引：</strong> 组合索引又叫联合索引，指的是将多个字段联合起来去创建索引。</p><ul><li><p>组合索引的使用，需要遵循左前缀原则</p></li><li><p>一般情况下，建议使用组合索引代替单列索引（主键索引除外）</p><blockquote><p>因为我们业务中的大部分查询都是涉及到多个字段的，组合索引比较于单列索引来说磁盘的IO操作和排序操作更少了，从而提高了查询效率</p></blockquote></li></ul><p>在设计数据库表时，如果经常需要在多个列上进行组合查询，那么使用组合索引可以显著提升查询效率。比如在订单表中，每次查询都要查询订单的状态和下单时间，那么我们就可以在这两个字段上添加一个组合索引，以提高查询效率。</p><h3 id="8-什么是左前缀原则"><a href="#8-什么是左前缀原则" class="headerlink" title="8. 什么是左前缀原则"></a>8. 什么是左前缀原则</h3><p>在MySQL建议联合索引时会遵循左前缀原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，组合索引的第一个字段必须出现在查询语句中，这个索引才会被用到；</p><p>例如：<code>create index index_age_name_sex on tb_user(age, name, sex)</code> ;</p><p>上述SQL语句中，对<code>age、name、sex</code> 建立了一个组合索引<code>index_age_name_sex</code> ，实际上这个联合索引相当于<code>(age)、(age，name)、(age, name, sex)</code> 三个索引。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/moon-4919501_1920.jpg&quot; alt=&quot;moon&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;以下是我对Java高频面试题的一个总结，后面我会持续更新，希望对你有所帮助。&lt;br&gt;当然，如果有哪道题目我理解错误了，或者是你有更好的见解，非常欢迎你在评论区中留下宝贵的意见！&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试题" scheme="https://minster.top/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://minster.top/tags/Java/"/>
    
    <category term="interview" scheme="https://minster.top/tags/interview/"/>
    
    <category term="持续更新" scheme="https://minster.top/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程编程中的等待和休眠：wait() 和 sleep() 方法解析</title>
    <link href="https://minster.top/2023/05/27/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E4%BC%91%E7%9C%A0%EF%BC%9Await-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <id>https://minster.top/2023/05/27/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E4%BC%91%E7%9C%A0%EF%BC%9Await-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/</id>
    <published>2023-05-27T00:49:12.000Z</published>
    <updated>2023-05-27T02:56:37.430Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/640.png" alt="640"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在Java多线程中，线程的状态如上图所示（图来自<a href="https://javaguide.cn/">JavaGuide</a>），可以发现，当前线程调用<code>wait(long time)</code>方法或者执行<code>Thread.sleep(long time)</code>方法都会进入到一个<code>TIMED_WAITING</code>的状态。那么，这个状态下的线程的锁资源是怎么样的呢？</p><span id="more"></span><h2 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h2><p>在多线程环境下，如果当前线程调用了wait()方法，那么该方法会进入到<code>WAITING</code>状态，并释放它所持有的锁，等待其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法来唤醒它。如果没有其唤醒操作，当前线程会处于一个无限等待的状态。</p><p>如果当前线程在调用的是<code>wait(long time)</code>方法时，线程会进入到一个<code>TIMED_WAITING</code>状态，同时会释放锁资源，等待其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法来唤醒它，或者等待指定的时间过期后自动唤醒。在等待期间，该线程不会占用 CPU 资源，因此其他线程可以执行。</p><p>代码演示：</p><p><strong>WaitingThread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WaitingThread</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;获取到了锁资源&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待2秒钟，释放锁资源</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() +<span class="string">&quot;线程等待2s.....释放锁&quot;</span>);</span><br><span class="line">                lock.wait(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 等待时间过去，唤醒，尝试重新获取锁资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>WaitingTest类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">WaitingThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitingThread</span>(lock);</span><br><span class="line">        <span class="type">WaitingThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitingThread</span>(lock);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230527102116952.png" alt="image-20230527102116952"></p><p>上述代码中，我们创建了两个线程，并将它们传递给同一个锁对象。在<code>run()</code>方法中，线程首先使用<code>synchronized</code>关键字获取锁对象，然后调用<code>wait(long time)</code>方法进入<code>TIMED_WAITING</code>状态，等待2秒钟后会自动唤醒，此时，锁对象已经被释放，线程需要重新获取锁才能继续执行。可以看到，在线程重新获取锁之后，它就可以继续执行对共享数据的操作了。</p><h2 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h2><p>当线程调用<code>sleep(long time)</code>方法时，该线程也会进入到<code>TIMED_WAITING</code>状态，但是当前线程对象并不会释放锁资源，因此其他线程对象也无法获取到锁资源，会进入阻塞状态。</p><p>当指定的休眠时间过期之后，当前线程会主动唤醒，并且该线程仍然持有锁资源，可以继续执行。</p><p>代码演示：</p><p><strong>SleepingThread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SleepingThread</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;获取到了锁资源&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() +<span class="string">&quot;线程休眠2s.....仍持有锁&quot;</span>);</span><br><span class="line">                <span class="comment">// 线程休眠2秒钟，进入TIMED_WAITING状态</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 休眠时间过去，自动唤醒，继续执行&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SleepingTest类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepingTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">SleepingThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepingThread</span>(lock);</span><br><span class="line">        <span class="type">SleepingThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepingThread</span>(lock);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230527105237869.png" alt="image-20230527105237869"></p><p>在上面的代码中，我们创建了两个线程，并将它们传递给同一个锁对象。在线程的run()方法中，我们首先使用synchronized关键字来获取锁对象，然后让线程进入TIMED_WAITING状态。在这里，线程会休眠2秒钟，然后再输出一条消息。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当线程调用<code>wait()</code>方法时，线程会进入一个<code>WAITING</code>状态，并且释放锁资源，直至被唤醒才会进入到就绪状态，竞争锁资源。</p><p>当线程调用<code>wait(long time)</code>方法时（指定一个等待时间），线程会进入到一个<code>TIMED_WAITING</code>状态，同时释放锁资源，只有当线程被通知或者等待时间结束后才会重新去获取锁资源。</p><p>当线程调用的是<code>sleep(long time)</code>方法，线程虽然也会进入到一个<code>TIMED_WAITING</code>状态，但是不会释放锁资源，其他线程会处于阻塞状态直至当前线程释放锁资源</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/640.png&quot; alt=&quot;640&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在Java多线程中，线程的状态如上图所示（图来自&lt;a href=&quot;https://javaguide.cn/&quot;&gt;JavaGuide&lt;/a&gt;），可以发现，当前线程调用&lt;code&gt;wait(long time)&lt;/code&gt;方法或者执行&lt;code&gt;Thread.sleep(long time)&lt;/code&gt;方法都会进入到一个&lt;code&gt;TIMED_WAITING&lt;/code&gt;的状态。那么，这个状态下的线程的锁资源是怎么样的呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Java多线程" scheme="https://minster.top/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://minster.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Thread" scheme="https://minster.top/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot如何实现基于注解配置</title>
    <link href="https://minster.top/2023/05/26/Spring-Boot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE/"/>
    <id>https://minster.top/2023/05/26/Spring-Boot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-26T11:46:12.000Z</published>
    <updated>2023-05-26T13:04:21.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在使用Spring注册Bean时，有很多方式，其中两种常用的配置方式如下</p><p><strong>基于注解的配置</strong>：使用注解来定义 bean，如  <code>@Component</code> 、 <code>@Autowired</code> 、 <code>@Configuration</code>  等。这种方式相比于基于 XML 的配置更加简洁、易于阅读和维护，也是目前比较流行的一种方式。</p><p><strong>基于 Java 配置类的配置</strong>：使用 Java 类来定义 bean 和它们之间的依赖关系，如  <code>@Bean</code> 、 <code>@Configuration</code> 、 <code>@Import</code>  等。这种方式也是基于注解的配置方式的一种扩展形式，它允许我们使用 Java 代码来定义 bean，从而更加灵活地控制应用程序的配置。 </p><p><strong>不难发现，上述两种配置方式的核心都是基于注解实现的，只是应用场景不同。</strong></p><p>而我在使用基于Java配置类的配置时，发现在Spring中需要直接或间接实现<code>AnnotationConfigRegistry</code>接口时才能应用基于注解的配置方式；于是我便开始思考：Spring Boot是怎么实现的呢？通过查阅资料以及源码后，以下是我的拙见。</p><span id="more"></span><h2 id="Spring使用注解-Java配置类-配置Bean"><a href="#Spring使用注解-Java配置类-配置Bean" class="headerlink" title="Spring使用注解(Java配置类)配置Bean"></a>Spring使用注解(Java配置类)配置Bean</h2><p>在Spring中，我们若想简单使用基于注解的配置方式，需要完成以下几步：</p><ol><li><p>创建SpringConfig配置类作为传递参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;org.heng.dao&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring创建容器时或根据该配置类上的注解信息来配置和创建引用程序上下文中的Bean。这样做可以省去XML配置的繁琐过程。</p><p><strong>JdbcConfig</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc:mysql://localhost:3306//spring_db&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;123456&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(BookDao BookDao)</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Application启动类上使用<code>AnnotationConfigApplicationContext</code>类来创建容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> context.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中我们将SpringConfig配置类作为参数传入到<code>AnnotationConfigApplicationContext</code>类中，该类会根据接收到的参数来创建容器</p></li><li><p>通过上述代码，我们如果有其他Java配置类，只需要在配置类中写好配置信息后在SpringConfig类中的<code>@Import</code>注解上导入即可，不需要在XML中配置了。</p></li></ol><h2 id="Spring-Boot为什么可以使用基于注解的配置方式？"><a href="#Spring-Boot为什么可以使用基于注解的配置方式？" class="headerlink" title="Spring Boot为什么可以使用基于注解的配置方式？"></a>Spring Boot为什么可以使用基于注解的配置方式？</h2><p>在完成上述的Spring使用基于注解的配置方式完成配置之后，我在想SpringBoot是如何实现的呢，于是乎我去查看了一下SpringBoot的源码</p><p>在启动类中，我进入到SpringBootApplication类中，发现它没有继承任何类，于是我找到run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我本来以为un()方法中返回的<code>ConfigurableApplicationContext</code>会直接或者间接实现<code>AnnotationConfigRegistry</code>接口的，从而实现Spring Boot基于注解的配置的。于是我查看<code>ConfigurableApplicationContext</code>的类图，发现其并没有直接或间接实现上述的接口。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520162648142.png" alt="image-20230520162648142"></p><p>然后我继续查阅源码，找到了创建创建Spring应用上下文的方法<code>createApplicationContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title function_">createApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.applicationContextFactory.create(<span class="built_in">this</span>.webApplicationType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看不出来什么端倪，于是乎我看到方法上面的注释</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520163608571.png" alt="image-20230520163608571"></p><p>这段注释的大概内容为</p><blockquote><p>这个方法使用了一个策略模式，它会根据应用程序上下文工厂（ApplicationContextFactory）来创建应用程序上下文。如果应用程序上下文工厂被设置了，它会使用这个工厂来创建应用程序上下文；否则，它会使用适当的默认实现来创建应用程序上下文。</p></blockquote><p>然后注释底部链接跳转了一个方法<code>setApplicationContextFactory</code>，我们继续追踪源码，查看该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContextFactory</span><span class="params">(ApplicationContextFactory applicationContextFactory)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.applicationContextFactory = (applicationContextFactory != <span class="literal">null</span>) ? applicationContextFactory</span><br><span class="line">         : ApplicationContextFactory.DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现<code>setApplicationContextFactory</code>方法是用来设置<strong>ApplicationContextFactory</strong>的，查看该方法的注释</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520164231835.png" alt="image-20230520164231835"></p><p>我们可以发现我们在创建Spring应用程序上下文时，如果设置了ApplicationContextFactory，则根据设置的Factory来创建Spring应用程序上下文。如果没有设置，根据应用程序的类型自动选择创建相应的ApplicationContext实现类，其中包括</p><ul><li><p><strong>对于基于Servlet的Web应用程序</strong></p><p>创建<code>AnnotationConfigServletWebServerApplicationContext</code>实例。</p></li><li><p><strong>对于基于Reactive的Web应用程序</strong></p><p>创建<code>AnnotationConfigReactiveWebServerApplicationContext</code>实例。</p></li><li><p><strong>对于非Web应用程序</strong></p><p>创建<code>AnnotationConfigApplicationContext</code>实例。</p></li></ul><p>而上述三个实现类，都实现了<code>AnnotationConfigRegistry</code>接口！所以，Spring Boot可以使用基于注解的配置方式的原因就在这里！</p><h3 id="在开发中怎么设置ApplicationContextFactory"><a href="#在开发中怎么设置ApplicationContextFactory" class="headerlink" title="在开发中怎么设置ApplicationContextFactory"></a>在开发中怎么设置ApplicationContextFactory</h3><p>在Spring Boot应用程序中，可以通过继承SpringApplication类并重写其createApplicationContextFactory方法，来自定义应用程序上下文的创建过程，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">SpringApplication</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ApplicationContextFactory <span class="title function_">createApplicationContextFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> <span class="title class_">MyWebApplicationContext</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<strong>MyApplication类继承了SpringApplication类</strong>，并重写了其<strong>createApplicationContextFactory</strong>方法，返回一个lambda表达式，该表达式返回一个自定义的ApplicationContext实现类MyWebApplicationContext的实例。通过这种方式，可以在Spring Boot应用程序中自定义应用程序上下文的创建过程，满足不同的应用场景需求。</p><h2 id="AnnotationConfigRegistry接口的作用和意义（补充）"><a href="#AnnotationConfigRegistry接口的作用和意义（补充）" class="headerlink" title="AnnotationConfigRegistry接口的作用和意义（补充）"></a>AnnotationConfigRegistry接口的作用和意义（补充）</h2><p><code>AnnotationConfigRegistry</code>  接口是 Spring Framework 中的一个接口，它继承了  <code>BeanDefinitionRegistry</code>  接口，并增加了一些注册的方法。主要作用是用于注册基于注解的配置类（如  <code>@Configuration</code>  注解的类）。   </p><p>该接口的意义在于为开发者提供了一种便捷的方式，用于将基于注解的配置类注册到 Spring 容器中。在使用基于注解的配置时，开发者需要将其所在的类注册到 Spring 容器中，通常是通过  <code>AnnotationConfigApplicationContext</code>  或者其他类似的上下文来实现。而这些上下文都实现了  <code>AnnotationConfigRegistry</code>  接口，因此可以调用该接口中的方法来实现注册。  </p><p> <code>AnnotationConfigRegistry</code>  接口中的方法有：</p><ul><li><p><code>register(Class&lt;?&gt;... annotatedClasses)</code> ：注册一个或多个基于注解的配置类。 </p></li><li><p><code>scan(String... basePackages)</code> ：扫描指定的包（及其子包）下的所有 Bean 定义，并将其加入到 Spring 容器中。</p></li></ul><p>通过使用  <code>AnnotationConfigRegistry</code>  接口，开发者可以更加灵活地管理基于注解的配置类，并将其注册为 Spring Bean，从而实现更加方便、简单、快捷的配置方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Spring Boot启动时，它会通过SpringApplication类的createApplicationContext方法来创建Spring应用程序上下文。如果设置了ApplicationContextFactory，它将使用该工厂来创建Spring应用程序上下文，否则将根据应用程序的类型自动选择创建相应的ApplicationContext实现类。</p><p>Spring Boot基于注解的配置方式的实现原理是基于ApplicationContextFactory接口和AnnotationConfigRegistry接口结合实现的。ApplicationContextFactory接口用于创建Spring应用程序上下文的工厂，而AnnotationConfigRegistry接口则是用于注册基于注解的配置类的接口。这两者的结合使得Spring Boot能够使用基于注解的配置方式，从而简化了应用程序的配置过程。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们在使用Spring注册Bean时，有很多方式，其中两种常用的配置方式如下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于注解的配置&lt;/strong&gt;：使用注解来定义 bean，如  &lt;code&gt;@Component&lt;/code&gt; 、 &lt;code&gt;@Autowired&lt;/code&gt; 、 &lt;code&gt;@Configuration&lt;/code&gt;  等。这种方式相比于基于 XML 的配置更加简洁、易于阅读和维护，也是目前比较流行的一种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于 Java 配置类的配置&lt;/strong&gt;：使用 Java 类来定义 bean 和它们之间的依赖关系，如  &lt;code&gt;@Bean&lt;/code&gt; 、 &lt;code&gt;@Configuration&lt;/code&gt; 、 &lt;code&gt;@Import&lt;/code&gt;  等。这种方式也是基于注解的配置方式的一种扩展形式，它允许我们使用 Java 代码来定义 bean，从而更加灵活地控制应用程序的配置。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不难发现，上述两种配置方式的核心都是基于注解实现的，只是应用场景不同。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而我在使用基于Java配置类的配置时，发现在Spring中需要直接或间接实现&lt;code&gt;AnnotationConfigRegistry&lt;/code&gt;接口时才能应用基于注解的配置方式；于是我便开始思考：Spring Boot是怎么实现的呢？通过查阅资料以及源码后，以下是我的拙见。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="https://minster.top/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="https://minster.top/tags/Spring-Boot/"/>
    
    <category term="底层原理" scheme="https://minster.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>懒汉式单例模式下的双检锁机制的理解</title>
    <link href="https://minster.top/2023/05/26/%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%8F%8C%E6%A3%80%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://minster.top/2023/05/26/%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%8F%8C%E6%A3%80%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2023-05-26T11:39:13.000Z</published>
    <updated>2023-05-26T11:42:09.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在学习懒汉式单例模式时，发现了懒汉双检锁的实现方式，当时不是很理解，查阅资料后得出以下结论</p><span id="more"></span><h2 id="双检锁机制"><a href="#双检锁机制" class="headerlink" title="双检锁机制"></a>双检锁机制</h2><p>在多个线程同时请求一个获取一个懒汉式单例对象时，可能会导致创建多个对象的问题，为了确保只有一个对象被创建，可以使用双检锁机制。（双检锁机制不是创建两个锁实现，而是再方法内部实现两种检锁）</p><p>双检锁机制基于懒汉模式，在第一次获取单例对象时才创建它；</p><p>为了提高程序的性能，我们不在方法前使用syschronized关键字，而是在方法内部使用，同时也在方法内部实现了双重检查锁定机制。</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//第一重检锁</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//第二重检锁，只有uniqueInstance为null时才会生效</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在双检锁机制中，我们使用了synchronized关键字来创建一个锁，确保只有一个线程能进入if语句块内部。在此之前，我们首先检查uniqueInstance变量是否为null。如果为null我们才进入if语句块，获取锁，并再次检查uniqueInstance变量是否为null。这是因为在多线程环境下，可能会有多个线程同时进入第一个if语句块，如果不在此检查uniqueInstance变量是否为null，就有可能会创建多个Singleton对象，违反了单例模式的原则。</p><p>一旦我们进入了if语句块，获取了锁，就可以创建唯一的Singleton对象。其他线程尝试进入if语句块时，由于uniqueInstance变量已经不为null，所以它们不会执行if语句块内的代码，而是直接返回uniqueInstance变量的值。</p><p>在整个过程中，synchronized关键字可以确保只有一个线程能够访问if一句话内的代码，在这之前和之后，uniqueInstance变量由于是用volatile关键字进行了修饰，可以被确保它在多线程环境下的可见性，从而避免了问题的发生。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>除了单例模式之外，它还可以用于其他需要保证线程安全的场景。例如，我们可以使用双检锁机制来确保在多线程环境下只创建一个实例化某个对象的方法。<br>双检锁机制在多线程环境下会有比较好的性能表现，因为它只在第一次创建对象时使用synchronized关键字来获取锁，在之后的访问中不需要获取锁，因此避免了不必要的开销。如果在多线程环境下需要频繁创建对象，使用双检锁机制会比使用简单的synchronized关键字更加高效。<br>需要注意的是，虽然双检锁机制可以确保在多线程环境下只创建一个对象，但是如果对象的初始化操作耗时较长，可能会造成性能问题。此外，还需要注意正确使用volatile关键字，确保变量的可见性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，双检锁机制是一种比较常见的保证线程安全的方式，可以用于单例模式等需要确保只有一个对象被创建的场景。在使用双检锁机制时，需要注意并发情况下的安全性和性能问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我在学习懒汉式单例模式时，发现了懒汉双检锁的实现方式，当时不是很理解，查阅资料后得出以下结论&lt;/p&gt;</summary>
    
    
    
    <category term="Design Patterns" scheme="https://minster.top/categories/Design-Patterns/"/>
    
    
    <category term="Singleton Pattern" scheme="https://minster.top/tags/Singleton-Pattern/"/>
    
    <category term="Lazy Singleton" scheme="https://minster.top/tags/Lazy-Singleton/"/>
    
    <category term="Design Patterns" scheme="https://minster.top/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>My First Blog</title>
    <link href="https://minster.top/2023/05/26/My-First-Blog/"/>
    <id>https://minster.top/2023/05/26/My-First-Blog/</id>
    <published>2023-05-26T09:08:15.000Z</published>
    <updated>2023-05-26T11:29:16.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我一直都想搭建一个用于记录生活和学习的博客，但是碍于懒惰，一直拖延到现在。直到昨天我在浏览Github的开源项目时，我看到了<a href="https://crossoverjie.top/">杰哥</a>的个人博客，很佩服<a href="https://crossoverjie.top/">杰哥</a>的经历，所以我也决定搭建一个博客来记录自己在工作中遇到的问题以及自己学习技术的一个理解等。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我是一名Java菜鸟程序员，我在学习Java的时候一直有使用MarkDown去记录笔记。而我在之前也搭建一个基于<a href="https://minster77.github.io/">Hugo的博客</a>，上面的文章都是一些学习笔记，比较合适于初学Java的朋友们。</p><h2 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h2><p>在这个博客中，我将主要分享关于Java技术的一些知识和个人理解，也会分享一些编程技巧和实践经验。</p><p>同时我也会分享一些个人的学习方法和年度总结，希望通过这个博客能够为大家提供有价值的信息和帮助，输出一些有意义的内容！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我搭建这个博客的初衷是为了记录一下自己的程序员生涯的故事，毕竟来都来了，怎么也得留下些什么吧！其次是希望能有大神能在这个过程中指出我的错误，能让我学习到更多！</p><p>在最后，祝你好运，也祝我好运！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我一直都想搭建一个用于记录生活和学习的博客，但是碍于懒惰，一直拖延到现在。直到昨天我在浏览Github的开源项目时，我看到了&lt;a href=&quot;https://crossoverjie.top/&quot;&gt;杰哥&lt;/a&gt;的个人博客，很佩服&lt;a href=&quot;https://crossoverjie.top/&quot;&gt;杰哥&lt;/a&gt;的经历，所以我也决定搭建一个博客来记录自己在工作中遇到的问题以及自己学习技术的一个理解等。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://minster.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="LifeNode" scheme="https://minster.top/tags/LifeNode/"/>
    
  </entry>
  
</feed>
