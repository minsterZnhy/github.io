<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>minster&#39;s Blog</title>
  
  <subtitle>记录学习以及生活~</subtitle>
  <link href="https://minster.top/atom.xml" rel="self"/>
  
  <link href="https://minster.top/"/>
  <updated>2023-08-22T12:34:34.295Z</updated>
  <id>https://minster.top/</id>
  
  <author>
    <name>Minster</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java如何去解析Neo4j返回的Record</title>
    <link href="https://minster.top/2023/08/22/Java%E5%A6%82%E4%BD%95%E5%8E%BB%E8%A7%A3%E6%9E%90Neo4j%E8%BF%94%E5%9B%9E%E7%9A%84Record/"/>
    <id>https://minster.top/2023/08/22/Java%E5%A6%82%E4%BD%95%E5%8E%BB%E8%A7%A3%E6%9E%90Neo4j%E8%BF%94%E5%9B%9E%E7%9A%84Record/</id>
    <published>2023-08-22T00:49:12.000Z</published>
    <updated>2023-08-22T12:34:34.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Neo4j是一个可以构建节点关系的非关系型的图数据库，通过使用Neo4j存储数据，我们可以很好地实现一些节点关系数据，比如物流中的运输路线等。</p><p>对于第一次使用Neo4j的朋友来说，解析查询记录是很痛苦的，本文记录了几种常用的处理查询结果的方法，以便不时之需。</p><span id="more"></span><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="如果查询返回的是m，r，n"><a href="#如果查询返回的是m，r，n" class="headerlink" title="如果查询返回的是m，r，n"></a>如果查询返回的是m，r，n</h3><p>正如下述Neo4j查询语句，返回的记录是两个节点的信息及其关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (n) -[r]- (m) RETURN n,r,m</span><br></pre></td></tr></table></figure><p>我们可以这样去解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取节点n的数据</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> record.get(<span class="string">&quot;n&quot;</span>).asNode();</span><br><span class="line"><span class="comment">// 获取节点m的数据</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">m</span> <span class="operator">=</span> record.get(<span class="string">&quot;m&quot;</span>).asNode();</span><br><span class="line"><span class="comment">// 获取关系r的数据</span></span><br><span class="line"><span class="type">Relationship</span> <span class="variable">relationship</span> <span class="operator">=</span> record.get(<span class="string">&quot;r&quot;</span>).asRelationship();</span><br></pre></td></tr></table></figure><p><strong>注意：上述的r，n，m要与cypher语句中的对应</strong></p><h3 id="如果返回的是一条路径-path-xxx"><a href="#如果返回的是一条路径-path-xxx" class="headerlink" title="如果返回的是一条路径 path = (xxx)"></a>如果返回的是一条路径 <code>path = (xxx)</code></h3><p>在我们物流的路线规划业务中，往往会有最短距离路线和最低成本路线的选取，而这是返回的路线数据是比较复杂的，正如下面 <code>cypher</code> 查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH path = shortestPath((n:n_Label) -[*..&#123;&#125;]- (m:m_Label))</span><br><span class="line">WHERE n.bid = 10001 AND m.bid = 10002</span><br><span class="line">RETURN path</span><br></pre></td></tr></table></figure><p>此时我们获取到的 <code>record</code> 是 <code> 节点n</code> 到 <code>节点m</code> 的整条路径的值，包括一个开始节点（n）、结束节点（m）。</p><p>以及从开始节点到结束节点之间经过的每两个节点间的片段segements：</p><p> <strong><code>segments:[&#123;startNode, relationship, endNode&#125;,&#123;xxx&#125;,&#123;xxx&#125;] </code></strong> </p><p>此时，如果我们想要获取record中的某一条线路的值，我们可以通过 <code>record.get(x)</code> 来获取（<strong>注意：x为第x条线路，因为我们这里的最短线路只有一条线路，所以 <code>record.get(0)</code> 即可以获取到</strong>），这里获取到的就是我们的path值，是Value接口类型的。</p><p><code>record.get(0)</code> 的结果：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230822200019573.png" alt="image-20230822200019573"></p><p>Value接口类型是一个类似于Map的接口，这里我们不好处理，所以我们要将其转换为PathValue（PathValue是Value类型的一个实现类可以获取到Path，Path类型处理结果方便）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将第一条记录格式化成path-&gt; path</span></span><br><span class="line"><span class="type">PathValue</span> <span class="variable">pathValue</span> <span class="operator">=</span> (PathValue) record.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* path[nodes, relationship, segment] </span></span><br><span class="line"><span class="comment">* nodes: 所有节点 </span></span><br><span class="line"><span class="comment">* relationship: 节点间的关系 </span></span><br><span class="line"><span class="comment">* segment:  路线的轨迹片段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> pathValue.asPath();</span><br></pre></td></tr></table></figure><p>转换成path之后，我们可以看到path里面的值</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230822200125781.png" alt="image-20230822200125781"></p><p>在这里，我们可以查看一下path源码，看一下<code>nodes、relationships、segments</code>的值分别是什么</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230822200148765.png" alt="image-20230822200148765"></p><p>通过上述代码以及注释我们可以发现：</p><ul><li><p>nodes是Path类帮我们实现的一个迭代器，里面包含了整条路径涉及到的所有的node</p></li><li><p>relationships同上，里面封装的是整条路线涉及到的节点之间的关系</p></li><li><p>segment是一个接口，segment其实就是我们某段关系的记录，包括开始节点、关系、接收节点，也就是对应的 <code>n-r-m  </code> 。</p><p><strong>注意：segment是某一段关系，而一个节点到另外一个节点的中间，可能会有多段关系</strong></p></li></ul><p>上述cypher语句的查询路径如下图所示</p><blockquote><p><strong>注意：因为 <code>shortestPath()</code> 是有方向性的，所以这里只能查询到从a到b的结点</strong></p><p><strong>如果要查询a到e之间的所有路线，我们把shortestPath去掉即可，但是一定要加排序并加limit加以限制，不然会造成OOM。</strong></p></blockquote><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230822200229541.png" alt="image-20230822200229541"></p><p>好的，言归正传，如果我们需要获取record中的node进行数据处理，只需要调用 <code>path.nodes()</code> 遍历即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里我用的是Stream来处理数据</span></span><br><span class="line">List&lt;OrganDTO&gt; organDTOList = StreamUtil.of(path.nodes()).map(</span><br><span class="line">        node -&gt; &#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = node.asMap();</span><br><span class="line">            <span class="type">OrganDTO</span> <span class="variable">organDTO</span> <span class="operator">=</span> BeanUtil.toBean(map, OrganDTO.class);</span><br><span class="line">            <span class="type">OrganTypeEnum</span> <span class="variable">organTypeEnum</span> <span class="operator">=</span> OrganTypeEnum.valueOf(CollUtil.getFirst(node.labels()));</span><br><span class="line">            organDTO.setType(organTypeEnum.getCode());</span><br><span class="line">            <span class="type">Object</span> <span class="variable">location</span> <span class="operator">=</span> map.get(<span class="string">&quot;location&quot;</span>);</span><br><span class="line">            organDTO.setLatitude(BeanUtil.getProperty(location, <span class="string">&quot;y&quot;</span>));</span><br><span class="line">            organDTO.setLongitude(BeanUtil.getProperty(location, <span class="string">&quot;x&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> organDTO;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面代码的执行流程：</p><ol><li><p>将 <code>nodes</code> 转换为Stream流，用于遍历处理node</p></li><li><p>因为node是一个接口并且其结构与Map类似，也是K-V键值对，所以我们在这里可以直接调用它的<code>asMap</code> 方法将其转成map集合，用于后续数据处理</p><p>Node接口的类图：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230822203138378.png" alt="image-20230822203138378"></p><p>我们可以查看MapAcessor接口，看里面的方法</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230822203236912.png" alt="image-20230822203236912"></p></li><li><p>将Node转成Map之后，我们就可以用工具类对我们需要的实体类进行封装。</p></li></ol><p>同理，<code>relationship</code> 的获取也是差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里获取到的是一个迭代器，我们可以直接使用Stream遍历</span></span><br><span class="line">path.relationships();</span><br><span class="line"><span class="type">double</span> <span class="variable">cost</span> <span class="operator">=</span> StreamUtil.of(path.relationships()).mapToDouble(relationship -&gt; &#123;</span><br><span class="line">                    Map&lt;String, Object&gt; map = relationship.asMap();</span><br><span class="line">                    <span class="keyword">return</span> Convert.toDouble(map.get(<span class="string">&quot;cost&quot;</span>), <span class="number">0D</span>);</span><br><span class="line">              &#125;).sum();</span><br></pre></td></tr></table></figure><p>上面获取cost的代码，执行流程是这样的</p><ol><li><p>通过 <code>StreamUtil.of(path.relationships())</code> 将relationships转换为流。</p></li><li><p>使用 <code>mapToDouble</code> 对Stream流做一个映射，映射的结果返回为double类型</p></li><li><p>然后再映射过程中，将 <code>relationship</code> 转换成map，因为relationship是一个k-v键值对。</p><blockquote><p><code>relationship.asMap();</code> 将relationship转为map</p></blockquote><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230822200316496.png" alt="image-20230822200316496"></p></li><li><p>然后获取 <code>cost</code> 属性，并且进行一个求和处理</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230822200333102.png" alt="image-20230822200333102"></p></li></ol><h3 id="如果返回的是一个统计结果"><a href="#如果返回的是一个统计结果" class="headerlink" title="如果返回的是一个统计结果"></a>如果返回的是一个统计结果</h3><p>当然，如果我们对结果进行统计，这时想要获取record中的统计结果的话，我们直接获取即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 统计从n到m有多少条线路</span><br><span class="line">MATCH path = (n:n_LabelType)-[r]-(m:m_LabelType)</span><br><span class="line">        WHERE n.bid =$startId AND m.bid = $endId</span><br><span class="line">        RETURN count(r) AS c</span><br></pre></td></tr></table></figure><p>比如上述cypher查询中，我们要获取c的值，直接get即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> Convert.toLong(record.get(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Neo4j是一个可以构建节点关系的非关系型的图数据库，通过使用Neo4j存储数据，我们可以很好地实现一些节点关系数据，比如物流中的运输路线等。&lt;/p&gt;
&lt;p&gt;对于第一次使用Neo4j的朋友来说，解析查询记录是很痛苦的，本文记录了几种常用的处理查询结果的方法，以便不时之需。&lt;/p&gt;</summary>
    
    
    
    <category term="Neo4j" scheme="https://minster.top/categories/Neo4j/"/>
    
    
    <category term="Java" scheme="https://minster.top/tags/Java/"/>
    
    <category term="Neo4j" scheme="https://minster.top/tags/Neo4j/"/>
    
  </entry>
  
  <entry>
    <title>HashMap为什么通过(n - 1) &amp; hash 获取哈希桶数组下标？</title>
    <link href="https://minster.top/2023/07/07/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%9A%E8%BF%87(n%20-%201)%20&amp;%20hash%20%E8%8E%B7%E5%8F%96%E5%93%88%E5%B8%8C%E6%A1%B6%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%EF%BC%9F/"/>
    <id>https://minster.top/2023/07/07/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%9A%E8%BF%87(n%20-%201)%20&amp;%20hash%20%E8%8E%B7%E5%8F%96%E5%93%88%E5%B8%8C%E6%A1%B6%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%EF%BC%9F/</id>
    <published>2023-07-07T13:21:04.000Z</published>
    <updated>2023-07-08T02:32:38.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看过HashMap源码的应该都知道HashMap是如何根据hash值来计算哈希桶数组下标的，<strong>就是通过(n - 1) &amp; hash来计算的，为什么用的是位运算(&amp;)而不是取模运算(hash % n)呢？</strong></p><p>获取hash桶数组下标源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="位运算与取模运算效率比较"><a href="#位运算与取模运算效率比较" class="headerlink" title="位运算与取模运算效率比较"></a>位运算与取模运算效率比较</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polymorphic;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100000</span>; <span class="comment">// 数据集数量，初始定义为十万</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位运算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">bitwise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从十万开始，一直到Integer的最大值，计算所需时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> number; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            a &amp;= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> end - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;位运算时间为：&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取模运算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">module</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> number; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            a %= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> end - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;取模运算时间为：&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        t.bitwise();</span><br><span class="line">        t.<span class="keyword">module</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image01.jpg" alt="image01"></p><p>从测试结果我们可以看出，如果数据集足够的大，那么取模运算的时间将会是位运算时间的十几倍。</p><p>这只是一方面，如果数据集足够大的话，HashMap的初始容量肯定不够，这也触发了HashMap的扩容机制。所以<strong>采用二进制位操作 &amp;，相对于%能够提高运算效率。</strong></p><h2 id="位运算是如何保证索引不越界的？"><a href="#位运算是如何保证索引不越界的？" class="headerlink" title="位运算是如何保证索引不越界的？"></a>位运算是如何保证索引不越界的？</h2><p>讲到这，<strong>我们也就要想想为什么HashMap的容量是2的n次幂？</strong>两者之间有着千丝万缕的联系。</p><p>当 n 是2的次幂时， n - 1 通过 二进制表示即尾端一直都是以连续1的形式表示的。<strong>当(n - 1) 与 hash 做与运算时，会保留hash中 后 x 位的 1，这样就保证了索引值 不会超出数组长度。</strong></p><blockquote><p><strong>当n为2次幂时，即n&#x3D;2^k，那么(n-1)的二进制表示中，从最低位开始到k-1位，都是1。</strong></p><p>2^2-1 &#x3D; 3：0000 0000 0011</p><p>2^3-1 &#x3D; 7：0000 0000 0111</p><p>…</p><p>2^5-1 &#x3D; 31：0000 0001 1111</p><p>最低位是从0开始算的。</p><p>为什么当我们将一个哈希值与 n - 1 进行按位与运算时，结果会保留哈希值的后 x 位中的所有 1？</p><p>这是因为 n - 1 的二进制表示中，后 x 位都是 1，而哈希值的对应位如果是 1，则与 1 进行按位与运算结果仍为 1，如果是 0，则结果为 0。 </p><p>这就可以说明：我们进行位运算时，得到的结果永远小于或等于n-1</p></blockquote><p><strong>同时当n为2次幂时，会满足一个公式：(n - 1) &amp; hash &#x3D; hash % n。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;看过HashMap源码的应该都知道HashMap是如何根据hash值来计算哈希桶数组下标的，&lt;strong&gt;就是通过(n - 1) &amp;amp; hash来计算的，为什么用的是位运算(&amp;amp;)而不是取模运算(hash % n)呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获取hash桶数组下标源码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((p = tab[i = (n - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;amp; hash]) == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tab[i] = newNode(hash, key, value, &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java" scheme="https://minster.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://minster.top/tags/Java/"/>
    
    <category term="HashMap" scheme="https://minster.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>微信登录的双token三验证方案</title>
    <link href="https://minster.top/2023/05/26/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E7%9A%84%E5%8F%8Ctoken%E5%AE%9E%E7%8E%B0/"/>
    <id>https://minster.top/2023/05/26/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E7%9A%84%E5%8F%8Ctoken%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-05-26T11:39:13.000Z</published>
    <updated>2023-09-04T13:22:02.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文从实现了微信登录的双token三验证方案。</p><span id="more"></span><h2 id="微信小程序登录业务分析"><a href="#微信小程序登录业务分析" class="headerlink" title="微信小程序登录业务分析"></a>微信小程序登录业务分析</h2><p>通过查阅微信官方文档，我们可以知道微信小程序的具体登录业务流程。当然，他的实现与我们传统的不同之处就是在于我们需要调用微信的服务器来实现，下面是官方提供的时序图。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/api-login.jpg" alt="api-login"></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">微信官网登录接口文档</a>说明</p><ol><li>调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html">wx.login()</a> 获取 <strong>临时登录凭证code</strong> ，并回传到开发者服务器。</li><li>调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html">auth.code2Session</a> 接口，换取 <strong>用户唯一标识 OpenID</strong> 、 用户在微信开放平台账号下的<strong>唯一标识UnionID</strong>（若当前小程序已绑定到微信开放平台账号） 和 <strong>会话密钥 session_key</strong>。</li></ol><p>之后开发者服务器可以根据用户标识（<code>OpenID</code>）来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。</p><p>当然，现在微信用户基本都是绑定了手机号码的，所以我们也可以整合官网提供的<a href="https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-info/phone-number/getPhoneNumber.html">手机号码接口</a>，来获取用户登录时候的手机号码，保存到我们的数据库中。</p><blockquote><p>需要注意的是，手机号码的获取需要先去获取 <code>access_token</code> </p></blockquote><h2 id="微信登录的单token实现"><a href="#微信登录的单token实现" class="headerlink" title="微信登录的单token实现"></a>微信登录的单token实现</h2><p>用户端通过集成微信小程序进行登录，流程图如下：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230904203819067.png" alt="image-20230904203819067"></p><p>流程图分析：</p><ul><li>微信小程序通过http请求访问用户端web服务</li><li>然后通过OpenFeign远程调用用户微服务</li><li>用户业务微服务直接连接Mysql数据执行CRUD操作</li></ul><p><strong>user表</strong></p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230904203942639.png" alt="image-20230904203942639"></p><h3 id="第一步，流程分析"><a href="#第一步，流程分析" class="headerlink" title="第一步，流程分析"></a>第一步，流程分析</h3><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230904204426417.png" alt="image-20230904204426417"></p><p>实现流程步骤：</p><ol><li>调用微信后台接口，根据临时code获取openid【第三步】</li><li>通过openid查询用户，判断是否为新用户，新用户则注册，老用户不需要注册</li><li>调用微信后台接口，获取用户手机号【第四步】</li><li>如果用户手机号有更新，需要进行修改操作</li><li>生成token【第五步】</li><li>封装数据并返回</li></ol><h3 id="第二步，实现登录"><a href="#第二步，实现登录" class="headerlink" title="第二步，实现登录"></a><strong>第二步，实现登录</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userLoginRequestVO 登录code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserLoginVO <span class="title function_">login</span><span class="params">(UserLoginRequestVO userLoginRequestVO)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1、调用微信后台接口，根据临时code获取openid</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> wechatService.getOpenid(userLoginRequestVO.getCode());</span><br><span class="line">    <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> jsonObject.getStr(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">    <span class="comment">//2.通过openid查询用户，判断是否为新用户，新用户则注册，老用户不需要注册</span></span><br><span class="line">    <span class="type">MemberDTO</span> <span class="variable">memberDTO</span> <span class="operator">=</span> <span class="built_in">this</span>.getByOpenid(openid);</span><br><span class="line">    <span class="comment">//新用户</span></span><br><span class="line">    <span class="keyword">if</span>(ObjectUtil.isEmpty(memberDTO))&#123;</span><br><span class="line">        memberDTO=MemberDTO.builder()</span><br><span class="line">                .openId(openid)<span class="comment">//设置微信openid</span></span><br><span class="line">                .authId(jsonObject.getStr(<span class="string">&quot;unionid&quot;</span>))<span class="comment">//如果有值，则复制，没有值则为空</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="built_in">this</span>.save(memberDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  再次查询数据库表，这样就就可以获取对应的主键和其他属性了，方便后面使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       memberDTO = <span class="built_in">this</span>.getByOpenid(openid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用微信后台接口，获取用户手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> wechatService.getPhone(userLoginRequestVO.getPhoneCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.如果用户手机号有更新，需要进行修改操作</span></span><br><span class="line">    <span class="keyword">if</span> (!StrUtil.equals(phone,memberDTO.getPhone())) &#123;</span><br><span class="line">        memberDTO.setPhone(phone);</span><br><span class="line">        memberFeign.update(memberDTO.getId(),memberDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.生成token</span></span><br><span class="line">    Map&lt;String, Object&gt; claims=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(Constants.GATEWAY.USER_ID,memberDTO.getId());</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> tokenService.createAccessToken(claims);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.封装数据并返回</span></span><br><span class="line">    UserLoginVO userLoginVO= UserLoginVO.builder()</span><br><span class="line">            .accessToken(accessToken)</span><br><span class="line">            .openid(openid)</span><br><span class="line">            .binding(StatusEnum.NORMAL.getCode())<span class="comment">//绑定了手机号</span></span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">return</span> userLoginVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三步，获取openid"><a href="#第三步，获取openid" class="headerlink" title="第三步，获取openid"></a>第三步，获取openid</h3><p>参考<a href="https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html">小程序登录 | 微信开放文档 (qq.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取openid的访问路径地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL=<span class="string">&quot;https://api.weixin.qq.com/sns/jscode2session&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;sl.wechat.appid&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String appid;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;sl.wechat.secret&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String secret;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取openid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code 登录凭证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 唯一标识</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">getOpenid</span><span class="params">(String code)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//2.封装参数</span></span><br><span class="line">    Map&lt;String, Object&gt; paramMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    paramMap.put(<span class="string">&quot;appid&quot;</span>,appid);</span><br><span class="line">    paramMap.put(<span class="string">&quot;secret&quot;</span>,secret);</span><br><span class="line">    paramMap.put(<span class="string">&quot;js_code&quot;</span>,code);</span><br><span class="line">    paramMap.put(<span class="string">&quot;grant_type&quot;</span>,<span class="string">&quot;authorization_code&quot;</span>);</span><br><span class="line">    <span class="comment">//1.发起http请求</span></span><br><span class="line">    <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.get(URL)</span><br><span class="line">            .form(paramMap)<span class="comment">//设置表单参数</span></span><br><span class="line">            .execute();</span><br><span class="line">    <span class="comment">//3.解析结果</span></span><br><span class="line">    <span class="comment">//3.1 如果响应成功</span></span><br><span class="line">    <span class="keyword">if</span> (response.isOk()) &#123;</span><br><span class="line">        <span class="comment">//获取到响应主体内容json字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> response.body();</span><br><span class="line">        <span class="comment">//解析成json对象</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONUtil.parseObj(body);</span><br><span class="line">        <span class="comment">//如果包含errcode说明报错了</span></span><br><span class="line">        <span class="keyword">if</span>(jsonObject.containsKey(<span class="string">&quot;errcode&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SLWebException</span>(jsonObject.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2 响应失败</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> StrUtil.format(<span class="string">&quot;调用微信登录接口出错！ code = &#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SLWebException</span>(errMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四步，获取手机号"><a href="#第四步，获取手机号" class="headerlink" title="第四步，获取手机号"></a>第四步，获取手机号</h3><p>参考<a href="https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-info/phone-number/getPhoneNumber.html">手机号快速验证 | 微信开放文档 (qq.com)</a></p><p>注意：要想获取用户手机号，需要先获取到微信access_token,然后才能获取到手机号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取token的接口地址</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACCESS_TOKEN_URL=<span class="string">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span>;</span><br><span class="line"> <span class="comment">//获取手机号的接口地址</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PHONE_URL=<span class="string">&quot;https://api.weixin.qq.com/wxa/business/getuserphonenumber?access_token=&quot;</span>;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取手机号</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> code 手机号凭证</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 唯一标识</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">(String code)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="comment">//2.封装数据</span></span><br><span class="line">     Map&lt;String,Object&gt; paramMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     paramMap.put(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">     String paramBody=JSONUtil.toJsonStr(paramMap);</span><br><span class="line">     <span class="comment">//1.调获取手机号的接口</span></span><br><span class="line">     <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.post(PHONE_URL+<span class="built_in">this</span>.accessToken())</span><br><span class="line">            .body(paramBody)<span class="comment">//设置请求参数,json字符串类型</span></span><br><span class="line">            .execute();</span><br><span class="line">     <span class="comment">//3.解析结果</span></span><br><span class="line">     <span class="keyword">if</span> (response.isOk()) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> response.body();</span><br><span class="line">         <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONUtil.parseObj(body);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//获取手机号，然后返回</span></span><br><span class="line">         <span class="keyword">return</span> jsonObject.getByPath(<span class="string">&quot;phone_info.phoneNumber&quot;</span>,String.class);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> StrUtil.format(<span class="string">&quot;调用获取手机号接口出错！&quot;</span>);</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SLWebException</span>(errMsg);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取token值</span></span><br><span class="line"> <span class="keyword">private</span> String <span class="title function_">accessToken</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//2、封装数据</span></span><br><span class="line">     Map&lt;String,Object&gt; paramMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     paramMap.put(<span class="string">&quot;grant_type&quot;</span>,<span class="string">&quot;client_credential&quot;</span>);</span><br><span class="line">     paramMap.put(<span class="string">&quot;appid&quot;</span>,appid);</span><br><span class="line">     paramMap.put(<span class="string">&quot;secret&quot;</span>,secret);</span><br><span class="line">     <span class="comment">//1.获取token</span></span><br><span class="line">     <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpRequest.get(ACCESS_TOKEN_URL)</span><br><span class="line">             .form(paramMap)</span><br><span class="line">             .execute();</span><br><span class="line">     <span class="comment">//3.解析数据</span></span><br><span class="line">     <span class="keyword">if</span> (response.isOk()) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> response.body();</span><br><span class="line">         <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONUtil.parseObj(body);</span><br><span class="line">         <span class="keyword">return</span> jsonObject.getStr(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> StrUtil.format(<span class="string">&quot;调用获取接口调用凭据接口出错！&quot;</span>);</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SLWebException</span>(errMsg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="第五步，生成token"><a href="#第五步，生成token" class="headerlink" title="第五步，生成token"></a>第五步，生成token</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createAccessToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">    <span class="comment">//生成短令牌的有效期时间单位为：分钟</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtils.createToken(claims,</span><br><span class="line">            jwtProperties.getPrivateKey(),<span class="comment">//加入RSA私钥</span></span><br><span class="line">            jwtProperties.getAccessTtl(),<span class="comment">//设置过期时间</span></span><br><span class="line">            DateField.MINUTE<span class="comment">//设置时间单位，分钟</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里使用的是非对称加密算法的方式，其实就是公钥加密，私钥解密。</p></blockquote><p>但是，上面的实现是存在一定的问题的，大家试想一下：我们的token有效期该怎么去设置呢？</p><ul><li><p>如果设置的比较短，用户会频繁的登录，如果设置的比较长，会不太安全，因为token一旦被黑客截取的话，就可以通过此token与服务端进行交互了。</p></li><li><p>另外一方面，token是无状态的，也就是说，服务端一旦颁发了token就无法让其失效（除非过了有效期），这样的话，如果我们检测到token异常也无法使其失效，所以这也是无状态token存在的问题。</p></li></ul><p>下面我们可以通过双Token三验证的方式来解决上述问题。</p><h2 id="双Token三验证的登录实现"><a href="#双Token三验证的登录实现" class="headerlink" title="双Token三验证的登录实现"></a>双Token三验证的登录实现</h2><p>为了解决单token模式下存在的问题，所以我们可以通过【双token三验证】的模式进行改进实现，主要解决的两个问题如下：</p><ul><li><p>token有效期长不安全</p></li><li><ul><li>登录成功后，生成2个token，分别是：access_token、refresh_token，前者有效期短（如：5分钟），后者的有效期长（如：24小时）</li><li>正常请求后端服务时，携带access_token，如果发现access_token失效，就通过refresh_token到后台服务中换取新的access_token和refresh_token，这个可以理解为token的续签</li><li>以此往复，直至refresh_token过期，需要用户重新登录</li></ul></li><li><p>token的无状态性</p></li><li><ul><li>为了使token有状态，也就是后端可以控制其提前失效，需要将refresh_token设计成只能<strong>使用一次</strong></li><li>需要将refresh_token存储到redis中，并且要设置过期时间</li><li>这样的话，服务端如果检测到用户token有安全隐患（如：异地登录），只需要将refresh_token失效即可</li></ul></li></ul><p><strong>详细流程如下：</strong></p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/1687431489005.png" alt="1687431489005"></p><h3 id="生成刷新token"><a href="#生成刷新token" class="headerlink" title="生成刷新token"></a>生成刷新token</h3><p>注意：目前我们再此之前已经实现了创建access-token了，那么此步是为了实现refresh-token的</p><p>实现的步骤：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/1687443488956.png" alt="1687443488956"></p><p>生成刷新refresh_token的主要逻辑有两点：</p><ul><li>生成jwt格式的token，有效期时间一般小时为单位</li><li>将token存入到redis，使token有状态，并且确保只能使用一次</li></ul><p>在tokenServiceImpl中添加有以下实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生成长令牌</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> claims token中存储的数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 长令牌</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">createRefreshToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">       <span class="comment">//生成长令牌的有效期时间单位为：小时</span></span><br><span class="line">       <span class="comment">//1、生成刷新token</span></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">refreshTtl</span> <span class="operator">=</span> jwtProperties.getRefreshTtl();</span><br><span class="line">       <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> JwtUtils.createToken(claims, jwtProperties.getPrivateKey(),refreshTtl );</span><br><span class="line">       <span class="comment">//2.长令牌只能使用一次，需要将其存储到redis中，变成有状态的</span></span><br><span class="line">       String redisKey=REDIS_REFRESH_TOKEN_PREFIX+ SecureUtil.md5(refreshToken);</span><br><span class="line">       stringRedisTemplate.opsForValue().set(redisKey,refreshToken, Duration.ofHours(refreshTtl));</span><br><span class="line">       <span class="comment">//3.返回刷新token</span></span><br><span class="line">       <span class="keyword">return</span> refreshToken;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="刷新token业务"><a href="#刷新token业务" class="headerlink" title="刷新token业务"></a>刷新token业务</h3><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/1687443593191.png" alt="1687443593191"></p><p>刷新token的动作是在refresh_token过期之后进行的，主要实现关键点有：</p><ul><li>校验refresh_token是否被伪造以及是否在有效期内</li><li>从redis中查询，是否不存在，如果不存在说明已经失效或已经使用过，如果存在，就需要将其删除</li><li>重新生成一对token，响应结果</li></ul><p>refreshToken方法实现以下业务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 刷新token动作</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> refreshToken 原长令牌，需要否则校验其合法性以及可用性</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 登录对象，包含长短令牌</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserLoginVO <span class="title function_">refreshToken</span><span class="params">(String refreshToken)</span> &#123;</span><br><span class="line">      <span class="comment">//1.非空判断</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isEmpty(refreshToken)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//2.校验token是否存在,第二次校验</span></span><br><span class="line">      Map&lt;String, Object&gt; checkTokenMap = JwtUtils.checkToken(refreshToken, jwtProperties.getPublicKey());</span><br><span class="line">      <span class="comment">//token无效</span></span><br><span class="line">      <span class="keyword">if</span>(checkTokenMap==<span class="literal">null</span> || checkTokenMap.size()==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//3.否则有效，则校验redis中的token是否使用过，第三次校验</span></span><br><span class="line">      String redisKey=REDIS_REFRESH_TOKEN_PREFIX+ SecureUtil.md5(refreshToken);</span><br><span class="line">      <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.hasKey(redisKey);</span><br><span class="line">      <span class="comment">//如果等于false,表示过期或者使用过</span></span><br><span class="line">      <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.重新生成长短令牌</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> createAccessToken(checkTokenMap);</span><br><span class="line">          <span class="comment">//生成新的长令牌，并重新存储新的令牌到redis中</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">newRefreshToken</span> <span class="operator">=</span> createRefreshToken(checkTokenMap);</span><br><span class="line">      <span class="comment">//5.删除redis中的原token，只能使用一次</span></span><br><span class="line">      stringRedisTemplate.delete(redisKey);</span><br><span class="line">      <span class="comment">//6.封装数据并返回</span></span><br><span class="line">      <span class="type">UserLoginVO</span> <span class="variable">userLoginVO</span> <span class="operator">=</span> UserLoginVO.builder()</span><br><span class="line">              .refreshToken(newRefreshToken)</span><br><span class="line">              .accessToken(accessToken)</span><br><span class="line">              .build();</span><br><span class="line">      <span class="keyword">return</span> userLoginVO;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意：该刷新token的业务动作，是由前端主动发起请求的，所以我们要完成对应的userController中的方法填充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 刷新token，校验请求头中的长令牌，生成新的长短令牌</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> refreshToken 原令牌</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 登录结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/refresh&quot;)</span></span><br><span class="line">   <span class="meta">@ApiOperation(&quot;刷新token&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;UserLoginVO&gt; <span class="title function_">refresh</span><span class="params">(<span class="meta">@RequestHeader(Constants.GATEWAY.REFRESH_TOKEN)</span> String refreshToken)</span> &#123;</span><br><span class="line">       <span class="type">UserLoginVO</span> <span class="variable">loginVO</span> <span class="operator">=</span> memberService.refresh(refreshToken);</span><br><span class="line">       <span class="keyword">return</span> R.success(loginVO);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>refresh方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 刷新token</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> refreshToken 原长令牌</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 长/短令牌</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> UserLoginVO <span class="title function_">refresh</span><span class="params">(String refreshToken)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> tokenService.refreshToken(refreshToken);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文从实现了微信登录的双token三验证方案。&lt;/p&gt;</summary>
    
    
    
    <category term="实现方案" scheme="https://minster.top/categories/%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Wechat" scheme="https://minster.top/tags/Wechat/"/>
    
  </entry>
  
  <entry>
    <title>使用OpenFeign时LocalDateTime反序列化失败的解决方法</title>
    <link href="https://minster.top/2023/05/26/%E8%AE%B0%E5%BD%95%E4%BD%BF%E7%94%A8OpenFeign%E6%97%B6LocalDateTime%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://minster.top/2023/05/26/%E8%AE%B0%E5%BD%95%E4%BD%BF%E7%94%A8OpenFeign%E6%97%B6LocalDateTime%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2023-05-26T11:39:13.000Z</published>
    <updated>2023-08-16T00:37:48.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​我在使用 <code>OpenFeign</code> 进行远程调用时，发现我的调用端报错 <code>Cannot deserialize value of type </code>java.time.LocalDateTime<code> from String &quot;2022-09-13T11:34:36&quot;</code> ，下面是错误排查与修改的过程。</p><span id="more"></span><h2 id="异常描述"><a href="#异常描述" class="headerlink" title="异常描述"></a>异常描述</h2><p>​OpenFeign使用Get远程调用服务时，返回的dto如果包含了 <code>LocalDateTime</code> 的话，会导致远程调用失败，报<code>Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) Text &#39;2022-09-13T11:34:36&#39; could not be parsed at index 10</code> 错误。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230816072604405.png" alt="image-20230816072604405"></p><h2 id="异常产生的原因"><a href="#异常产生的原因" class="headerlink" title="异常产生的原因"></a>异常产生的原因</h2><p>​查阅资料后发现，SpringBoot中默认使用Jackson做Json序列化和反序列化，服务器使用openFeign接收数据时将日期字符串转成LocalDateTime时，因为jsr310协议的默认的反序列化器格式是解析 <code>2022-09-13T11:34:36</code> 这样格式的字符串的。</p><p>​查看源码可以知道，默认解析String字符串时，会以 <code>DEFAULT_FORMATTER</code> 的格式进行解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_formatter == DEFAULT_FORMATTER) &#123;</span><br><span class="line">                <span class="comment">// ... only allow iff lenient mode enabled since</span></span><br><span class="line">                <span class="comment">// JavaScript by default includes time and zone in JSON serialized Dates (UTC/ISO instant format).</span></span><br><span class="line">                <span class="comment">// And if so, do NOT use zoned date parsing as that can easily produce</span></span><br><span class="line">                <span class="comment">// incorrect answer.</span></span><br><span class="line">                <span class="keyword">if</span> (string.length() &gt; <span class="number">10</span> &amp;&amp; string.charAt(<span class="number">10</span>) == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (string.endsWith(<span class="string">&quot;Z&quot;</span>)) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (isLenient()) &#123;</span><br><span class="line">                           <span class="keyword">return</span> LocalDateTime.parse(string.substring(<span class="number">0</span>, string.length()-<span class="number">1</span>),</span><br><span class="line">                                   _formatter);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="type">JavaType</span> <span class="variable">t</span> <span class="operator">=</span> getValueType(ctxt);</span><br><span class="line">                       <span class="keyword">return</span> (LocalDateTime) ctxt.handleWeirdStringValue(t.getRawClass(),</span><br><span class="line">                               string,</span><br><span class="line"><span class="string">&quot;Should not contain offset when &#x27;strict&#x27; mode set for property or type (enable &#x27;lenient&#x27; handling to allow)&quot;</span></span><br><span class="line">                               );</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">return</span> LocalDateTime.parse(string, _formatter);</span><br></pre></td></tr></table></figure><p>而 <code>DEFAULT_FORMATTER</code> 默认使用的日期格式为下图的 <code>ISO_LOCAL_DATE_TIME </code> 我们可以看到是带字符 T 的。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230816075102644.png" alt="image-20230816075102644"></p><p>​但是在根据根据2.12版本的[modules-base#94]的更改，我们的String时间字符串要解析成LocalDateTime格式时，不仅要第十个字符为T，还需要以字符Z结尾（这里我也不知道为什么这样设计）。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230816075705607.png" alt="image-20230816075705607"></p><p>​继续追踪源码，发现因为我们第十个字符是T，导致反序列化解析失败。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230816081428412.png" alt="image-20230816081428412"></p><blockquote><p>上面代码的注释意思：</p><p>解析指定的文本。</p><p>这将解析为一个TemporalAccessor，确保文本被完全解析。</p><p><strong>参数:</strong></p><ul><li><p>Text -要解析的文本，不是null </p></li><li><p>position -要解析的位置，更新为解析的长度和任何错误的索引，如果解析整个字符串，则为null</p></li></ul><p><strong>返回:</strong></p><p>解析的结果，不是null</p><p><strong>抛出:</strong></p><ul><li><p>DateTimeParseException:解析失败</p></li><li><p>DateTimeException:在解析日期或时间时发生错误</p></li><li><p>IndexOutOfBoundsException:位置无效</p></li></ul></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在我们dto中，将我们的日期格式添加上以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(shape = JsonFormat.Shape.STRING,pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br></pre></td></tr></table></figure><p>需要注意的是，一定要加 <code>shape = JsonFormat.Shape.STRING</code> 这个可以帮我们把T去掉。</p><p>加了之后我们在看debug看一下效果：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230816082128025.png" alt="image-20230816082128025"></p><p>可以发现这里的T不见了，并且解析结果也是成功的，至此问题解决。</p><blockquote><p>需要注意的是：如果你的实体类模块是与service分开的，你需要重新构建工程。比如说，你的实体类是放在xxx-domain模块下的话，你修改之后重启xxx-service模块是不会生效的，因为没有重构项目生成新的target</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	我在使用 &lt;code&gt;OpenFeign&lt;/code&gt; 进行远程调用时，发现我的调用端报错 &lt;code&gt;Cannot deserialize value of type &lt;/code&gt;java.time.LocalDateTime&lt;code&gt; from String &amp;quot;2022-09-13T11:34:36&amp;quot;&lt;/code&gt; ，下面是错误排查与修改的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Exception" scheme="https://minster.top/categories/Exception/"/>
    
    
    <category term="Spring Cloud" scheme="https://minster.top/tags/Spring-Cloud/"/>
    
    <category term="Exception" scheme="https://minster.top/tags/Exception/"/>
    
    <category term="openFeign" scheme="https://minster.top/tags/openFeign/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现缓存及解决缓存产生的问题</title>
    <link href="https://minster.top/2022/07/22/Redis%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"/>
    <id>https://minster.top/2022/07/22/Redis%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</id>
    <published>2022-07-22T09:08:15.000Z</published>
    <updated>2023-08-16T00:37:27.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将以查询商铺信息业务为主线，使用Redis做缓存逐步提升查询商铺的效率。</p><p>同时提供使用Redis缓存过程中遇到的数据一致性、缓存击穿、缓存穿透、缓存雪崩等问题的解决思路。</p><span id="more"></span><h2 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h2><p>在查询商户业务中，如果不使用缓存，而是直接像以下代码那样去查询数据库，效率是非常慢的！因为查询数据库操作的是磁盘，而操作磁盘需要大量的IO操作，从而导致查询效率非常慢！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//这里是直接查询数据库</span></span><br><span class="line">    <span class="keyword">return</span> shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用Postman测试一下效率</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230620215005159.png" alt="image-20230620215005159"></p><p>可以发现，在数据量比较少的情况下，还是需要280ms</p><p>下面我们使用redis做缓存优化一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使用redis数据类型做缓存</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">     <span class="comment">// 查看redis中是否存在对应数据</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line"></span><br><span class="line">     <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shop</span>();</span><br><span class="line">    <span class="comment">// 判断缓存中有没有店铺信息</span></span><br><span class="line">     <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">         <span class="comment">// 存在 返回</span></span><br><span class="line">         shop = JSONUtil.toBean(shopJson, Shop.class)</span><br><span class="line">         <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 不存在 从数据库中查找</span></span><br><span class="line">     shop =  getById(id);</span><br><span class="line">     <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="comment">// 查不到对应的数据 返回</span></span><br><span class="line">         <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 将对应的数据添加到redis中</span></span><br><span class="line">     redisTemplate.opsForValue().set(CACHE_SHOP_KEY + id,JSONUtil.toJsonStr(shop));</span><br><span class="line">     <span class="comment">// 查到对应的数据 返回</span></span><br><span class="line">     <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用Postman测试一下效率</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230620215911050.png" alt="image-20230620215911050"></p><p>可以发现，查询用时为16ms，效率提升了十几倍！</p><p>下面是使用Redis做缓存的具体流程</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230620222156022.png" alt="Cache_Model"></p><p>以下是Redis实现添加商户缓存的业务逻辑图</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230620222915204.png" alt="add_shop_cache"></p><p><strong>小结：</strong></p><blockquote><p>使用Redis做商铺缓存可以提升我们的查询效率，但随之也产生了一些问题：我们缓存的数据是存放在内存中的，而内存并不像JVM那样，有垃圾回收机制，如果不加以措施，我们内存很容易爆掉！同时，因为我们的数据库数据是会发生改变的，而缓存的数据来自于数据库，我们该怎么样保证数据的一致性呢？</p></blockquote><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>其实，在Redis中，提供了一个缓存更新策略（其实就是缓存淘汰机制）；使用这个机制，可以很好的解决我们上一小节的问题。</p><p>下面是三种缓存更新策略</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230621205555248.png" alt="image-20230621205555248"></p><p>业务场景：</p><ul><li>低一致性要求：使用内存淘汰机制。例如店铺类型的查询缓存</li><li>高一致性要求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存</li></ul><p>现在回到我们的业务，查询商铺信息，也就是高一致性要求的场景下，我们可以使用主动更新，并以超时剔除作为兜底方案解决上面的问题。</p><p>而主动更新的话是有两种方案的：</p><ul><li>先删除缓存、再更新数据库</li><li>先更新数据库、再删除缓存</li></ul><p>上述两种方案看起来没什么区别，但是高并发场景下差别可是很大的，我们一般选择后者。原因如下：</p><blockquote><p><strong>场景：缓存和数据库中的字段A&#x3D;10，现在线程1要将A修改成20，同时，线程2想查询这个字段</strong></p></blockquote><p>如果你选择第一种方案，在两个线程并发来访问时，线程1先来，他要更新的是<code>A=20</code>，他先把缓存中的字段A删了，此时线程2过来，他查询缓存时发现字段A并不存在，他就只能去数据库查了，同时他将数据库查询的数据<code>A=10</code>写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入数据库的数据A&#x3D;20，与缓存中的不一致，导致后面其他线程再来查询A的时候，值都是缓存中的10；</p><p><strong>通过上述分析，下面我们修改代码实现我们的查询商铺信息业务中数据在数据库和缓存的双写一致</strong></p><ul><li><p>第一个要修改的地方，每次修改店铺时，我们需要<strong>先更新数据库，再删除缓存</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateShopById</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据id修改店铺</span></span><br><span class="line">    <span class="keyword">if</span> (shop.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺id为空, 修改失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先更新数据库</span></span><br><span class="line">    updateById(shop);</span><br><span class="line">    <span class="comment">// 修改完成后删除缓存</span></span><br><span class="line">    stringRedisTemplate.delete(CACHE_SHOP_KEY + shop.getId());</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二个要修改的地方，我们在添加redis缓存时，应该给我们<strong>缓存数据设置有效期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使用redis数据类型做缓存</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">     <span class="comment">// 查看redis中是否存在对应数据</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line"></span><br><span class="line">     <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shop</span>();</span><br><span class="line">    <span class="comment">// 判断缓存中有没有店铺信息</span></span><br><span class="line">     <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">         <span class="comment">// 存在 返回</span></span><br><span class="line">         shop = JSONUtil.toBean(shopJson, Shop.class)</span><br><span class="line">         <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 不存在 从数据库中查找</span></span><br><span class="line">     shop =  getById(id);</span><br><span class="line">     <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="comment">// 查不到对应的数据 返回</span></span><br><span class="line">         <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 将对应的数据添加到redis中 并且设置缓存过期时间</span></span><br><span class="line">     redisTemplate.opsForValue().set(CACHE_SHOP_KEY + id,JSONUtil.toJsonStr(shop), <span class="number">30L</span>, TimeUnit.MINUTES);</span><br><span class="line">     <span class="comment">// 查到对应的数据 返回</span></span><br><span class="line">     <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>小结：</strong></p><blockquote><p>目前，我们通过缓存更新策略，暂且解决了我们的缓存导致内存爆满以及数据一致性的要求。</p><p>但是，由于我们的缓存数据是有一定的有效期的，同时也会产生以下三个redis缓存中常见的问题：</p><ul><li><strong>缓存穿透：</strong>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</li><li><strong>缓存雪崩：</strong>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</li><li><strong>缓存击穿：</strong>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</li></ul><p>下面三个小节将逐步分析这几个问题以及解决思路</p></blockquote><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote><p>在我们当前查询商户信息业务下可能会发生缓存穿透的场景：</p><p>比方说现在有一个用户想要查询id&#x3D;10的商户，按照我们上面的逻辑，会先去redis缓存中查询是否存在，如果redis不存在，则去数据库中查询，但是由于用户查询的是不存在的店铺，我们并不会把后面从数据库中查询到的不存在店铺的信息保存到redis中，而是直接返回店铺不存在信息给用户。</p><p>如果这个时候，这个用户不安好心，疯狂的往我们的系统中查询这个店铺的信息，那么这些请求会全部打到我们的数据库中，从而给我们数据库造成巨大的压力。</p></blockquote><p>上述场景中，大量的请求穿过了我们的redis缓存，到达数据库，这样是非常危险的，这也就是所谓的缓存穿透了。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230622075634008.png" alt="image-20230622075634008"></p><p>缓存穿透的解决方案有两种：</p><ul><li>当查询到数据不存在时，我们将null数据存储到缓存当中去，从而避免大量的请求到达数据库</li><li>使用布隆过滤器</li></ul><p><strong>方案一设置null值解决思路：</strong></p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/Cache_penetration_1.png" alt="Cache_penetration_1"></p><p>如上图所示，我们只需要在查询到null数据的时候，往我们的缓存中设置null值，即可解决缓存穿透问题。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithPassThrough</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 查看redis中是否存在对应数据 shopJson的可能取值 1.shop 2.null 3.&#123;&#125;</span></span><br><span class="line">    log.info(<span class="string">&quot;缓存穿透解决方案~ &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    log.info(<span class="string">&quot;shopJson =  &#123;&#125;&quot;</span>, shopJson);</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="comment">// 存在 返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果redis中查到的json无效 并且不为null 说明店铺不存在</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在 从数据库中查找</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在redis中添加一个有效期为2min的空数据 避免缓存穿透</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 查不到对应的数据 返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将对应的数据添加到redis中 并且设置超时时间 做缓存剔除</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">// 查到对应的数据 返回</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们使实现起来非常简单，但是如果用户多次查询到不同id的null值，那我们缓存中也会造成额外的内存消耗！</p><p><strong>方案二布隆过滤器解决思路：</strong></p><p>布隆过滤器其实本质就是一个二进制的数组，然后我们像布隆过滤器中存值时，会通过指定的hash算法来分别算出这个值在我们的二进制数组当中对应的下标位置，然后把这个下标位置对应的值改为1（数组初始化默认为0）；当我们要查询这个值是否存在时，我们只需要判断我们这个值对应的数组下标位置的值是否为全为1即可。</p><p>也就是说，布隆过滤器判定某个值不存在，则必定不存在；判定某个值存在，则大概率存在；</p><p>布隆过滤器解决缓存穿透的实现思路其实就是在我们的用户与redis之间增加一层过滤器，然后我们存放商铺数据的时候，需要把我们的商铺id信息存储到布隆过滤器中；当客户要查询商铺时，我们可以先通过布隆过滤器检查这个id是否存在，如果不存在直接返回null，这样就很好的解决了方案一中浪费内存的问题。但是布隆过滤器可能会存在误判的问题，以及要删除布隆过滤器中的数据也是非常困难的。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230625174538016.png" alt="image-20230625174538016"></p><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存穿透 - 布隆过滤器解决</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithPassThrough</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 查看redis中是否存在对应数据 shopJson的可能取值 1.shop 2.null 3.&#123;&#125;</span></span><br><span class="line">    log.info(<span class="string">&quot;缓存穿透解决方案~ &quot;</span>);</span><br><span class="line">    <span class="comment">// 创建Redisson提供的布隆过滤器</span></span><br><span class="line">    RBloomFilter&lt;Object&gt; bloomFilter = redissonConfig.redissonClient().getBloomFilter(<span class="string">&quot;shopCacheBloomFilter&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化布隆过滤器</span></span><br><span class="line">    bloomFilter.tryInit(<span class="number">10000</span>,<span class="number">0.01</span>);</span><br><span class="line">    <span class="comment">// 模拟向布隆过滤器添加商铺id数据 这一步通常在添加商铺时完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0L</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        bloomFilter.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测布隆过滤器, 如果id不存在过滤器中, 直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (!bloomFilter.contains(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    log.info(<span class="string">&quot;shopJson =  &#123;&#125;&quot;</span>, shopJson);</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="comment">// 存在 返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在 从数据库中查找</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在redis中添加一个有效期为2min的空数据 避免缓存穿透</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 查不到对应的数据 返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将对应的数据添加到redis中 并且设置超时时间 做缓存剔除</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查到对应的数据 返回</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿也叫热点key问题，就是一个被高并发访问key突然失效了，我们就需要去重建这个缓存，如果这个key的缓存重建业务比较复杂，那么就会造成大量的请求打到数据库上，给数据库造成巨大的压力。<strong>这也就是我们经常所说的热点key问题。</strong></p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230709203010616.png" alt="image-20230709203010616"></p><p>如上图所示，<strong>其实就是因为我们需要给key设定有效时间</strong>，而<strong>我们重构这个key的缓存的业务需要花费很长的时间，导致大量的请求都打到了我们的数据库中，</strong>给数据库造成了巨大的压力，这就是缓存击穿。</p><p>那么，针对上述产生缓存击穿的原因，目前主流的解决方案有两种：</p><ul><li>将key的有效期设置成逻辑有效期</li><li>在重建缓存的时候，使用互斥锁，保证只有一个线程参与缓存的重建</li></ul><hr><p><strong>两种方案的实现思路</strong></p><ul><li><p>互斥锁方案</p><p>在互斥锁解决缓存击穿的方案中，当我们需要进行重建缓存之前，我们需要先去获取互斥锁，只有拿到互斥锁的线程，才有资格去重建缓存。</p><p>而没有抢到互斥锁的资源，则需要休眠一段时间，之后再自旋去尝试获取互斥锁。当然，每一次自旋都需要判断需要的获取的缓存是否已经重建了，如果重建了则返回即可。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230723215156830.png" alt="Mutex"></p></li><li><p>逻辑过期</p><p>在逻辑过期方案中，我们可以在value中多设置一个字段，这个字段存放的使我们当前key的过期时间，当我们命中缓存的时候，需要先去判断我们命中的缓存是否还是有效的，如果有效就返回缓存的数据；</p><p>如果当前时间在我们设置的逻辑过期时间之后，我们就需要去重建缓存，而重建缓存的之前，需要去竞争互斥锁资源，只有竞争到互斥锁资源的线程，才能去重建缓存，同时，我们可以使用并发编程中的异步方式去重建缓存，即异步开启一条线程去重建缓存。</p><p>没有竞争到互斥锁的线程则返回过期的数据（脏数据）。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230723215700402.png" alt="image-20230723215700402"></p></li></ul><p><strong>两种方案的对比：</strong></p><ul><li><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据的一致性不会有问题，同时我们实现起来也很简单，只需要加锁即可。但是由于重建的过程中其他线程会处于阻塞，导致性能变差，并且可能会发生死锁。</li><li><strong>逻辑过期方案：</strong>通过逻辑过期，保证了线程在读取缓存的过程中，不需要阻塞了。同时，重建缓存的过程只需要一个线程去异步进行，其他线程可以正常读取数据。但是重建缓存完成之前返回的数据都是脏数据，会有数据不一致的问题产生，并且实现起来比较难</li></ul><hr><p><strong>两种方案的代码实现：</strong></p><p>首先我们可以通过Redis的<code>SETNX</code>命令来实现互斥锁</p><blockquote><p>这里也可以直接使用Redisson的互斥锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取互斥锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key* <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成互斥锁 有效期大约为具体业务的十倍</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lock</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//  log.info(&quot;获取了互斥锁 &#123;&#125;&quot;, key);</span></span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放互斥锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;释放了互斥锁 &#123;&#125;&quot;</span>, key);</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>互斥锁解决缓存击穿的代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存击穿 互斥锁解决方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.heng.entity.Shop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 查看redis中是否存在对应数据 shopJson的可能取值 1.shop 2.null 3.&#123;&#125;</span></span><br><span class="line">    <span class="comment">//log.info(&quot;缓存击穿 互斥锁解决方案~ &quot;);</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//log.info(&quot;shopJson =  &#123;&#125;&quot;, shopJson);</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="comment">// 存在 返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果redis中查到的json无效 并且不为null 说明店铺不存在</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在 竞争互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="comment">// 竞争不到互斥锁 休眠</span></span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 竞争到锁资源 判断redis是否已经重建了 避免高并发下 反复重构</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonShop</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// DoubleCheck</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(jsonShop)) &#123;</span><br><span class="line">            <span class="type">Shop</span> <span class="variable">cacheShop</span> <span class="operator">=</span> JSONUtil.toBean(jsonShop, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> cacheShop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 从数据库中查询</span></span><br><span class="line">        shop = getById(id);</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 找不到对应的数据 防止缓存穿透 在redis中构建一个空的缓存</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 重构redis缓存</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放互斥锁</span></span><br><span class="line">        unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>逻辑过期解决缓存击穿的代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存击穿 逻辑过期解决方案</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.hmdp.entity.Shop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 从redis缓存中去热点数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">// 如果没命中 返回null (不命中说明没有设置成热点数据 所以直接返回null)</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(shopJson)) &#123;</span><br><span class="line">        <span class="comment">// 存在 返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果命中 判断逻辑有效时间是否过期</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为RedisData类中的data可以是其他需要缓存的热点数据 所以是使用Object去接的 我们可以将它强转成JSONObject类型 以便于获取数据的实际实体类</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(jsonObject, Shop.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果逻辑有效时间过期, 重键缓存</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 过期 重建缓存</span></span><br><span class="line">    <span class="comment">// 1. 获取互斥锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">// 2. 先判断缓存是否已经被重建了</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson1</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData1</span> <span class="operator">=</span> JSONUtil.toBean(shopJson1, RedisData.class);</span><br><span class="line">        <span class="keyword">if</span> (redisData1.getExpireTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject1</span> <span class="operator">=</span> (JSONObject) redisData1.getData();</span><br><span class="line">            shop = JSONUtil.toBean(jsonObject1, Shop.class);</span><br><span class="line">            <span class="comment">// 返回重建后的商铺缓存信息</span></span><br><span class="line">            <span class="keyword">return</span> shop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 开启另外一条线程进行缓存重建</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveRedisData(id, <span class="number">10L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放互斥锁</span></span><br><span class="line">                unlock(LOCK_SHOP_KEY + id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文将以查询商铺信息业务为主线，使用Redis做缓存逐步提升查询商铺的效率。&lt;/p&gt;
&lt;p&gt;同时提供使用Redis缓存过程中遇到的数据一致性、缓存击穿、缓存穿透、缓存雪崩等问题的解决思路。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis 缓存问题" scheme="https://minster.top/categories/Redis-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="Redis" scheme="https://minster.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Eureka中的负载均衡</title>
    <link href="https://minster.top/2022/07/03/Eureka%E4%B8%AD%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://minster.top/2022/07/03/Eureka%E4%B8%AD%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2022-07-03T13:21:04.000Z</published>
    <updated>2023-08-16T00:37:41.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Eureka中的负载均衡"><a href="#Eureka中的负载均衡" class="headerlink" title="Eureka中的负载均衡"></a>Eureka中的负载均衡</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Eureka是Netflix开发的一种用于构建分布式系统中的微服务架构的服务发现组件。</p><p>Ribbon是一个基于HTTP和TCP协议的客户端负载均衡工具，它是Netflix开源的一个组件，旨在提供客户端侧负载均衡算法和服务实例的自动发现功能，以实现对服务调用的负载均衡。</p><p>Spring官方提供了一个Spring Cloud LoadBalancer来替代Ribbon它是基于Netflix Ribbon的一个新的客户端负载均衡组件，提供更加灵活的扩展性和可配置性。</p><p>而在我们的Eureka中实现服务的远程调用则是通过Spring Cloud LoadBalancer来完成。本文将结合源码分析一下Euraka拉取服务以及远程调用服务的过程。</p><span id="more"></span><h3 id="Eureka与Ribbon的关系"><a href="#Eureka与Ribbon的关系" class="headerlink" title="Eureka与Ribbon的关系"></a>Eureka与Ribbon的关系</h3><p>Eureka组件只提供服务的注册和发现功能，它本身并不具备负载均衡的功能。但我们使用Eureka组件时却能实现服务请求的处理和分配（负载均衡），正是因为Eureka中集成了Ribbon负载均衡组件。</p><blockquote><p>Ribbon是Netflix开源的一种用于构建分布式系统中的微服务架构的客户端负载均衡组件。Ribbon支持多种负载均衡算法，例如轮询、随机、加权轮询、加权随机等，并且支持自定义负载均衡算法。Ribbon可以与Eureka、Consul等服务发现组件集成，也可以与Spring Cloud LoadBalancer等负载均衡器集成，提供更加灵活和可扩展的负载均衡功能。</p></blockquote><h3 id="为什么要使用Eureka"><a href="#为什么要使用Eureka" class="headerlink" title="为什么要使用Eureka"></a>为什么要使用Eureka</h3><p>现在有一个案例：在分布式的架构中，有两个节点order-service以及user-service。</p><p>在order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706170322077.png" alt="image-20230706170322077"></p><p>如果上图所示，我们在order-service服务中需要想user-service中发起一个请求，才能取到对应的用户信息。</p><p>要实现上述需求，我们可以这样做</p><ol><li><p>在order-service中注册RestTemplate</p><blockquote><p>RestTemplate是Spring框架提供的一个用于发送HTTP请求的客户端库，主要用于调用RESTful Web服务时发送请求并接收响应。它可以发送GET、POST、PUT、DELETE等HTTP请求，并接收相应的响应。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: minster</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PACKAGE</span>_NAME: cn.itcast.config</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@NAME</span>: RestConfiguration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2023/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改order-service中的order业务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">    <span class="comment">// 2. 远程查询user信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/user/&quot;</span> + order.getUserId();</span><br><span class="line">    <span class="comment">// 3. 通过restTemplate发起调用</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">    <span class="comment">// 4. 封装数据到order</span></span><br><span class="line">    order.setUser(user);</span><br><span class="line">    <span class="comment">// 5. 返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>测试：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706171645353.png" alt="image-20230706171645353"></p><p>如下图所示，我们的user-service提供了接口给外部使用，即服务提供者。而order-service使用了user-service，即服务消费者。</p><blockquote><p>服务提供者与服务消费者是相对的，一个服务既有可能是服务提供者，也有可能是服务消费者</p></blockquote><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706141607328.png" alt="image-20230706141607328"></p><p>虽然上述代码实现了需求，但是我们可以发现以下问题：</p><ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时该如何选择？</li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li></ul><p>上述问题都需要利用Spring Cloud中的注册中心来解决，其中Eureka便是一个注册中心。</p><p>下面我们使用一个案例，来演示基于Eureka组件的服务注册与发现以及服务调用请求的分配，分析Eureka是怎么解决上述三个问题的。</p><p>案例的架构如下：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706102828818.png" alt="image-20230706102828818"></p><p><strong>实现代码</strong></p><p>新建项目eureka-server</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706173731285.png" alt="image-20230706173731285"></p><p>导入服务端依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写配置信息。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里配置了eureka-server的端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># applicatio-name: 其实就是在注册中心的服务名字</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>开启EurekaServer服务功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.discovery.EurekaNamespace;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: minster</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PACKAGE</span>_NAME: cn.itcast</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@NAME</span>: EurekaApplication</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2023/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// @EnableEurekaServer 可以开启EurekaServer服务</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:10086/">Eureka</a></p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706174019102.png" alt="image-20230706174019102"></p><p>我们可以发现eureka-server服务已经成功注册到我们的Eureka注册中心</p><p>同时，我们将order-service、user-service服务也注册到我们的Eureka注册中心</p><p>步骤如下：</p><ol><li><p>导入客户端依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure></li></ol><p>注册步骤一样，这里不再演示。</p><p>同时，我们多启动一个user-service，构成一个user服务集群。</p><p>当前服务启动情况如下图所示：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706175121795.png" alt="image-20230706175121795"></p><p>刷新一下<a href="http://localhost:10086/">Eureka</a>，可以发现，我们都客户端服务都注册到我们的Eureka中</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706175230190.png" alt="image-20230706175230190"></p><p>下面我们修改order-service中的业务代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">    <span class="comment">// 2. 远程查询user信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br><span class="line">    <span class="comment">// 3. 通过restTemplate发起调用</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">    <span class="comment">// 4. 封装数据到order</span></span><br><span class="line">    order.setUser(user);</span><br><span class="line">    <span class="comment">// 5. 返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在order-service中的RestTemplate配置类中给Bean添加<code>@LoadBalanced</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用order服务接口，查看两个user-service中的控制台的日志</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706175757006.png" alt="image-20230706175757006"></p><p>我们可以发现，两个user-service服务都被调用到了！</p><p>Eureka是怎么做到的呢？我们可以通过下图分析</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706180452345.png" alt="image-20230706180452345"></p><p>在我们上述案例中，我们通过配置客户端配置文件中的</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>分别将我们的order-service、user-service注册到注册中心当中去。</p><p>当我们需要调用的时候，我们的服务消费者只需要去注册中心拉取我们的服务信息，然后再进行远程调用即可，这也就解释我们上面的第一个问题：<strong>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口的</strong></p><p>然后当我们的服务注册到Eureka注册中心之后，我们的注册中心会定期检查我们服务的一个健康状态的，通常是30s，这样也就能解决我们上述的第三个问题：<strong>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</strong></p><p>然后对于第二个问题：<strong>有多个user-service实例地址，order-service调用时该如何选择？</strong>在这里，我们可以看到在RestTemplate中加了一个注解<code>@LoadBalanced</code>，这个注解的作用其实就是做了一个负载均衡，具体的原理，如下图所示：</p><p> <img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706195504888.png" alt="image-20230706195504888"></p><h3 id="Ribbon负载均衡在SpringCloud中的实现（源码分析）"><a href="#Ribbon负载均衡在SpringCloud中的实现（源码分析）" class="headerlink" title="Ribbon负载均衡在SpringCloud中的实现（源码分析）"></a>Ribbon负载均衡在SpringCloud中的实现（源码分析）</h3><p>在上述案列中，我们只加了一个<code>@LoadBalanced</code>注解，就实现了负载均衡，这个注解到底做了什么呢？</p><p>下面我们通过源码追踪，分析一下SpringCloud是如何实现Ribbon负载均衡的。</p><p>我们先定位到<code>@LoadBalanced</code>注解所在的包，发现在同包下有一个<code>LoadBalancerInterceptor</code> 类。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706200720713.png" alt="image-20230706200720713"></p><p>顾名思义，这是一个负载均衡的拦截器，我们以这个类为起点，进行调试，源码追踪</p><p><strong>进入到我们的<code>LoadBalancerInterceptor</code> 类中，发现其中有一个<code>intercept</code> 方法，我们打个断点，调试</strong></p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706201039313.png" alt="image-20230706201039313"></p><p>可以发现，<code>intercept</code>方法将我们order-service中发送到服务提供者user-service的请求拦截下来了，并且解析了我们的请求url，获取我们服务提供者的主机名。</p><p>我们继续追踪，查看<code>loadBalancer.execute</code>方法到底做了什么，追踪到<code>LoadBalancerClient</code>的一个实现类<code>RibbonLoadBalancerClient</code> 中</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706201714764.png" alt="image-20230706201714764"></p><p>我们可以发现，主机名：userservice作为参数传递到了<code>getLoadBalancer</code>方法中，我们追踪该方法，看一下里面到底做了什么。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706204336667.png" alt="image-20230706204336667"></p><p><code>getLoadBalancer</code> 方法最终返回了一个Feign Client实例，通过这个Feign Client我们可以从Eureka中拉取对应我们的serviceId对应的服务，也就是userservice服务。</p><blockquote><p>在使用Feign Client进行服务调用时，Feign Client会通过负载均衡器来选择要调用的服务实例。</p></blockquote><p>我们继续往下调试</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706204944251.png" alt="image-20230706204944251"></p><p>在通过<code>getLoadBalancer(serviceId)</code> 方法获取到的返回值loadBalancer中，可以看到我们的userservice对应的端口！也就是说我们的拉取服务是在这里完成的。</p><p>我们继续追踪源码，看一个<code>execute</code> 方法中的<code>getServer()</code>到底做了什么。可以发现，后面<code>getServer()</code>会调用到<code>BaseLoadBalancer</code>类下的<code>chooseServer</code>方法中。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706210502196.png" alt="image-20230706210502196"></p><p>我们将这个方法分成两部分来看，分别解析：</p><p><strong>第一部分：</strong></p><blockquote><p>在这里，我们做了一个计数器的自增操作，因为我们在我们的负载均衡的轮询策略中，是按照一定的顺序来依次执行的。每次选择服务实例时，计数器会自增1，从而实现轮询的效果。</p><p>例如，假设我们有三个服务A，B，C，我们的负载均衡采取了轮询的策略来进行服务的调用。</p><p>当我们进行第一次进行服务选择时，负载均衡器会选择我们的第0个服务，也就是A；</p><p>当我们进行第二次进行服务选择时，负载均衡器会选择我们的第1个服务，也就是B；</p><p>当我们进行第三次进行服务选择时，负载均衡器会选择我们的第2个服务，也就是C；</p><p>当我们进行第四次进行服务选择时，由于已经选择了所有的服务实例，负载均衡器会重新从第0个服务实例开始选择。</p></blockquote><p><strong>第二部分：</strong></p><blockquote><p>在这里，我们会根据指定的负载均衡策略对应的算法，对我们的服务进行一个选择操作，如果我们没有指定负载均衡策略，则会使用Ribbon默认的负载均衡策略——轮询。</p></blockquote><p>上述的负载均衡策略是通过rule获取的，我们可以看一下，rule的类型以及实现类</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230706212556355.png" alt="image-20230706212556355"></p><blockquote><p>拓展：IRule的实现类及其代表的含义如下</p><ol><li><strong>RoundRobinRule（轮询规则）：</strong>按照顺序依次选择可用的服务器进行请求分发，实现简单的轮询负载均衡。</li><li><strong>WeightedResponseTimeRule（加权响应时间规则）：</strong>根据每个服务器的平均响应时间和权重，选择一个性能较好的服务器进行请求分发。具有更低响应时间和较高权重的服务器将有更高的概率被选中。</li><li><strong>RandomRule（随机规则）：</strong>随机选择一个可用的服务器进行请求分发。具有平均负载分布的特点，适用于无需特定负载均衡策略的场景。</li><li><strong>RetryRule（重试规则）：</strong>在请求失败时，会尝试重新选择一个可用的服务器进行重试。该规则适用于具有容错需求的场景，可以增加系统的可靠性。</li><li><strong>AvailabilityFilteringRule（可用性过滤规则）：</strong>根据服务器的可用性和运行状态，选择一个可用的服务器进行请求分发。它会排除掉那些因为故障或超负荷而不可用的服务器。</li><li><strong>BestAvailableRule（最佳可用规则）：</strong>选择一个可用服务器中并发连接最低的服务器进行请求分发。这有助于减少请求被发送到负载较高的服务器上。</li><li><strong>ZoneAvoidanceRule：</strong>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</li></ol></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在最后，我们可以发现，我们使用SpringCloud整合Eureka注册中心实现服务的注册发现与处理分配时，其实就是通过我们的<code>LoadBalancerInterceptor</code>将我们的要调用的服务拦截下来，并获取我们服务请求url中的主机名，然后通过<code>Feign Client</code>和负载均衡器到我们的Eureka注册中心拉取服务列表。</p><p>拉取到服务列表之后，我们会调用<code>getServer()</code>方法去执行我们的负载均衡策略，通过我们设定的负载均衡策略（默认是轮询），执行对应的负载均衡算法，从而选择一个服务列表中选择一个适合的服务给我们的服务消费者使用 。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Eureka中的负载均衡&quot;&gt;&lt;a href=&quot;#Eureka中的负载均衡&quot; class=&quot;headerlink&quot; title=&quot;Eureka中的负载均衡&quot;&gt;&lt;/a&gt;Eureka中的负载均衡&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Eureka是Netflix开发的一种用于构建分布式系统中的微服务架构的服务发现组件。&lt;/p&gt;
&lt;p&gt;Ribbon是一个基于HTTP和TCP协议的客户端负载均衡工具，它是Netflix开源的一个组件，旨在提供客户端侧负载均衡算法和服务实例的自动发现功能，以实现对服务调用的负载均衡。&lt;/p&gt;
&lt;p&gt;Spring官方提供了一个Spring Cloud LoadBalancer来替代Ribbon它是基于Netflix Ribbon的一个新的客户端负载均衡组件，提供更加灵活的扩展性和可配置性。&lt;/p&gt;
&lt;p&gt;而在我们的Eureka中实现服务的远程调用则是通过Spring Cloud LoadBalancer来完成。本文将结合源码分析一下Euraka拉取服务以及远程调用服务的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Cloud" scheme="https://minster.top/categories/Spring-Cloud/"/>
    
    
    <category term="Spring Cloud" scheme="https://minster.top/tags/Spring-Cloud/"/>
    
    <category term="Ribbon" scheme="https://minster.top/tags/Ribbon/"/>
    
    <category term="Eureka" scheme="https://minster.top/tags/Eureka/"/>
    
    <category term="Spring Cloud LoadBalancer" scheme="https://minster.top/tags/Spring-Cloud-LoadBalancer/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题汇总（持续更新！）</title>
    <link href="https://minster.top/2022/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/"/>
    <id>https://minster.top/2022/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/</id>
    <published>2022-06-03T13:21:04.000Z</published>
    <updated>2023-08-16T00:38:19.210Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/moon-4919501_1920.jpg" alt="moon"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下是我对Java高频面试题的一个总结，后面我会持续更新，希望对你有所帮助。<br>当然，如果有哪道题目我理解错误了，或者是你有更好的见解，非常欢迎你在评论区中留下宝贵的意见！</p><span id="more"></span><h2 id="JavaSE基础"><a href="#JavaSE基础" class="headerlink" title="JavaSE基础"></a>JavaSE基础</h2><h3 id="1-JDK、JRE、JVM分别是什么，有什么区别"><a href="#1-JDK、JRE、JVM分别是什么，有什么区别" class="headerlink" title="1. JDK、JRE、JVM分别是什么，有什么区别"></a>1. JDK、JRE、JVM分别是什么，有什么区别</h3><ul><li><strong>JDK(Java Development Kit) ：</strong> 是Java标准开发包，它提供了编译、运行Java所需要的各种工具和资源，包括Java编译器、Java运行环境、以及常用的类库等</li><li><strong>JRE(Java Runtime Enviroment)：</strong>Java的运行环境，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件</li><li><strong>JVM(Java Virtual Mechinal)：</strong>Java虚拟机，是JRE的一部分，它用于编译执行字节码文件，是可运行Java字节码文件的虚拟计算机</li></ul><p><strong>区别</strong></p><ul><li>JDK用于开发，JRE用于运行Java程序，如果你只是为了运行一下Java程序的话，安装JRE即可，但是要开发Java程序的话，必须要安装JDK</li><li>JDK包含JRE，JDK、JRE中都有JVM</li><li>JVM是Java实现跨平台性的核心，它具有平台独立性能，它拥有类加载以及垃圾回收等机制。</li></ul><h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2. 重载和重写的区别"></a>2. 重载和重写的区别</h3><ul><li>重载发生在同一类中，当同一类中的两个或多个方法，方法名相同，参数列表不同，就构成了重载</li><li>重写发生在类的父子关系中，当一个类继承另一个类或者实现了某一个接口，就可以重写该类的非私有方法，从而实现功能的拓展；重写要求方法名、参数列表相同</li></ul><h3 id="3-x3D-x3D-和equals的区别是什么"><a href="#3-x3D-x3D-和equals的区别是什么" class="headerlink" title="3. &#x3D;&#x3D;和equals的区别是什么"></a>3. &#x3D;&#x3D;和equals的区别是什么</h3><p>&#x3D;&#x3D;对于基本类型来说就是值的比较，对于引用类型来说就是引用的比较。</p><p>而equals默认情况下是引用的比较，只是因为有很多类都重写了equals方法，比如String、Integer等类都把它变成了值的比较。</p><h3 id="4-什么是hashCode"><a href="#4-什么是hashCode" class="headerlink" title="4. 什么是hashCode()"></a>4. 什么是hashCode()</h3><p>hashCode()方法作用获取一个哈希码，即散列码，它实际上是一个int整数。哈希码可以确定该对象在哈希表中的索引位置。hashCode的定义在Object类中，所以java中任何类都包含了hashCode函数。</p><p>散列表其实就是用来存放键值对（key-value），我们可以通过key快速检索出对应的value。其中就使用了散列码。</p><h3 id="5-hashCode与equals有什么关系"><a href="#5-hashCode与equals有什么关系" class="headerlink" title="5. hashCode与equals有什么关系"></a>5. hashCode与equals有什么关系</h3><p>要搞清楚他们之间的关系，我们可以从hash表的结构出发，其实hash表是一个数组+链表或红黑树的结构，Java的集合容器就有使用到这种数据结构的，然后在我们要存储对象到容器时可以先通过hashCode方法返回了一个hash值，这个hash与数组长度取余之后就能获取到该对象的存放在数组结构的一个对应的下标，<strong>当两个对象有相同的hash值的时候，说明存放的数组下标是一样的（也就是产生了哈希冲突）</strong>，那么此时我们就需要通过equals方法判断这两个对象是不是相同的对象，如果不是则插入在链表中，所以我们可以得下面结论：</p><ol><li>当两个对象相同时，它们的hash值也相同，它们之间的互相调用equals方法结果为true</li><li>当两个对象有相同的hashCode的值，那么它们也不一定相等。</li></ol><blockquote><p>补充：</p><p>对于HashSet存放的自定义类型来说，如果是同一个对象会插入失败</p><p>对于HashMap存放的自定义类型来说，如果是同一个对象会覆盖掉原来的value</p></blockquote><h3 id="6-为什么重写equals方法必须重写hashCode方法呢"><a href="#6-为什么重写equals方法必须重写hashCode方法呢" class="headerlink" title="6. 为什么重写equals方法必须重写hashCode方法呢"></a>6. 为什么重写equals方法必须重写hashCode方法呢</h3><p>首先在java的一些容器中，是不允许存放两个相同的对象的，如果对象相同会覆盖掉，而在散列表中我们存放对象时，会首先判断两个对象的hash值是否相同，如果相同再通过equals方法来判断是否为相同对象，如果是相同对象就会在散列表中覆盖掉，否则就插入到相关链表中，那么如果我们只重写了equals方法，而不重写hashCode方法，那么那么相同对象的值就无法覆盖了。</p><h3 id="7-面向对象的特征"><a href="#7-面向对象的特征" class="headerlink" title="7. 面向对象的特征"></a>7. 面向对象的特征</h3><p>面向对象主要有三大特征：封装性、继承、多态</p><ol><li><p>封装性：封装性指的是我们在定义对象时，尽可能的把对象状态信息隐藏起来，只提供有限的接口的方法给外界交互使用，从而避免外界对对象内部属性进行破坏。</p></li><li><p>继承：继承其实就是一种能力，当一个类A继承了另外一个类B时，A类就可以使用B类公开的所有的属性和方法，并且可以在不修改父类的前提下对其功能进行拓展。当然，如果B类存在用private修饰的属性或方法，A类是无法使用的，这就是封装性的体现。</p></li><li><p>多态：多态是指同一对象的不同形式的展现，比如说我们到宠物店跟店说“我要一只宠物”，那么店员就可以给我一只小猫、小狗、或者小蜥蜴等等，那么此时我们所说的宠物对象就是多态一种展现了。</p><blockquote><p>多态是怎么形成的</p><p>其实java的引用变量有两种类型，一种是编译时类型、一种是运行时类型，而编译类型由引用变量在定义时的声明所决定，运行时类型由实际赋值给引用变量的类型所决定，当编译时类型与运行时类型不一样时，就会产生所谓的多态</p></blockquote></li></ol><h3 id="8-接口和抽象类的共同点和区别"><a href="#8-接口和抽象类的共同点和区别" class="headerlink" title="8. 接口和抽象类的共同点和区别"></a>8. 接口和抽象类的共同点和区别</h3><p><strong>共同点：</strong></p><ul><li>都不能被实例化</li><li>都可以包含抽象方法</li><li>都可以有默认实现的方法（在JDK1.8之后才可以用default定义接口中的默认方法的）</li></ul><p><strong>区别：</strong></p><ul><li>接口用于对类的行为进行约束，一个类实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系</li><li>一个类只能继承一个类，但是可以实现多个接口</li><li>抽象类中有构造方法，接口中没有构造方法</li><li>抽象类中的成员变量默认是default，可以被子类重新定义赋值，接口中的成员变量是常量，不能被修改且必须要有初始值</li></ul><h3 id="9-java中操作字符串的类有哪些？他们之间有什么区别"><a href="#9-java中操作字符串的类有哪些？他们之间有什么区别" class="headerlink" title="9. java中操作字符串的类有哪些？他们之间有什么区别"></a>9. java中操作字符串的类有哪些？他们之间有什么区别</h3><p>操作字符串的类有主要有String、StringBuffer、StringBuilder三种。</p><p>在jdk1.8及以前String、StringBuffer、StringBuilder底层都是char数组。</p><p>在jdk1.9及以后，三者的底层都是byte数组。</p><blockquote><p>使用byte[]还能存放中文的原因是因为他们的底层会有一个coder的值，该值可以是<code>LATIN1</code>和<code>UTF16</code>的一种，所以能存放中文字符</p></blockquote><p>因为String类是由Final修饰的，所以String类的长度是不会变化，每当我们新建一个String类时都需要new一个对象，让指针指向新的对象。而StringBuffer、StringBuilder都是继承于AbstractStringBuilder，而AbstractStringBuilder底层是使用一个可变数组来存放字符串的，所以他们存放的字符串内容是可变的。而且存在扩容机制。</p><blockquote><p>扩容机制：</p><p>因为他们都是继承了AbstractStirngBuilder类，而该类有一个方法会检测当前字符串类的byte的容量是否足够来存放新的字符串，如果不能，进行扩容</p><p>扩容的逻辑就是先判断是字符串是否含有中文，在根据相应的一个处理得到一个新的byte数组，最后通过Arrays.copyOf方法将原来byte数组的值复制到新的byte值当中去。</p></blockquote><p>然后StringBuffer和StringBuilder之间是有线程是否安全的区别的。</p><p>StringBuffer因为加了同步锁synchronized所以线程安全，因为synchronized同步锁会有一个获取锁和释放锁的操作，所以StringBuffer的效率更低。</p><blockquote><p>为什么StringBuffer加了锁就效率更低呢？</p><p>因为synchronized锁其实是会有四种状态的升级和优化的。分别是：无锁、偏向锁、轻量级锁、重量级锁四种</p><p>偏向锁就是当一段同步代码或者是资源被同一个线程多次访问的时候，那么该线程就会自动获取锁，降低获取锁的代价。</p><p>而当锁是偏向锁时，如果有其他线程访问该锁时，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式来获取锁，不会阻塞，提高性能。</p><p>当前锁是轻量级锁时，另外一个线程不会一直自旋，当其自旋到一定次数后，轻量级锁会升级为重量级锁，其他线程进入阻塞状态，性能降低。因为线程自旋需要消耗cpu性能，所以自旋到一定次数后轻量级锁会膨胀成重量级锁。</p></blockquote><p>StringBuilde因为没有加锁，所以效率更高。</p><h3 id="10-String为什么要设计成不可变的？"><a href="#10-String为什么要设计成不可变的？" class="headerlink" title="10. String为什么要设计成不可变的？"></a>10. String为什么要设计成不可变的？</h3><p>String设计成不可变的原因主要有以下四点：</p><ol><li><p>便于实现字符串池（String pool）</p><p>因为在实际开发中，我们会大量的使用String常量，如果每次声明一个String类型都创建一个String对象的话，那将会造成极大的空间资源浪费。所以Java提出了String pool的概念，并且在堆中开放了一块专门用来存放String常量的字符串常量池(String Pool)。当我们初始化一个String变量时，JVM会先去查找字符串常量池是否已经存在该字符串了，如果存在则直接引用，如果不存在则新建一个字符串对象。</p><p>如果String是可以变的，那么一个字符串变量改变了他的值，都会指向一个新的String对象了，而String Pool也无法实现了</p></li><li><p>线程安全</p><p>在多线程环境下如果对同一个资源同时进行写操作时会引发一个线程安全的问题，而String设计成了不可变，确保了String对象不能被写，所以保证了多线程的安全。</p></li><li><p>避免安全问题</p><p>在网络连接和数据库连接中字符串常常作为参数，例如，网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。</p></li><li><p>加快字符串处理速度</p><p>由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。所以HashMap中的键往往都使用String。</p></li></ol><p>总体来说，String不可变的原因要包括 设计考虑，效率优化，以及安全性这三大方面。</p><h3 id="11-深克隆与浅克隆的区别（深拷贝和浅拷贝）"><a href="#11-深克隆与浅克隆的区别（深拷贝和浅拷贝）" class="headerlink" title="11. 深克隆与浅克隆的区别（深拷贝和浅拷贝）"></a>11. 深克隆与浅克隆的区别（深拷贝和浅拷贝）</h3><p>浅克隆（默认）</p><ul><li><p>拷贝出的新对象，与原对象中的数据一模一样（引用类型拷贝的是地址）</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230509175906576.png" alt="shallow-copy"></p></li></ul><p>深克隆（避免新对象修改其他对象内容时，影响原对象的对象内容）</p><ul><li><p>对象中基本类型的数据直接拷贝</p></li><li><p>对象中的字符串数据拷贝的还是地址</p></li><li><p>对象中还包含的其他对象，不会拷贝地址，会创建新对象</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230509175922784.png" alt="deep-copy"></p></li></ul><h3 id="12-Java-是编译执行的语言，还是解释执行的语言"><a href="#12-Java-是编译执行的语言，还是解释执行的语言" class="headerlink" title="12. Java 是编译执行的语言，还是解释执行的语言?"></a>12. Java 是编译执行的语言，还是解释执行的语言?</h3><p><strong>Java即是编译型的，也是解释型语言，总的来说Java更接近解释型语言</strong></p><ul><li>可以说它是编译型的。因为所有的Java代码都是要编译的，Java不经过编译就什么用都没有。同时围绕JVM的效率问题，会涉及一些如JIT、AOT等优化技术，例如JIT技术，会将热点代码编异成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码</li><li>可以说它是解释型的。因为Java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的。</li></ul><h3 id="13-jdk1-8的新特性"><a href="#13-jdk1-8的新特性" class="headerlink" title="13. jdk1.8的新特性"></a>13. jdk1.8的新特性</h3><ol><li><p>Lambda表达式</p><p>Lambda 允许把函数作为一个方法的参数</p></li><li><p>方法引用</p><p>方法引用允许直接引用已有Java类或对象的方法或构造方法</p></li><li><p>函数式接口</p><p>只有一个抽象方法的接口就叫函数式接口，函数式接口可以被隐式转换为Lambda表达式。通常函数式接口上回添加一个<code>@FunctionalInterface</code>注解</p></li><li><p>接口允许定义默认方法和静态方法</p><p>从JDK8开始，允许接口存在一个或多个默认非抽象方法和静态方法</p></li><li><p>Stream API（Stream流）</p><p>Stream API把真正的函数式编程风格引入到Java中。</p><p>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等</p></li><li><p>日期&#x2F;时间类改进</p><p>在JDK8之前，我们JDK提供的日期处理类非常不方便，我们在处理的时候通常是使用第三方工具包，比如<code>commons-lang</code> 包等。</p><p>在JDK8之后，因为LocalDateTime的出现，日期时间的创建、比较、调整、格式化、时间间隔等操作都比以往简单很多。</p></li><li><p>Optional 类</p><p>Optional 类是一个可以为null的容器对象。如果值存在则 <code>isPresent()</code> 方法会返回true，调用 <code>get()</code> 方法会返回该对象</p></li><li><p>Java8 Base64实现</p><p>Java8内置了 Base64 编码的编码器和解码器</p></li></ol><h3 id="14-Final有什么作用"><a href="#14-Final有什么作用" class="headerlink" title="14. Final有什么作用"></a>14. Final有什么作用</h3><p>Final是一个关键字修饰符，被Final修饰的类或成员变量有以下特点</p><ul><li><p>被final修饰的类不可以被继承</p></li><li><p>被final修饰的方法不可以被重写</p></li><li><p>被final修饰的变量不可以被改变</p><blockquote><p><strong>被final修饰的变量不可变的是变量的引用，而不是引用指向的内容，引用指向的内容时可以改变的</strong></p></blockquote></li></ul><h3 id="15-什么是反射机制"><a href="#15-什么是反射机制" class="headerlink" title="15. 什么是反射机制"></a>15. 什么是反射机制</h3><p>Java反射机制是在运行状态中，对于任意一个类，都能够获取到这个类的所有属性和方法的信息；对于任意一个对象，都能够调用它的任意一个方法和属性；</p><p>在Java中，这种动态获取类的信息以及动态调用对象的方法的功能被称为反射机制</p><h3 id="16-反射机制的优缺点"><a href="#16-反射机制的优缺点" class="headerlink" title="16. 反射机制的优缺点"></a>16. 反射机制的优缺点</h3><p>优点：运行期类型的判断，动态加载类，提高代码灵活度</p><p>缺点：性能瓶颈：反射相当于一系列解释操作，通知JVM要做的事情，性能比直接的Java代码要慢很多</p><h2 id="JavaSE进阶-IO"><a href="#JavaSE进阶-IO" class="headerlink" title="JavaSE进阶-IO"></a>JavaSE进阶-IO</h2><h3 id="1-BIO-NIO-AIO有什么区别？"><a href="#1-BIO-NIO-AIO有什么区别？" class="headerlink" title="1. BIO NIO AIO有什么区别？"></a>1. BIO NIO AIO有什么区别？</h3><ul><li><p>BIO：Block IO 同步阻塞式IO，就是我们平常使用的传统ID，它的特点是模式简单使用方便。但是并发处理能力低。</p></li><li><p>NIO：New IO 同步非阻塞IO，是传统IO的升级，客户端和服务端通过Channel（通道）通讯，实现了多路复用</p><blockquote><p>IO多路复用模型</p><p>该模型是有一个多路复用器，也就是一个选择器(Selector)，通过这个选择器，我们只需要一个线程便可以管理多个客户端连接。当用户数据到了之后才会为其服务</p></blockquote></li><li><p>AIO：Asynchronous IO 是NIO的升级，也叫NIO2，实现了一部非阻塞IO，一部IO的操作基于事件和回调机制</p></li></ul><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/BIO_NIO_AIO.png" alt="BIO_NIO_AIO"></p><h2 id="JavaSE进阶-异常"><a href="#JavaSE进阶-异常" class="headerlink" title="JavaSE进阶-异常"></a>JavaSE进阶-异常</h2><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230611074554345.png" alt="image-20230611074554345"></p><p><strong>Throwable是所有Java程序中错误处理的父类，他有两种子类：Error和Exception</strong></p><h3 id="1-Error-和-Exception-区别是什么"><a href="#1-Error-和-Exception-区别是什么" class="headerlink" title="1. Error 和 Exception 区别是什么"></a>1. Error 和 Exception 区别是什么</h3><ul><li><p><strong>Error</strong> </p><p>表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，最多只是显示错误信息</p></li><li><p><strong>Exception：</strong> 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<code>Exception</code> 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和一般异常(又叫受检查异常) 。</p></li></ul><h3 id="运行时异常（非受检查异常）和一般异常（受检查异常）的区别"><a href="#运行时异常（非受检查异常）和一般异常（受检查异常）的区别" class="headerlink" title="运行时异常（非受检查异常）和一般异常（受检查异常）的区别"></a>运行时异常（非受检查异常）和一般异常（受检查异常）的区别</h3><p><strong>运行时异常：</strong>包括 <code>RunTimeException</code> 类及其子类，表示JVM在运行期间可能出现的异常。Java编译器不会检查运行时异常。</p><blockquote><p>常见的运行时异常有：</p><p><code>NullPointException(空指针)</code>、<code>NumberFormatException（字符串转换为数字）</code>、<code>IndexOutOfBoundsException(数组越界)</code>、<code>ClassCastException(类转换异常)</code>、<code>ArrayStoreException(数据存储异常，操作数组时类型不一致)</code>等</p></blockquote><p><strong>一般异常(受检查异常)：</strong>是Exception中除 <code>RuntiemException</code> 及其子类紫外的异常。 Java编译器会检查一般异常（受检查异常）。</p><blockquote><p>常见的一般异常有：</p><p>IO相关的异常、<code>ClassNotFoundException</code> 、 <code>SQLException</code>等</p></blockquote><p><strong>两者之间的区别：</strong> 它们之间的区别就是是否在编译阶段就能检查到。</p><h2 id="JavaSE进阶-集合"><a href="#JavaSE进阶-集合" class="headerlink" title="JavaSE进阶-集合"></a>JavaSE进阶-集合</h2><h3 id="1-Array-和-ArrayList-有什么区别？"><a href="#1-Array-和-ArrayList-有什么区别？" class="headerlink" title="1. Array 和 ArrayList 有什么区别？"></a>1. Array 和 ArrayList 有什么区别？</h3><ul><li><p>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</p></li><li><p>Array 大小是固定的，ArrayList 的大小是动态变化的。</p></li><li><p>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</p></li></ul><h3 id="2-常见的集合类有哪些"><a href="#2-常见的集合类有哪些" class="headerlink" title="2. 常见的集合类有哪些"></a>2. 常见的集合类有哪些</h3><p>Java的集合容器有单列集合和双列集合两种，单列集合指的是Collection接口下的派生类：List、Set、Queue（JDK5 新增的队列）；双列集合则是Map接口下的派生类。</p><blockquote><p><strong>注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口</strong>。</p></blockquote><p>在集合体系中，List集合代表了可重复集合，他们是有索引的；Set集合代表无序不可重复的集合，只能根据元素本身来访问（无索引）。Queue集合是一个队列集合。</p><p>Map集合时可以存放key-value键值对的集合，他的key是不可重复的，value是可以重复的。</p><p>List集合常用的有ArrayList、LinkedList</p><p>Set集合中常用的有HashSet、TreeSet</p><p>Queue集合常用的有ArrayQueue</p><p>Map集合中常用的有HashMap、TreeMap、ConcurrentHashMap</p><h3 id="3-ArrayList与LinkedList的异同"><a href="#3-ArrayList与LinkedList的异同" class="headerlink" title="3. ArrayList与LinkedList的异同"></a>3. ArrayList与LinkedList的异同</h3><ul><li><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> Arraylist 底层使用的是Object数组（动态数组）；LinkedList 底层使用的是双向循环链表数据结构；</li><li><strong>插入和删除是否受元素位置的影响：</strong> <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。  <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li><li><strong>是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h3 id="4-ArrayList的扩容机制"><a href="#4-ArrayList的扩容机制" class="headerlink" title="4. ArrayList的扩容机制"></a>4. ArrayList的扩容机制</h3><p>因为ArrayList底层维护的是一个数组，所以ArrayList的扩容机制是基于Arrays.copyOf方法实现的。</p><p>当我们用默认的无参构造方法创建ArrayList集合的时候，ArrayList的初始长度为0。<strong>当我们向集合添加第一个元素的时候，ArrayList集合的长度为10；</strong></p><p>当我们向集合添加元素时都会有一个判断，就是查看当前容量是否可以继续添加元素，<strong>如果集合的容量够就添加到集合中，如果容量不够则触发扩容机制，扩容的大小为原集合容量的1.5倍。</strong></p><blockquote><p>1.5倍是因为新的集合容量为<strong>原集合容量</strong>与<strong>其右移一位之后</strong>的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure></blockquote><p>当我们使用有参构造去创建ArrayList集合时，扩容机制也与上面的一样，不过需要注意的是他扩容的大小为你传进去的参数的1.5倍</p><h3 id="5-HashMap的底层数据结构是什么"><a href="#5-HashMap的底层数据结构是什么" class="headerlink" title="5. HashMap的底层数据结构是什么"></a>5. HashMap的底层数据结构是什么</h3><p><strong>在JDK1.8以前，HashMap底层维护的是一个”数组+链表“的结构</strong>，数组是HashMap的主体，链表是为了解决哈希冲突而存在的。</p><p><strong>在JDK1.8之后，HashMap的底层变成了”数组+链表+红黑树“的数据结构了</strong>。</p><p>在JDK1.8之前，如果我们使用HashMap存放大量数据时，会使HashMap的链表结构变得非常长，这样会导致我们的查询效率变慢，严重的影响了HashMap的性能。</p><p>因此，在JDK1.8之后对数据结构做了进一步的优化，引进了红黑树，链表和红黑树会在达到一定条件时会进行转换：</p><ul><li>当链表长度达到了8，且数组的长度达到64时才会发生转换</li><li>因为在触发树化机制的时候，HashMap的底层会进行判断，如果当前数组的长度没有达到64，会优先对数组进行扩容，而不是进行树化，这样可以节省查询时间。</li></ul><blockquote><p><strong>面试官也许还会问：</strong></p><p>如你上面所说，为什么HashMap在JDK8之后不直接采取数组+红黑树的结构，而是使用数组+链表+红黑树的数据结构呢？</p><p>首先因为红黑树会在每次添加元素时进行一个左旋、右旋、变色等操作来保持平衡，链表则不会，因此链表插入数据的效率会比红黑树快。</p><p>所以在数据量很少的时候，链表的效率会比红黑树高；</p><p>但是当数据量多了之后，因为红黑树搜索的时间复杂度为O(log n)，而链表的是O(n)，因此选择红黑树可以增加的查询效率，但是新增的效率变慢了。</p><p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p></blockquote><h3 id="6-HashMap的扩容机制"><a href="#6-HashMap的扩容机制" class="headerlink" title="6. HashMap的扩容机制"></a>6. HashMap的扩容机制</h3><ul><li>HashMap底层维护了Node类型的数组table，默认为null，链表与红黑树是为了解决哈希冲突而存在的。</li><li>当创建对象时，将加载因子(loadfactor)初始化为0.75；</li><li>当添加key-value时，通过<strong>key</strong>的hash值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换<strong>value</strong>；<strong>如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。</strong></li><li>第一次添加时，会将需要扩容的table容量扩容到16，临界值(threshold)为12</li><li>如果需要再次扩容，会将需要扩容的table容量扩容到原来的2倍（32），临界值为原来的2倍（24） 依次类推。</li><li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），<strong>否则任然采用数组扩容机制</strong></li></ul><blockquote><p>HashSet的底层就是HashMap，唯一区别是HashSet的value值为一个常量，所以当同一hash值中的key相同时，会添加失败；而HashMap会替换掉key对应的value。</p></blockquote><h3 id="7-ConcurrentHashMap的实现原理是什么"><a href="#7-ConcurrentHashMap的实现原理是什么" class="headerlink" title="7. ConcurrentHashMap的实现原理是什么?"></a>7. ConcurrentHashMap的实现原理是什么?</h3><blockquote><p>ConcurrentHashMap的底层数据结构</p></blockquote><p>ConcurrentHashMap 在JDK1.7和JDK1.8的实现方式是不同的。</p><p><strong>JDK1.7</strong></p><p>ConcurrentHashMap在JDK1.7是由<code>segment</code> 和 <code>HashEntry</code> 组成的。**<code>ConcurrentHashMap</code>会把哈希桶切分成小数组（segment）**，每一个<code>segment</code> 都包含了n个<code>HashEntry</code> , 也就是我们<code>HashMap</code>的一个结构。</p><p><code>ConcurrentHashMap</code>能实现线程安全其实就是在每一个<code>segment</code> 中加了一个可重入锁（也就是说每一段数据都会有锁），当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。</p><p>底层结构图如下图所示</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/JDK_7_ConcurrentHashMap.png" alt="JDK_7_ConcurrentHashMap"></p><blockquote><p>补充：</p><p><code>segment</code>是<code>ConcurrentHashMap</code>的一个内部类，<strong>它继承了<code>ReentrantLock</code>可重入锁</strong>，扮演锁的角色（构成了分段锁）。所以<code>segment</code>锁也是可重入的。</p></blockquote><p><strong>JDK1.8</strong></p><p>在数据结构上，JDK1.8中<code>ConcurrentHashMap</code>选择了与HashMap相似的Node数组+链表+红黑树的数据结构，这样可以使<code>ConcurrentHashMap</code>的数据结构不再像JDK1.7那么的臃肿，使用起来更为方便；在锁的实现上，抛弃了原有的 <code>Segment</code> 分段锁，<strong>采用了<code>CAS+Synchronized</code>实现更加细粒度的锁</strong>。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230621195606507.png" alt="image-20230621195606507"></p><p>在JDK8中，<code>ConcurrentHashMap</code> 将锁的级别控制在了更细粒度的哈希桶数组元素级别，也就是说<strong>我们只需要在链表的头结点或者红黑树的根节点上加锁</strong>，就不会影响其他哈希桶数组元素的读写，从而实现了并发。</p><blockquote><p><strong>也许面试官还会问：为什么JDK8使用了<code>Synchronized</code>锁替换可重入锁<code>ReentrantLock</code>呢？</strong></p><ul><li>在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步转换。</li><li>减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</li></ul></blockquote><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-描述一下jvm加载-class文件的过程吗？（类加载过程）"><a href="#1-描述一下jvm加载-class文件的过程吗？（类加载过程）" class="headerlink" title="1. 描述一下jvm加载.class文件的过程吗？（类加载过程）"></a>1. 描述一下jvm加载.class文件的过程吗？（类加载过程）</h3><p>因为Class文件需要加载到虚拟机中才能运行和使用，所以就有了类加载的过程</p><p>类在JVM中的生命周期主要有：<strong>加载、连接、初始化、使用、卸载五部分组成。</strong></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong></p><p><strong>加载过程</strong>指的是JVM将经过javac编译的字节码文件加载到内存当中的过程。</p><p><strong>连接阶段分别由验证、准备、解析三个阶段组成。</strong></p><ul><li><p>验证阶段会对字节码文件的格式、元数据格式等进行验证，确保字节码文件没有损害JVM的内容，是保护JVM的一个阶段。</p></li><li><p>准备阶段会为class文件的静态变量分配内存，并赋予初始值，此时的初始值指的是0</p></li><li><p>解析阶段会将符号引用转换为直接引用</p></li></ul><p><strong>连接阶段完成之后会到初始化阶段</strong>，该阶段开始执行java中定义的代码，为变量赋予真正的初始值，指的是代码中程序员想要赋的值</p><blockquote><p>类加载是由类加载器完成的，类加载器分别有：启动类加载器、扩展类加载器、系统类加载器、自定义加载器等</p></blockquote><h3 id="2-什么是双亲委派模型，为什么要使用"><a href="#2-什么是双亲委派模型，为什么要使用" class="headerlink" title="2. 什么是双亲委派模型，为什么要使用"></a>2. 什么是双亲委派模型，为什么要使用</h3><p>双亲委派原则指的是类加载器在接收到类加载的一个请求时，不会立刻加载，会先委派该类的父类加载器去加载，只有当父类加载器在他的搜索范围内没有搜索到该类时，子类的加载器才会对该类进行加载。</p><p>这样做可以防止内存中出现多个相同的字节码文件；因为如果没有双亲委派模型的话，那么用户自己再定义了一个java.lang.String的类，就无法保证类的唯一性了。</p><h3 id="3-可达性算法"><a href="#3-可达性算法" class="headerlink" title="3. 可达性算法"></a>3. 可达性算法</h3><p>可达性算法的逻辑就是，在以一个GC Root为根节点的对象作为起点开始搜索，能遍历到的对象，也就是说该对象的引用还存在，就是可达的对象。而不能遍历到的对象，说明对象的引用已经不存在了，所以是不可达对象，也就是被GC回收的对象。</p><p>可以作为GC Roots的对象有哪些呢？</p><blockquote><ul><li>在栈帧的局部变量引用的对象</li><li>在本地方法区JNI引用的对象</li><li>在方法区（元空间）的静态变量或常量引用的对象</li></ul></blockquote><h3 id="4-你能说一下垃圾回收机制吗？"><a href="#4-你能说一下垃圾回收机制吗？" class="headerlink" title="4. 你能说一下垃圾回收机制吗？"></a>4. 你能说一下垃圾回收机制吗？</h3><p>首先我们要理解JVM的一个内存模型，因为JVM的内存模型是由栈、本地方法区、程序计算器、元空间、堆这5部分组成。</p><p>然后因为我们创建的对象，是存放在堆的，然后当我们一段代码执行完成之后，只有存放在栈的局部变量可以自动删除，而存放在堆的对象仍然存在，这时候就需要垃圾回收机制来回收堆的内存了。</p><p>然后垃圾回收的算法主要有三种</p><ul><li><p>标记清理法：就是先遍历一次堆里面的所有对象，把要删除的对象标记，然后再遍历一次，把第一次遍历标记的对象都删除掉，就完成了，但是有一个缺点，就是会存在内存碎片</p><blockquote><p>什么是内存碎片？</p><p>内存碎片我是这样理解的，比如我们在堆中的两个不相连的位置中分别有一个1KB大小的对象，然后我们通过标记清理法把他们删除了，那么堆中就挤出来2KB的内存空间了，如果我们这个时候新建一个2KB大小的对象，是无法存放在堆中的，因为上面清理出来的2KB空间不是连续的，所以就会产生内存碎片问题</p></blockquote></li><li><p>标记-整理法：他跟标记清理法原理是差不多的，但是他会在删除对象后，把后面的对象往前推，这样子就解决了内存碎片的问题，但是由于每删一个对象都需要移动一次后面的对象，会导致性能会有所降低，而且这样做的代价太大了。</p></li></ul><ul><li>复制法：复制法会把内存分成两块大小一样的内存，首先把其中一块内存通过GC ROOT标记，再把标记过后存活的对象复制到另一块内存中去，最后把存放垃圾对象的内存清理掉，缺点就是需要双倍的内存，太消耗内存了。</li></ul><p>所以GC综合了上面三个算法，创建了一个分代收集的算法出来</p><p>分代收集算法就是先把内存分为young区跟old区两块，分别代表年轻代和老年代。</p><p>然后再young区那一块内存中，又分为E空间、S0空间、S1空间；</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/hotspot-heap-structure.png" alt="hotspot-heap-structure"></p><p><strong>简单的概括就是：</strong></p><p>大部分情况，对象都会首先在 Eden 区域分配。</p><p>然后在一次GC之后，E空间和S0空间存活的对象会移到S1空间去，再回收E空间和S0空间的垃圾对象</p><p>在下一次GC完成后，E空间和S1空间存活的对象会移到S0空间去，然后回收E空间和S1空间的垃圾对象</p><p>每一次被标记存活的对象，都会有一个类似于age的变量，都会加一，当age&gt;一个阈值时，他会晋升到老年代去。需要注意的是，大对象（需要大量内存的对象，例如集合、数组）会直接存放在老年代</p><blockquote><p>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置），<strong>取这个年龄和 MaxTenuringThreshold 中更小的一个值</strong>，作为新的晋升年龄阈值”</p></blockquote><p><strong>补充：垃圾回收机制中会触发的几种GC方式的区别以及详解</strong></p><blockquote><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p></blockquote><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/rf-hotspot-vm-gc.png" alt="rf-hotspot-vm-gc"></p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="1-你能说一下创建线程的方法有哪些吗"><a href="#1-你能说一下创建线程的方法有哪些吗" class="headerlink" title="1. 你能说一下创建线程的方法有哪些吗"></a>1. 你能说一下创建线程的方法有哪些吗</h3><p>创建线程的方式有四种，分别是</p><ol><li>继承Thread类并重写run方法创建线程，虽然实现简单，但是不可以继承其他类</li><li>实现Runnable接口并重写run方法方法。避免了单继承的局限性，编程更加灵活，很好的实现了解耦合</li><li>实现Callable接口并重写call方法，创建线程，通过该方法可以获取线程执行结果的返回值，并且可以抛出异常。</li><li>通过线程池创建。（使用java.util.concurrent.Executor接口）</li></ol><h3 id="2-Runnable接口和Callable接口的区别"><a href="#2-Runnable接口和Callable接口的区别" class="headerlink" title="2. Runnable接口和Callable接口的区别"></a>2. Runnable接口和Callable接口的区别</h3><p>Runnable接口的run方法没有返回值，Callable接口的call方法有返回值，并且支持泛型</p><p>Runnable接口的run方法只能抛出运行时异常，且其他异常只能在内部处理异常，而Callable接口可以抛出所有的异常，以及在内部处理。</p><h3 id="3-sleep方法和yield方法有什么区别"><a href="#3-sleep方法和yield方法有什么区别" class="headerlink" title="3. sleep方法和yield方法有什么区别"></a>3. sleep方法和yield方法有什么区别</h3><ol><li>sleep方法不会考虑优先级问题，然后优先级低的线程也能拿到CPU资源，而yield方法会考虑优先级的问题，调用该方法只会给同等优先级或高优先级的线程CPU资源</li><li>Sleep方法有声明InterruptedExcetion异常抛出，yield是没有异常抛出的</li><li>sleep方法执行后线程会进入阻塞状态，而yield方法执行后会进入就绪状态</li><li>sleep比yield具有更好的移植性</li></ol><h3 id="4-线程中sleep和wait方法有什么区别"><a href="#4-线程中sleep和wait方法有什么区别" class="headerlink" title="4. 线程中sleep和wait方法有什么区别"></a>4. 线程中sleep和wait方法有什么区别</h3><p>首先sleep()方法是线程类的一个静态方法，调用该方法可以让线程暂停指定的一段时间，暂停的线程会把CPU资源让出来给其他线程使用，但是对象的锁依然保存，所以当暂停时间到后，该线程会自动恢复到就绪状态。而wait方法是Object类一个方法，调用对象的wait方法可以让当前线程放弃对象的锁，即进入暂停状态，然后当前线程会进入到对象的等待池，知道对象调用notice方法时才能唤醒等待池中的线程进入等锁池，如果线程重新获得对象的锁就可以进入到就绪状态。</p><h3 id="5-线程的run方法和start方法有什么区别"><a href="#5-线程的run方法和start方法有什么区别" class="headerlink" title="5. 线程的run方法和start方法有什么区别"></a>5. 线程的run方法和start方法有什么区别</h3><p>调用start()方法可以让启动一个线程，并进入到就绪状态，而调用run()方法只是调用了一个对象的方法，并没有开启新的线程。</p><p>就比如说你在主线程中调用了run()方法，那么你要等run()方法执行完之后才会继续执行下面的代码，而调用了start()方法，会开启一条线程去执行Thread对象中对应的run方法，即使run方法没有执行完，主线程中还会执行start()下面的代码。</p><h3 id="6-线程有哪几种状态？（线程的生命周期）"><a href="#6-线程有哪几种状态？（线程的生命周期）" class="headerlink" title="6. 线程有哪几种状态？（线程的生命周期）"></a>6. 线程有哪几种状态？（线程的生命周期）</h3><p>Java线程在运行的生命周期中的指定时刻只可能处于下面6中不同状态的其中一个状态</p><ul><li><strong>NEW</strong>：线程初始状态，线程被创建出来但没有被调用start()方法的状态</li><li><strong>RUNNABLE</strong>：运行状态，线程被调用了start()等待运行的状态。<code>RUNNABLE</code>状态细分一下会有一个<code>RUNNING</code>状态以及<code>READY</code>状态的</li><li><strong>BLOCKED</strong>：阻塞状态，需要等待锁释放。</li><li><strong>WAITING</strong>：等待状态，调用wait方法后的一个状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）</li><li><strong>TIME_WAITING</strong>：超时等待状态，调用wait方法并且传入了一个时间之后的状态，可以在指定的时间后自行返回而不是想WAITING那样一直等待。</li><li><strong>TERMINATED</strong>：终止状态，表示该线程已经运行完毕</li></ul><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间转换。</p><p><img src="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/640.png" alt="Java-thread-status"></p><h3 id="7-线程相关的基本方法都有哪些"><a href="#7-线程相关的基本方法都有哪些" class="headerlink" title="7. 线程相关的基本方法都有哪些"></a>7. 线程相关的基本方法都有哪些</h3><p>线程相关的基本方法有6种，分别是wait、sleep、notifyAll、notify、join、yield</p><ol><li><p><strong>wait方法（线程等待）：</strong></p><p>线程调用<code>wait</code>方法并且没有传入参数时，会让该线程进入到一个<code>WAITING</code>状态，<strong>并且释放锁资源</strong>，直至被其他线程调用<code>notify</code>或<code>notifyAll</code>方法才会进入就绪状态重新竞争锁资源；如果调用<code>wait</code>方法并传入一个指定的时间，该线程会进入到<code>TIMED_WAITING</code>状态，如果指定超过的时间还没获取到锁资源，该线程就会直接返回到就绪状态，不会一直在等待通知</p></li><li><p><strong>sleep方法（线程睡眠）</strong>：</p><p>sleep方法会导致当前线程休眠，与wait方法不同的是<strong>sleep不会释放锁资源</strong>，然后sleep会导致线程进入TIMED_WAITING状态，当休眠时间过去之后，当前线程会自动唤醒并且继续执行。这个过程中其他线程处于阻塞状态</p></li><li><p><strong>yield方法（线程让步）</strong>：</p><p>yield方法会让当前线程让出CPU时间片（资源），同时让当前线程重新与其他线程竞争CPU时间片，一般来说优先级高的线程会比较容易获得CPU时间片。但不是绝对的，有一些操作系统对线程优先级不敏感。</p></li><li><p><strong>interrupt（线程中断）：</strong></p><p>该方法可以中断一个线程，该方法会将线程中的一个标识符设置为true，表示中断该线程，但是<strong>线程中断之后并不会释放锁资源</strong>，需要结合wait方法的使用才会释放锁资源。这个过程中线程的状态不会发生改变</p></li><li><p><strong>join方法（等待其他线程终止）：</strong></p><p>在当前线程调用另外一个线程的join()方法时，会让<strong>当前线程进入到阻塞状态，直到另一个线程执行结束</strong>，当前线程才会由阻塞状态转换为就绪状态并且重新竞争锁资源。</p></li><li><p><strong>notify方法（线程唤醒）：</strong></p><p>Object类上的notify方法，可以唤醒在此对象监视器上等待的线程（可以理解为在当前锁对象外面等待的资源），如果所有的线程都在这个对象上等待，则会唤醒任意一个线程。</p><p>在调用notify()方法之后，线程并不会立即释放该对象的锁。它会继续执行同步代码块，<strong>直到离开同步代码块或调用wait()方法时才会释放锁</strong>，从而使等待的线程有机会获取锁并执行。</p><p>在使用wait()和notify()方法进行线程间通信时，<strong>需要确保等待线程和唤醒线程都使用相同的对象作为锁</strong>，以避免死锁等问题。</p></li></ol><h3 id="8-wait-和sleep-的区别"><a href="#8-wait-和sleep-的区别" class="headerlink" title="8. wait() 和sleep()的区别"></a>8. wait() 和sleep()的区别</h3><p>wait()方法与sleep()方法的区别主要有一下四点</p><ol><li><p>它们来自不同的类</p><p>wait()来自Object类</p><p>sleep()来自Thread类</p></li><li><p>调用wait方法会释放锁资源，调用sleep方法不会释放锁资源</p></li><li><p>wait方法必须要在同步代码块中使用，sleep方法可以在任何地方使用</p></li><li><p>wait方法不需要捕获异常，sleep方法需要捕获异常</p></li></ol><h3 id="9-Java中常用的线程池有哪些"><a href="#9-Java中常用的线程池有哪些" class="headerlink" title="9. Java中常用的线程池有哪些"></a>9. Java中常用的线程池有哪些</h3><p>常用的线程池主要有6种，分别是：</p><ol><li><strong>newFixedThreadPool：</strong>创建一个定长线程池（核心线程数与最大线程数都为指定参数的线程池），可以控制线程最大并发数，超出的线程会在队列中等待。</li><li><strong>newCacheThreadPool：</strong>创建一个可缓存线程池（核心线程数为0，最大线程数为Integer.MAX_VALUE的线程池），如果线程池的长度超过处理需要，可以灵活的回收空闲线程，若无可回收，则创建新线程。这种方式可能会创建大量的线程，造成OOM。</li><li><strong>newScheduledThreadPool：</strong>创建一个定长的线程池（核心线程数与最大线程数都为指定参数的线程池），支持定时及周期性任务执行。</li><li><strong>newSingleThreadExecutor：</strong>创建一个单线程化的线程池（核心线程数与最大线程数都为1的线程池），它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行</li><li><strong>newSingleScheduledThreadPool：</strong>创建一个单线程化的线程池（核心线程数为1、最大线程数为Integer.MAX_VALUE的线程池），它可安排在给定延迟后运行命令或者定期执行</li><li><strong>newWorkStealingPool</strong>：创建一个带并<strong>行级别的线程池</strong>，并行级别决定了同<strong>一时刻</strong>最多有<strong>多</strong>少个；线程在执行<strong>，如不传并行级别参数，将默认为当前系统的</strong>CPU<strong>核心数</strong>*<strong>2</strong>。该线程池是在JDK1.8才出现的，底层是基于一个工作窃取算法实现的，该算法的核心思想就是让空闲的线程从其他线程的任务队列中“窃取”任务来执行。</li></ol><h3 id="10-Java线程池的核心参数有哪些（创建的时候）"><a href="#10-Java线程池的核心参数有哪些（创建的时候）" class="headerlink" title="10. Java线程池的核心参数有哪些（创建的时候）"></a>10. Java线程池的核心参数有哪些（创建的时候）</h3><blockquote><p>corePoolSize：线程池的核心线程数量</p><p>maxNumPollSiza：线程池中最大的线程数</p><p>KeepAliveTime：当线程数大于核心线程数时，多余的空闲线程存活的最长时间</p><p>unit：时间单位</p><p>WorkQueue：阻塞队列&#x2F;任务队列，用来储存等待执行任务的队列</p><p>threadFartoty：线程工厂，用来创建线程，一般默认即可</p><p>handler：拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</p></blockquote><h3 id="11-线程池的执行流程"><a href="#11-线程池的执行流程" class="headerlink" title="11. 线程池的执行流程"></a>11. 线程池的执行流程</h3><p><img src="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230602143058557.png" alt="image-20230602143058557"></p><ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><h3 id="12-Synchronized底层实现原理"><a href="#12-Synchronized底层实现原理" class="headerlink" title="12. Synchronized底层实现原理"></a>12. Synchronized底层实现原理</h3><p>我们可以结合JVM和字节码来分析一下Synchronized底层实现原理</p><h3 id="13-Synchronized与Volatile的区别"><a href="#13-Synchronized与Volatile的区别" class="headerlink" title="13. Synchronized与Volatile的区别"></a>13. Synchronized与Volatile的区别</h3><p><code>Volatile</code>关键字可以保证变量的可见性。使用Volatile关键修饰的标量其实就是相当于指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><code>Synchronized</code>关键字其实就是我们的同步锁，主要用于解决多个线程之间资源访问的同步性，被它修饰的方法或者代码块在任意时刻只能有一个线程执行。如果使用Synchronized修饰变量的话，就是将变量锁定了，当前线程可以访问该变量，其他线程被阻塞。 </p><p>它们之间的区别主要有以下四点：</p><ul><li><code>Volatile</code>关键字是线程同步的轻量级实现，所以<code>Volatile</code> 性能肯定要比<code>Synchronized</code> 关键字要好。但是<code>Volatile</code> 只能作用于变量，而<code>Synchronized</code> 可以作用在变量、方法、类中</li><li><code>Volatile</code> 关键字可以保证数据的可见性，但不能保证数据的原子性。<code>Synchronized</code> 关键字两者都能保证</li><li><code>Volatile</code> 关键字主要用于解决变量在多个线程之间的可见性，而<code>Synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li></ul><blockquote><p><strong>Volatile除了可以保证标量的可见性之外，还有一个重要的作用就是防止 JVM 的指令重排序。</strong></p><p>如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><p>面试官可能会问：“了解单例模式吗？请你用懒汉双检锁的方式给我写一个单例模式，并且解释一下”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个单例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">// 构造器私有化，保证单例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 提供一个公开的方法，供外界获取单例实例</span></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查，避免单例已经被创建的时候，其他线程都去竞争锁，从而导致阻塞</span></span><br><span class="line">       <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">// 加同步锁锁住类，防止高并发场景下创建多个实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line"><span class="comment">// 第二次检查，确保实例是没有被创建的</span></span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span> )&#123;</span><br><span class="line">                    <span class="comment">// 创建实例</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>uniqueInstance</code> 变量使用了<code>volatile</code> 修饰符声明，是为了防止JVM的指令重排序。比方说我们创建<code>Singleton</code> 实例的那一行代码<code>uniqueInstance = new Singleton();</code>  ，其实在JVM中是分三步完成的</p><ol><li>为<code>Singleton</code> 类的实例对象分配内存空间。</li><li>初始化<code>Singleton</code> 类的实例对象</li><li>将<code>uniqueInstance</code> 变量指向<code>Singleton</code> 类的实例对象所在的内存地址。</li></ol><p>正常来说我们上面的代码执行顺序就是<code>1-&gt;2-&gt;3</code> ，<strong>但是在JVM指令重排序的影响下，执行顺序可能会是<code>1-&gt;3-&gt;2</code></strong> ，这样做可以提高程序的性能，因为<strong>在执行步骤3之前，对象已经被创建，可以被其他线程访问</strong>，而步骤2中的初始化操作不影响对象的可见性和安全性。</p><p>在单线程环境下，这样做并不会产生什么问题，因为最终得到的都是一个初始化过后的实例对象嘛。</p><p>但是在并发环境下，如果线程A的执行顺序是<code>1-&gt;3-&gt;2</code> ，而在3这一步的时候，线程B进来了发现<code>uniqueInstance</code>不为null，这个时候他就会直接返回<code>uniqueInstance</code>，而这个时候线程B得到的<code>uniqueInstance</code>是一个<strong>还未初始化的实例对象</strong></p><h3 id="14-ThreadLocal是什么？"><a href="#14-ThreadLocal是什么？" class="headerlink" title="14. ThreadLocal是什么？"></a>14. ThreadLocal是什么？</h3><p><code>ThreadLocal</code>其实就是线程的一个局部变量。通常情况下，我们创建的变量，在多线程环境下都是共享的。如果我们想要给每个线程都创建一个属于自己的本地变量的话，我们就需要使用JDK中自带的<code>ThreadLocal</code>类了。**<code>ThreadLocal</code>类会为每一个线程创建一个独自的变量副本，这个变量副本在同一个线程内是可以传递的，在不同的线程中是隔离开的。每个线程可以通过ThreadLocal提供的get()、set()方法来获取到副本中的值。**</p><p>其实我们可以这样理解ThreadLocal：比方说有两个人去宝屋收集宝物，如果两个人都共用一个袋子的话，他们是不是有可能会发生争执，那么如果给他们各自分配一个袋子的话，是不是就避免了这个问题。<strong>我们把这两个人比作线程的话，就是他们有可能发生并发问题吧，那么ThreadLocal其实就是上面分发袋子的一个机制，用来避免（不是解决，是避免！）他们发生并发问题的。</strong></p><blockquote><p>ThreadLocal的底层实现原理：</p><p>在Thread类中，有两个<code>ThreadLocal.ThradLocalMap</code> 类型的属性，而<code>ThreadLocalMap</code> 它是<code>ThreadLocal</code> 下的一个静态内部类，它的结构与<code>HashMap</code> 类似，我们可以理解成它是<code>ThradLocal</code> 定制的一个<code>HashMap</code> 。因为它的key其实就是我们的<code>ThreadLocal</code>的一个弱引用，然后<code>value</code>就是我们要存放到线程变量副本中的值，比如我们业务中要传递的登录数据就是这个<code>value</code>了。</p><p>然后当我们需要获取这个<code>value</code>的时候，我们只需要通过调用<code>ThreadLocal</code>中的<code>get()，set()</code>方法即可，因为实际上调用这两个方法时，我们调用的是<code>ThradLocalMap</code>类对应的<code>get()、set()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说<code>ThreadLoca</code>的实现原理就是：</p><p><strong>每个<code>Thread</code>中度具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为key，<code>object</code>为value的键值对，我们要获取或存储变量副本的值，只需要调用<code>ThreadLocal</code> 的<code>get()/set()</code> 方法即可</strong></p></blockquote><h3 id="15-ThreadLocal的内存泄漏是怎么导致的？怎么避免？"><a href="#15-ThreadLocal的内存泄漏是怎么导致的？怎么避免？" class="headerlink" title="15. ThreadLocal的内存泄漏是怎么导致的？怎么避免？"></a>15. ThreadLocal的内存泄漏是怎么导致的？怎么避免？</h3><p>首先，<code>ThradLocal</code>为每个线程提供变量副本是基于<code>ThreadLocalMap</code>  实现的，**<code>ThreadLocalMap</code> 中的key是<code>ThradLocal</code> 的一个弱引用，如果<code>ThradLocal</code> 没有被外部强引用的话，那么就JVM发生GC的时候，key就会被清理掉，而value不会被清理掉。**</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的entry，如果不加以处理的话，<strong>value是不是就永远都不会被GC给清理掉，这个时候就会造成内存泄漏了。</strong></p><blockquote><p><strong>如何避免</strong></p><p><code>ThreadLocalMap</code> 的实现中已经考虑了内存泄漏的问题了，在调用它的<code>get()、set()、remove()</code> 方法的时候，会清理掉key为null的记录。当然，我们在使用完<code>ThreadLocal</code>之后最好还是调用一下<code>remove()</code>方法手动去释放一下比较好。</p></blockquote><h3 id="16-ThreadLocal的应用场景有哪些"><a href="#16-ThreadLocal的应用场景有哪些" class="headerlink" title="16. ThreadLocal的应用场景有哪些"></a>16. ThreadLocal的应用场景有哪些</h3><ul><li><p>应用场景一：</p><p>在我们的业务中，有一些业务是需要获取我们的当前用户的一些信息嘛。然后并发环境下，我们可以在做登录校验的时候，把一些用户相关的信息存放到我们的threadLocal中，那么当前线程的业务中，如果我们想要获取用户相关的信息，直接去threadLocal中取就行了。</p></li><li><p>应用场景二：</p><p>Spring事务管理的实现就有用到<code>ThreadLocal</code> 。</p><p>首先我们Java操作数据库的一个连接技术其实就是jdbc嘛，然后jdbc在操作数据库时，是需要获取数据库连接对象connection的，而我们对数据库的事务的开启、提交、回滚操作都是可以通过connection对象来完成的。</p><p>在Spring中，假设我们使用声明式事务来做事务管理，也就是使用<code>@Transactional</code>注解，我们的业务层的一个方法使用了@Transaction注解开启事务嘛，然后这个业务层方法分别调用了mapper层的两个操作数据库的方法test01，test02。</p><p>然后在我们的事务开启前，我们是需要从数据库连接池中获取一个connection对象的，并且把我们关闭掉事务自动提交。然后这个connection对象会存放到我们的ThreadLocal中。然后再开启事务，当我们执行test01的时候，spring会先从threadlocal中获取connection对象，然后再去执行我们的数据库操作。执行test02时也是同样的一个操作。当两个方法执行完之后，spring会从threadlocal中获取connection对象，并且判断是否发生异常，如果发生了异常就使用connection.rollback回滚，否则使用connection.commit提交事务。</p></li></ul><h3 id="17-Java加锁的方式有哪些"><a href="#17-Java加锁的方式有哪些" class="headerlink" title="17. Java加锁的方式有哪些"></a>17. Java加锁的方式有哪些</h3><p>首先在Java中是有两种类型的锁的，<strong>悲观锁和乐观锁。</strong></p><p><strong>悲观锁</strong></p><p>其中，悲观锁从字面上理解就是它是很悲观的，总是假设最坏的情况；指的就是在并发环境下，<strong>无论如何，对共享资源的访问都一定会发生并发安全问题</strong>，所以在每次获取资源操作的时候都会上锁，其他线程想拿到这个资源就必须去竞争锁。也就是说，<strong>共享资源每次只能让一个线程使用，其他线程都会进入到阻塞状态，直到获得了共享资源的线程释放掉资源，其他线程才会重新去竞争锁。</strong></p><p><strong>悲观锁思想的常见实现有：</strong></p><ul><li>Synchronized关键字实现的同步锁</li><li>Lock接口的实现子类：ReentrantLock可重入锁、ReentrantReadWriteLock可重入读写锁等。</li></ul><p><strong>乐观锁</strong></p><p>乐观锁从字面上理解就是很乐观，总是假设最好的情况。<strong>它认为在并发环境下，每次对共享资源的访问都不会发生并发安全问题，线程可以不停的执行，无需加锁也无需等待。</strong>只有在提交修改的时候去验证对应的资源（数据）是否被其他线程修改了即可（可以通过版本号机制或CAS算法实现）。</p><p>在Java中<code>atomic</code> 包下面有两个原子变量类（比如<code>AtmoicInteger</code>、<code>LongAdder</code>），就是使用了乐观锁中的一种实现方式CAS算法实现的。</p><p><strong>乐观锁思想的常见实现有：</strong></p><ul><li><p>版本号机制</p><blockquote><p>版本号机制指的就是在数据库表中加一个version字段，表示被修改的次数。当我们要执行更新操作时，就要先读取数据嘛，在读取数据时我们把version字段的值也读取，然后在提交更新的时候，只有数据库的当前版本号跟我们读取到版本号的一致时，才会更新成功，否则重试更新操作，直至更新成功</p></blockquote></li><li><p>CAS算法，CAS算法用的比较多</p><blockquote><p>CAS算法其实就是<code>Compare And Swap(比较与交换)</code>，</p></blockquote></li></ul><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="1-网络的7层架构"><a href="#1-网络的7层架构" class="headerlink" title="1. 网络的7层架构"></a>1. 网络的7层架构</h3><blockquote><p>OSI七层模型是什么？每一层的作用是什么？</p></blockquote><p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230603073012982.png" alt="image-20230603073012982"></p><h3 id="2-TCP与UDP的区别"><a href="#2-TCP与UDP的区别" class="headerlink" title="2. TCP与UDP的区别"></a>2. TCP与UDP的区别</h3><ol><li><strong>是否面向连接：</strong>UDP在传送数据之前不需要先建立连接。而TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接</li><li><strong>是否是可靠传输：</strong>远地主机在收到UDP报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP提供可靠的传输服务，TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制等机制。通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达</li><li><strong>是否有状态：</strong>与”是否可靠“相对应，TCP传输是有状态的，这个有状态说的是TCP会去记录自己发送消息的状态，比如消息是否发送了、是否被接收了等等。为此TCP需要维持复杂的连接状态表。而UDP是无状态服务，简单来说就是不管发出去之后的事情了（渣男行为）</li><li><strong>传输效率：</strong>TCP进行传输时多了连接、确认、重传等机制，所以TCP传输效率要比UDP低很多</li><li><strong>传输形式</strong>：TCP是面向字节流的，UDP是面向报文的</li><li><strong>首部开销</strong>：TCP首部开销（20~60字节）比UDP首部开销（8字节）要大</li><li><strong>是否提供广播或多播服务：</strong>TCP只支持点对点通信；UDP支持一对一、一对多、多对一、多对多通信。</li></ol><p>总结起来就是：</p><table><thead><tr><th>条件</th><th>TCP</th><th>TCP</th></tr></thead><tbody><tr><td>是否面向连接</td><td>是</td><td>否</td></tr><tr><td>是否可靠</td><td>是</td><td>否</td></tr><tr><td>是否有状态</td><td>是</td><td>否</td></tr><tr><td>传输效率</td><td>较慢</td><td>较快</td></tr><tr><td>传输形式</td><td>字节流</td><td>数据报文段</td></tr><tr><td>首部开销</td><td>20 ～ 60 bytes</td><td>8 bytes</td></tr><tr><td>是否提供广播或多播服务</td><td>否</td><td>是</td></tr></tbody></table><h3 id="3-TCP与UDP的运用场景"><a href="#3-TCP与UDP的运用场景" class="headerlink" title="3. TCP与UDP的运用场景"></a>3. TCP与UDP的运用场景</h3><ul><li><strong>UDP 一般用于即时通信</strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li><li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li></ul><h3 id="4-TCP的三次握手和四次挥手"><a href="#4-TCP的三次握手和四次挥手" class="headerlink" title="4. TCP的三次握手和四次挥手"></a>4. TCP的三次握手和四次挥手</h3><blockquote><p>这个问题可以衍生出很多经典面试题，详细见下面链接</p><p><a href="https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/network/tcp-connection-and-disconnection">TCP 三次握手和四次挥手（传输层）</a></p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>算法篇详情见</p><ul><li><a href="https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/algorithms/10-classical-sorting-algorithms">十大经典排序算法</a></li></ul></blockquote><h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><h3 id="1-Get和Post的区别？"><a href="#1-Get和Post的区别？" class="headerlink" title="1. Get和Post的区别？"></a>1. Get和Post的区别？</h3><p>Get和Post都是前后端交互的请求方式，它们之前的区别有以下四点</p><ol><li>Get是不安全的，因为在传输过程，数据被放在请求的URL中；而Post的请求数据是放在请求体中的，也就是对用户来说都是不可见的，所以Post是安全的</li><li>Get传送的数据量较小，一般传输数据大小在1k-18k之间（根据浏览器不同，限制不一样，但相差不大，主要是因为受URL长度限制）而Post传输的数据量较大，一般被默认为不受限制</li><li>Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集</li><li>Get请求效率比Post方法好。Get是form表单提交的默认方法。</li></ol><h3 id="2-HTTP中重定向和请求转发的区别？"><a href="#2-HTTP中重定向和请求转发的区别？" class="headerlink" title="2. HTTP中重定向和请求转发的区别？"></a>2. HTTP中重定向和请求转发的区别？</h3><p>它们之间的区别主要有以下四点：</p><ol><li>重定向会发送两次请求，请求转发发送一次请求</li><li>重定向地址栏会变，请求转发地址栏不变</li><li>重定向是浏览器跳转的，请求转发是服务器跳转</li><li>重定向可以跳转到任意网址，请求转发只能跳转当前项目的</li></ol><blockquote><p>两者的实现也不同</p><ul><li><p>请求转发：用request的getRequestDispatcher()方法得到RequestDispatcher对象，在调用他的forward()方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">&quot;other.jsp&quot;</span>).forword(request,response);</span><br></pre></td></tr></table></figure></li><li><p>重定向：调用response的sendRedirect()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;other.jsp&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="3-Jsp和Servlet的区别"><a href="#3-Jsp和Servlet的区别" class="headerlink" title="3. Jsp和Servlet的区别"></a>3. Jsp和Servlet的区别</h3><p><strong>相同点</strong></p><ul><li>jsp经编译后就变成了servlet，jsp本质就是servlet，jvm只能识别java的类，不能识别jsp代码，web容器将jsp的代码编译成jvm能够识别的java类。</li><li>其实就是当你通过 http 请求一个 JSP 页面时，首先 Tomcat 会将JSP翻译并编译成为 Servlet，然后执行 Servlet的生命周期方法处理请求与响应。</li></ul><p><strong>不同点</strong></p><ul><li><p>JSP侧重视图展现数据，Sevlet主要用于控制逻辑获取数据。</p></li><li><p>Servlet中没有内置对象 。</p></li><li><p>JSP中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</p></li></ul><h3 id="4-cookie和session的区别？"><a href="#4-cookie和session的区别？" class="headerlink" title="4. cookie和session的区别？"></a>4. cookie和session的区别？</h3><ol><li><p>存储位置不同</p><p>cookie的数据信息存放在客户端浏览器上。</p><p>session的数据信息存放在服务器上。</p></li><li><p>存储容量不同</p><p>单个cookie保存的数据&lt;&#x3D;4KB，一个站点一般保存20~50个Cookie（不同浏览器不一样，Sarafi和Chrome对每个域的Cookie数目没有严格限制）</p><p>对于session来说并没有数据上限，但出于对服务器端性能考虑，session内不要存放过多的东西，并且设置session删除机制（或者采用缓存技术代替session）</p></li><li><p>存储方式不同</p><p>cookie只能保存ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</p><p>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</p></li><li><p>隐私策略不同</p><p>cookie对客户端是可见的，容易被分析本地cookie并且进行cookie欺骗，所以不安全。</p><p>session存储在服务器上，不存在敏感信息泄露的风险。</p></li><li><p>有效期上不同</p><p>开发者可以通过设置cookie的属性，达到是cookie长期有效的效果。</p><p>session依赖于名为<code>JSESSIONID</code>的cookie，而且设置了过期时间默认为-1，只需要关闭窗口该session就会失效，因而session不能达到长期有效的效果</p></li><li><p>服务器压力不同</p><p>cookie存储在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</p><p>session是保管在服务端的，每个用户都会产生一个session。加入并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</p></li></ol><h3 id="5-什么是Ajax，Ajax有什么优点"><a href="#5-什么是Ajax，Ajax有什么优点" class="headerlink" title="5. 什么是Ajax，Ajax有什么优点"></a>5. 什么是Ajax，Ajax有什么优点</h3><p>Ajax全称为”Asynchronous JavaScript And XML”（异步 JavaScript 和 XML），是指一种创建交互方式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更快更新部分网页的技术。</p><p>优点：</p><ul><li>通过异步模式，可以提升用户的体验</li><li>优化了浏览器和服务器之前的传输，减少了不必要的数据往返，减少了带宽占用。</li></ul><h3 id="5-JavaWeb的三大组件"><a href="#5-JavaWeb的三大组件" class="headerlink" title="5. JavaWeb的三大组件"></a>5. JavaWeb的三大组件</h3><ul><li>Servlet：用于处理请求与响应</li><li>Filter：用于拦截请求与响应</li><li>Lisenter：用于监听三大域对象request、session、servletContext的创建与销毁，和域中数据发生变化的时候会调用监听器实现逻辑控制。</li></ul><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="1-IOC、DI、AOP"><a href="#1-IOC、DI、AOP" class="headerlink" title="1. IOC、DI、AOP"></a>1. IOC、DI、AOP</h3><p>IOC和AOP是Spring的两大核心。</p><ul><li><p><strong>IOC(Inversion of Control)：</strong>IOC其实是一种设计思想，是指我们在创建对象的时候，将对象的控制权交给Spring容器来管理。在这之前，我们创建对象的主动权和时机都是由自己去决定的，而现在这种全力转移到Spring容器中，并由容器根据配置文件或者注解去创建实例和管理各个实例之间的依赖关系了，这样做可以在一定程度上降低对象与对象之间的耦合性，同时也提高了功能的复用<strong>（创建对象的解耦）。</strong></p><blockquote><p>比如：在没有IOC之前，我们业务层bookService要调用dao层的实现方法bookDaoImplA时，我们只需要new一个bookDaoImplA的实例对象即可。但是在某一天我们收到一个需求，要将bookDaoImpA的实现换成bookDaoImplB了，我们就要去修改bookService中的对应的实现，牵一发而动全身，每次修改都有可能要修改大量的代码，这样的设计耦合性太高了，所以才有IOC的出现。</p></blockquote></li><li><p><strong>DI：</strong>DI其实就是IOC的一种实现方式，即应用程序在运行时依赖IOC容器来动态的注入外部资源<strong>（赋值或使用对象的解耦）。</strong></p></li><li><p><strong>AOP(Aspect Oriented Programming)：</strong>AOP指的是面向切面编程，在开发中，会有一些与业务无关但每个业务的需要的逻辑方法，例如日志记录、事务控制、异常处理等。在AOP中，我们可以将这个逻辑代码分别抽取并封装成不同的模块，这些模块在AOP中也被称为“切面”。这样做可以减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring 的AOP是基于动态代理和cglib代理模式的，如果要代理的对象是一个接口，我们就可以通过JDK动态代理来给该对象创建一个代理对象。而如果我们要代理的对象是一个类，我们就要使用cglib代理来创建代理对象了。</p></li></ul><h3 id="2-Spring框架中用到了哪些设计模式？"><a href="#2-Spring框架中用到了哪些设计模式？" class="headerlink" title="2. Spring框架中用到了哪些设计模式？"></a>2. Spring框架中用到了哪些设计模式？</h3><p><strong>工厂设计模式：</strong>Spring使用工厂模式通过<code>BeanFactory</code>、<code>ApplicationContext</code> 创建Bean对象</p><p><strong>代理设计模式：</strong>Spring Aop功能就是基于代理模式实现的，如果要代理的对象实现了某个接口，Spring 会使用JDK动态代理来创建代理对象；对于没有实现接口的对象，Spring会使用cglib代理生成一个被代理对象的子类；</p><blockquote><p><strong>因为JDK动态代理创建代理对象时，是基于实现<code>$Proxy</code>类来创建的</strong></p></blockquote><p><strong>单例设计模式：</strong>Spring中的Bean默认都是单列的。Spring在底层是通过<code>ConcurrentHashMap</code> 实现单例注册表的特殊方式来实现单例模式的。</p><p><strong>模板方法设计模式：</strong> 所谓模板方法设计模式就是将一些通用的代码抽取抽来，作为一个模板，然后提供一些通用的方法给外界使用。就比如说<code>jdncTemplate</code> 、<code>RedisTemplate</code> 等以Template结尾的类，都是用到了模板方法设计模式的。</p><p><strong>包装器设计模式：</strong> </p><p><strong>观察者模式：</strong> Spring事件驱动模型就是观察者模式很经典的一个应用。</p><p><strong>适配器模式：</strong>大家都知道SpringAOP是基于动态代理实现的，但是SpringAOP中的增强是使用到了适配器模式的；</p><p>所谓适配器模式，指的是将一个类或接口转换成我们希望的的另外一个接口，适配器模式通俗点来说就是用来做兼容的，就好比如说我们生活中大家都有可能用到的一拖三充电线其实就是适配器模式的一种体现。</p><p>而SpringAOP中，BeforeAdvice、AfterAdvice、ThrowAdvice三种类型的通知都是基于适配器模式实现的。</p><blockquote><p>因为上述的几个类型的通知，</p></blockquote><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="1-MyISAM和InnoDB有什么区别"><a href="#1-MyISAM和InnoDB有什么区别" class="headerlink" title="1. MyISAM和InnoDB有什么区别?"></a>1. MyISAM和InnoDB有什么区别?</h3><p>在MySQL5.5之前，MyISAM是MySQl的默认存储引擎。虽然MyISAM的性能还行，各种特性也还不错(比如全文所以、压缩、空间函数等)。但是，由于MyISAM不支持事务以及行级锁，并且最大的缺陷就是崩溃后无法安全恢复。InnoDB正好解决了这些问题。</p><p>所以MySQL5.5之后，InnoDB是MySQL的默认存储引擎</p><p>两者的区别主要有七点</p><ol><li><p>是否支持行级锁</p><p>MyISAM只支持表级锁，而InnoDB支持表级锁以及行级锁，默认是行级锁。</p><p>也就说，MyISAM一锁就会锁住了整张表，而InnoDB可以根据具体的场景选择锁整张表还是锁住一行，这也是InnoDB在并发写时厉害之处。</p></li><li><p>是否支持事务</p><p>MyISAM不提供事务支持。</p><p>InnoDB提供事务支持，实现了SQL标准定义的四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。InnoDB默认使用的是<code>REPEATABLE-READ</code>（可重复读）的隔离级别，而InnoDB基于MVCC(多版本并发控制)控制和Next-Key Lock解决了幻读问题</p><blockquote><p>Next-Key Lock</p><p>Next-Key Lock是行级锁的基本单位，它是记录锁(Record Lock)和间隙锁(Gap Lock)的结合体。</p></blockquote></li><li><p>是否支持外键</p><p>MyISAM不支持外键，而InnoDB支持外键</p><p>虽然外键对于维护数据的一致性非常有帮助，但是对性能有一定的损耗的。</p><p>一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p></li><li><p>是否支持数据库异常崩溃后的安全恢复</p><p>MyISAM不支持，而InnoDB支持。</p><p>使用InnoDB的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。而这个恢复的过程是依赖于<code>redo log</code>。</p></li><li><p>是否支持MVCC</p><p>MyISAM不支持，而InnoDB支持。</p><p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p></li><li><p>索引的实现不一样</p><p>虽然MyISAM引擎和InnoDB引擎都是使用B+Tree作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB引擎中，其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的。</p></li><li><p>性能有差别。</p><p>InnoDB的性能比MyISAM更强大，不管是在读写混合模式下还是只读模式下，随着CPU核数的增加，InnoDB的读写能力呈线性增长。MyISAM因为读写不能并发，它的处理能力跟核数没有关系。</p></li></ol><p><strong>总结：</strong></p><ul><li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li><li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li><li>MyISAM 不支持外键，而 InnoDB 支持。</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>InnoDB 的性能比 MyISAM 更强大。</li></ul><h3 id="2-你知道ACID吗（事务的特性）"><a href="#2-你知道ACID吗（事务的特性）" class="headerlink" title="2. 你知道ACID吗（事务的特性）"></a>2. 你知道ACID吗（事务的特性）</h3><p>ACID是事务的四个特性，分别是：原子性、一致性、隔离性、持久性。</p><ul><li><strong>原子性(Atomicity)：</strong>事务值最小的执行单位，不允许分割。事务的原子性确保动作要么全部被执行，要么全部不起作用。</li><li><strong>一致性(Consistency)：</strong>事务实行前后，数据要保持一致。比如说在转账业务中，无论事务成功与否，转账者和收款人的总额是不变的。</li><li><strong>隔离性 (Isolation)：</strong>在并发访问数据库时，会产生多个事务，在这个过程中，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库时独立的。</li><li><strong>持久性(Durability)：</strong>一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库产生故障也不应该对其有任何影响</li></ul><blockquote><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p></blockquote><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ol><li><strong>读未提交（read Uncommited）：</strong>最低的隔离界别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、或不可重复度</li><li><strong>读已提交（READ-COMMITTED）：</strong>大多数数据库的默认隔离级别，该隔离级别允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复度仍有可能发生。</li><li><strong>可重复读（REPEATABLE-READ）：</strong>指的是对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复度，但幻读仍有可能发生，因为幻读是发生在DQL中的。这个隔离级别是MySQL默认的隔离级别，<strong>而MySQL在使用InnoDB数据库引擎后利用了MVCC（多版本并发控制机制）以及Next-Key lock 锁解决了幻读的问题。</strong></li><li><strong>可串行化（SERIALIZABLE）：</strong>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。虽然该隔离级别可以防止脏读、不可重复读以及幻读，但是需要付出的代价太高了，因为他是在每个读的数据行上加锁的，可能会导致大量的超时现象和锁竞争，一般为了提升程序的吞吐量不会采用这个；</li></ol><h3 id="3-脏读、幻读、不可重复读"><a href="#3-脏读、幻读、不可重复读" class="headerlink" title="3. 脏读、幻读、不可重复读"></a>3. 脏读、幻读、不可重复读</h3><ul><li><p><strong>脏读（Dirty read）</strong></p><p>当一个事务读取数据并且对数据进行了修改时，这个修改对其他事务来说是可见的，即使当前事务还没有提交。这时，如果另外一个事务读取了这个还未提交的数据，并且第一个事务突然回滚，导致数据并没有被提交到数据库，那么第二个事务读取到的就是一个脏数据了，这也是脏读的由来</p><blockquote><p>例如：事务1读取某表中的数据A &#x3D; 20， 然后事务1修改A &#x3D;A-1，也就是19。在这个时候，事务2也读取这张表的数据A ，并且读取到的数据是A &#x3D; 19，如果此时事务1突然回滚了，也就是A修改的数据没有被提交到数据库，即A &#x3D; 20，但是事务2读取到的还是19，这就是脏读。</p></blockquote></li><li><p><strong>不可重复读（Unrepeatable read）</strong></p><p>在一个事务内读取同一个数据时，如果在这个事务还没结束的时候，有另外一个事务也访问了这个数据，那么在第一个事务的两次读取这个数据之间，由于第二个事务对数据的修改，会导致第一个事务两次读取到的数据可能不太一样。这就发生了一个事务内连续读取到的数据不一样的情况，因此称为不可重复读。</p><blockquote><p>例如：事务1读取了某表的数据A &#x3D; 20，在事务1还没结束的时候，事务2也读取了这个数据A &#x3D; 20，同时对A进行了修改 A &#x3D; 19，并且提交了事务2。而这时如果事务1再次读取数据A，读取到的数据会为A &#x3D; 19，也就是说两次读取的数据都是不一样的。</p></blockquote></li><li><p><strong>幻读（Phantom read）</strong></p><p>幻读其实可以看作不可重复读的一种。它发生在一个事务读取了几行数据，接着另外一个并发事务插入了一些数据时。在随后的查询中，第一个失误就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称之为幻读。</p><blockquote><p>例如：事务2想要统计某张表的一个数据，就比如说一开始的count(*) &#x3D; 20嘛，然后这个时候事务1在这张表中插入了新的数据，那么这个时候事务2再次统计的count(*)&#x3D;21了，也就是说他啥也不知道，就读到多一行数据了</p></blockquote></li></ul><h3 id="4-连接查询"><a href="#4-连接查询" class="headerlink" title="4. 连接查询"></a>4. 连接查询</h3><p>在MySQL中，连接查询可以分为内连接和外连接。</p><p>内连接：内连接有隐式内连接和显示内连接两种</p><ul><li>隐式内连接：隐式内连接其实就是指我们连接查询时在from后面用逗号分隔两张变的连接查询</li><li>显示内连接：显示内连接指的就是我们是用inner join…on进行表连接的一个操作</li></ul><p>外连接：有左外连接和右外连接两种</p><ul><li>左外连接指的就是我们在连接查询时，以左表为基准去连接我们的另外一张表，然后他们的连接后的结果集就是左表的全部内容加上左表与右表的一个交集。连接的关键字为<code>left join...on</code></li><li>右外连接指的就是我们在连接查询时，以右表为基准去连接我们的另外一张表，然后他们的连接后的结果集就是右表的全部内容加上左表与右表的一个交集。连接的关键字为<code>right join...on</code></li></ul><h3 id="5-聚合函数"><a href="#5-聚合函数" class="headerlink" title="5. 聚合函数"></a>5. 聚合函数</h3><p>SQL中提供聚合函数有五种：</p><ol><li>COUNT：统计行数量</li><li>SUM：获取某个列的合计值</li><li>AVG：计算某个列的平均值</li><li>MAX：计算列的最大值</li><li>MIN：计算列的最小值</li></ol><h3 id="6-SQL关键字以及执行顺序"><a href="#6-SQL关键字以及执行顺序" class="headerlink" title="6. SQL关键字以及执行顺序"></a>6. SQL关键字以及执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">... </span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">...<span class="built_in">avg</span>()<span class="operator">/</span><span class="built_in">sum</span>()</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">...</span><br><span class="line">SELETE</span><br><span class="line">...</span><br><span class="line"><span class="keyword">distinct</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">...</span><br><span class="line">limit</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="7-有了解过MySQL的索引嘛"><a href="#7-有了解过MySQL的索引嘛" class="headerlink" title="7. 有了解过MySQL的索引嘛?"></a>7. 有了解过MySQL的索引嘛?</h3><p>MySQL中的索引主要有单列索引、组合索引、空间索引三种。用的比较多的是单列索引和组合索引，空间索引我这边目前还没有用过</p><p><strong>单列索引：</strong> 在MySQL表中的某一个列上创建的索引叫做单列索引。单列索引还分为：普通索引、唯一索引、主键索引、全文索引四种。</p><ul><li>普通索引：是MySQL基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹是为了提升查询效率。</li><li>唯一索引：唯一索引的索引列必须的值必须是唯一的，但是允许有控制</li><li>主键索引：主键索引其实就跟我们主键的特性类似嘛，需要确保索引列中的值时唯一的且不能为null</li><li>全文索引：全文索引比较特殊，只有在MyISAM引擎、InnoDB上才能使用，并且只能在CHAR、VARCHAR、TEXT类型的字段上才能使用。</li></ul><p><strong>组合索引：</strong> 组合索引又叫联合索引，指的是将多个字段联合起来去创建索引。</p><ul><li><p>组合索引的使用，需要遵循左前缀原则</p></li><li><p>一般情况下，建议使用组合索引代替单列索引（主键索引除外）</p><blockquote><p>因为我们业务中的大部分查询都是涉及到多个字段的，组合索引比较于单列索引来说磁盘的IO操作和排序操作更少了，从而提高了查询效率</p></blockquote></li></ul><p>在设计数据库表时，如果经常需要在多个列上进行组合查询，那么使用组合索引可以显著提升查询效率。比如在订单表中，每次查询都要查询订单的状态和下单时间，那么我们就可以在这两个字段上添加一个组合索引，以提高查询效率。</p><h3 id="8-什么是左前缀原则"><a href="#8-什么是左前缀原则" class="headerlink" title="8. 什么是左前缀原则"></a>8. 什么是左前缀原则</h3><p>在MySQL建议联合索引时会遵循左前缀原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，组合索引的第一个字段必须出现在查询语句中，这个索引才会被用到；</p><p>例如：<code>create index index_age_name_sex on tb_user(age, name, sex)</code> ;</p><p>上述SQL语句中，对<code>age、name、sex</code> 建立了一个组合索引<code>index_age_name_sex</code> ，实际上这个联合索引相当于<code>(age)、(age，name)、(age, name, sex)</code> 三个索引。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/moon-4919501_1920.jpg&quot; alt=&quot;moon&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;以下是我对Java高频面试题的一个总结，后面我会持续更新，希望对你有所帮助。&lt;br&gt;当然，如果有哪道题目我理解错误了，或者是你有更好的见解，非常欢迎你在评论区中留下宝贵的意见！&lt;/p&gt;</summary>
    
    
    
    <category term="Java面试题" scheme="https://minster.top/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://minster.top/tags/Java/"/>
    
    <category term="interview" scheme="https://minster.top/tags/interview/"/>
    
    <category term="持续更新" scheme="https://minster.top/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程编程中的等待和休眠：wait() 和 sleep() 方法解析</title>
    <link href="https://minster.top/2022/05/27/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E4%BC%91%E7%9C%A0%EF%BC%9Await-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <id>https://minster.top/2022/05/27/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E4%BC%91%E7%9C%A0%EF%BC%9Await-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/</id>
    <published>2022-05-27T00:49:12.000Z</published>
    <updated>2023-08-16T00:37:33.323Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/640.png" alt="640"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在Java多线程中，线程的状态如上图所示（图来自<a href="https://javaguide.cn/">JavaGuide</a>），可以发现，当前线程调用<code>wait(long time)</code>方法或者执行<code>Thread.sleep(long time)</code>方法都会进入到一个<code>TIMED_WAITING</code>的状态。那么，这个状态下的线程的锁资源是怎么样的呢？</p><span id="more"></span><h2 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h2><p>在多线程环境下，如果当前线程调用了wait()方法，那么该方法会进入到<code>WAITING</code>状态，并释放它所持有的锁，等待其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法来唤醒它。如果没有其唤醒操作，当前线程会处于一个无限等待的状态。</p><p>如果当前线程在调用的是<code>wait(long time)</code>方法时，线程会进入到一个<code>TIMED_WAITING</code>状态，同时会释放锁资源，等待其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法来唤醒它，或者等待指定的时间过期后自动唤醒。在等待期间，该线程不会占用 CPU 资源，因此其他线程可以执行。</p><p>代码演示：</p><p><strong>WaitingThread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WaitingThread</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;获取到了锁资源&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待2秒钟，释放锁资源</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() +<span class="string">&quot;线程等待2s.....释放锁&quot;</span>);</span><br><span class="line">                lock.wait(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 等待时间过去，唤醒，尝试重新获取锁资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>WaitingTest类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">WaitingThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitingThread</span>(lock);</span><br><span class="line">        <span class="type">WaitingThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitingThread</span>(lock);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230527102116952.png" alt="image-20230527102116952"></p><p>上述代码中，我们创建了两个线程，并将它们传递给同一个锁对象。在<code>run()</code>方法中，线程首先使用<code>synchronized</code>关键字获取锁对象，然后调用<code>wait(long time)</code>方法进入<code>TIMED_WAITING</code>状态，等待2秒钟后会自动唤醒，此时，锁对象已经被释放，线程需要重新获取锁才能继续执行。可以看到，在线程重新获取锁之后，它就可以继续执行对共享数据的操作了。</p><h2 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h2><p>当线程调用<code>sleep(long time)</code>方法时，该线程也会进入到<code>TIMED_WAITING</code>状态，但是当前线程对象并不会释放锁资源，因此其他线程对象也无法获取到锁资源，会进入阻塞状态。</p><p>当指定的休眠时间过期之后，当前线程会主动唤醒，并且该线程仍然持有锁资源，可以继续执行。</p><p>代码演示：</p><p><strong>SleepingThread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SleepingThread</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;获取到了锁资源&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() +<span class="string">&quot;线程休眠2s.....仍持有锁&quot;</span>);</span><br><span class="line">                <span class="comment">// 线程休眠2秒钟，进入TIMED_WAITING状态</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 休眠时间过去，自动唤醒，继续执行&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SleepingTest类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepingTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">SleepingThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepingThread</span>(lock);</span><br><span class="line">        <span class="type">SleepingThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepingThread</span>(lock);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230527105237869.png" alt="image-20230527105237869"></p><p>在上面的代码中，我们创建了两个线程，并将它们传递给同一个锁对象。在线程的run()方法中，我们首先使用synchronized关键字来获取锁对象，然后让线程进入TIMED_WAITING状态。在这里，线程会休眠2秒钟，然后再输出一条消息。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当线程调用<code>wait()</code>方法时，线程会进入一个<code>WAITING</code>状态，并且释放锁资源，直至被唤醒才会进入到就绪状态，竞争锁资源。</p><p>当线程调用<code>wait(long time)</code>方法时（指定一个等待时间），线程会进入到一个<code>TIMED_WAITING</code>状态，同时释放锁资源，只有当线程被通知或者等待时间结束后才会重新去获取锁资源。</p><p>当线程调用的是<code>sleep(long time)</code>方法，线程虽然也会进入到一个<code>TIMED_WAITING</code>状态，但是不会释放锁资源，其他线程会处于阻塞状态直至当前线程释放锁资源</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/640.png&quot; alt=&quot;640&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在Java多线程中，线程的状态如上图所示（图来自&lt;a href=&quot;https://javaguide.cn/&quot;&gt;JavaGuide&lt;/a&gt;），可以发现，当前线程调用&lt;code&gt;wait(long time)&lt;/code&gt;方法或者执行&lt;code&gt;Thread.sleep(long time)&lt;/code&gt;方法都会进入到一个&lt;code&gt;TIMED_WAITING&lt;/code&gt;的状态。那么，这个状态下的线程的锁资源是怎么样的呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Java多线程" scheme="https://minster.top/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://minster.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Thread" scheme="https://minster.top/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot如何实现基于注解配置</title>
    <link href="https://minster.top/2022/05/26/Spring-Boot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE/"/>
    <id>https://minster.top/2022/05/26/Spring-Boot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE/</id>
    <published>2022-05-26T11:46:12.000Z</published>
    <updated>2023-08-16T00:37:25.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在使用Spring注册Bean时，有很多方式，其中两种常用的配置方式如下</p><p><strong>基于注解的配置</strong>：使用注解来定义 bean，如  <code>@Component</code> 、 <code>@Autowired</code> 、 <code>@Configuration</code>  等。这种方式相比于基于 XML 的配置更加简洁、易于阅读和维护，也是目前比较流行的一种方式。</p><p><strong>基于 Java 配置类的配置</strong>：使用 Java 类来定义 bean 和它们之间的依赖关系，如  <code>@Bean</code> 、 <code>@Configuration</code> 、 <code>@Import</code>  等。这种方式也是基于注解的配置方式的一种扩展形式，它允许我们使用 Java 代码来定义 bean，从而更加灵活地控制应用程序的配置。 </p><p><strong>不难发现，上述两种配置方式的核心都是基于注解实现的，只是应用场景不同。</strong></p><p>而我在使用基于Java配置类的配置时，发现在Spring中需要直接或间接实现<code>AnnotationConfigRegistry</code>接口时才能应用基于注解的配置方式；于是我便开始思考：Spring Boot是怎么实现的呢？通过查阅资料以及源码后，以下是我的拙见。</p><span id="more"></span><h2 id="Spring使用注解-Java配置类-配置Bean"><a href="#Spring使用注解-Java配置类-配置Bean" class="headerlink" title="Spring使用注解(Java配置类)配置Bean"></a>Spring使用注解(Java配置类)配置Bean</h2><p>在Spring中，我们若想简单使用基于注解的配置方式，需要完成以下几步：</p><ol><li><p>创建SpringConfig配置类作为传递参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;org.heng.dao&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring创建容器时或根据该配置类上的注解信息来配置和创建引用程序上下文中的Bean。这样做可以省去XML配置的繁琐过程。</p><p><strong>JdbcConfig</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc:mysql://localhost:3306//spring_db&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;123456&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(BookDao BookDao)</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Application启动类上使用<code>AnnotationConfigApplicationContext</code>类来创建容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> context.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中我们将SpringConfig配置类作为参数传入到<code>AnnotationConfigApplicationContext</code>类中，该类会根据接收到的参数来创建容器</p></li><li><p>通过上述代码，我们如果有其他Java配置类，只需要在配置类中写好配置信息后在SpringConfig类中的<code>@Import</code>注解上导入即可，不需要在XML中配置了。</p></li></ol><h2 id="Spring-Boot为什么可以使用基于注解的配置方式？"><a href="#Spring-Boot为什么可以使用基于注解的配置方式？" class="headerlink" title="Spring Boot为什么可以使用基于注解的配置方式？"></a>Spring Boot为什么可以使用基于注解的配置方式？</h2><p>在完成上述的Spring使用基于注解的配置方式完成配置之后，我在想SpringBoot是如何实现的呢，于是乎我去查看了一下SpringBoot的源码</p><p>在启动类中，我进入到SpringBootApplication类中，发现它没有继承任何类，于是我找到run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我本来以为un()方法中返回的<code>ConfigurableApplicationContext</code>会直接或者间接实现<code>AnnotationConfigRegistry</code>接口的，从而实现Spring Boot基于注解的配置的。于是我查看<code>ConfigurableApplicationContext</code>的类图，发现其并没有直接或间接实现上述的接口。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520162648142.png" alt="image-20230520162648142"></p><p>然后我继续查阅源码，找到了创建创建Spring应用上下文的方法<code>createApplicationContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title function_">createApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.applicationContextFactory.create(<span class="built_in">this</span>.webApplicationType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看不出来什么端倪，于是乎我看到方法上面的注释</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520163608571.png" alt="image-20230520163608571"></p><p>这段注释的大概内容为</p><blockquote><p>这个方法使用了一个策略模式，它会根据应用程序上下文工厂（ApplicationContextFactory）来创建应用程序上下文。如果应用程序上下文工厂被设置了，它会使用这个工厂来创建应用程序上下文；否则，它会使用适当的默认实现来创建应用程序上下文。</p></blockquote><p>然后注释底部链接跳转了一个方法<code>setApplicationContextFactory</code>，我们继续追踪源码，查看该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContextFactory</span><span class="params">(ApplicationContextFactory applicationContextFactory)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.applicationContextFactory = (applicationContextFactory != <span class="literal">null</span>) ? applicationContextFactory</span><br><span class="line">         : ApplicationContextFactory.DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现<code>setApplicationContextFactory</code>方法是用来设置<strong>ApplicationContextFactory</strong>的，查看该方法的注释</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520164231835.png" alt="image-20230520164231835"></p><p>我们可以发现我们在创建Spring应用程序上下文时，如果设置了ApplicationContextFactory，则根据设置的Factory来创建Spring应用程序上下文。如果没有设置，根据应用程序的类型自动选择创建相应的ApplicationContext实现类，其中包括</p><ul><li><p><strong>对于基于Servlet的Web应用程序</strong></p><p>创建<code>AnnotationConfigServletWebServerApplicationContext</code>实例。</p></li><li><p><strong>对于基于Reactive的Web应用程序</strong></p><p>创建<code>AnnotationConfigReactiveWebServerApplicationContext</code>实例。</p></li><li><p><strong>对于非Web应用程序</strong></p><p>创建<code>AnnotationConfigApplicationContext</code>实例。</p></li></ul><p>而上述三个实现类，都实现了<code>AnnotationConfigRegistry</code>接口！所以，Spring Boot可以使用基于注解的配置方式的原因就在这里！</p><h3 id="在开发中怎么设置ApplicationContextFactory"><a href="#在开发中怎么设置ApplicationContextFactory" class="headerlink" title="在开发中怎么设置ApplicationContextFactory"></a>在开发中怎么设置ApplicationContextFactory</h3><p>在Spring Boot应用程序中，可以通过继承SpringApplication类并重写其createApplicationContextFactory方法，来自定义应用程序上下文的创建过程，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">SpringApplication</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ApplicationContextFactory <span class="title function_">createApplicationContextFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> <span class="title class_">MyWebApplicationContext</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<strong>MyApplication类继承了SpringApplication类</strong>，并重写了其<strong>createApplicationContextFactory</strong>方法，返回一个lambda表达式，该表达式返回一个自定义的ApplicationContext实现类MyWebApplicationContext的实例。通过这种方式，可以在Spring Boot应用程序中自定义应用程序上下文的创建过程，满足不同的应用场景需求。</p><h2 id="AnnotationConfigRegistry接口的作用和意义（补充）"><a href="#AnnotationConfigRegistry接口的作用和意义（补充）" class="headerlink" title="AnnotationConfigRegistry接口的作用和意义（补充）"></a>AnnotationConfigRegistry接口的作用和意义（补充）</h2><p><code>AnnotationConfigRegistry</code>  接口是 Spring Framework 中的一个接口，它继承了  <code>BeanDefinitionRegistry</code>  接口，并增加了一些注册的方法。主要作用是用于注册基于注解的配置类（如  <code>@Configuration</code>  注解的类）。   </p><p>该接口的意义在于为开发者提供了一种便捷的方式，用于将基于注解的配置类注册到 Spring 容器中。在使用基于注解的配置时，开发者需要将其所在的类注册到 Spring 容器中，通常是通过  <code>AnnotationConfigApplicationContext</code>  或者其他类似的上下文来实现。而这些上下文都实现了  <code>AnnotationConfigRegistry</code>  接口，因此可以调用该接口中的方法来实现注册。  </p><p> <code>AnnotationConfigRegistry</code>  接口中的方法有：</p><ul><li><p><code>register(Class&lt;?&gt;... annotatedClasses)</code> ：注册一个或多个基于注解的配置类。 </p></li><li><p><code>scan(String... basePackages)</code> ：扫描指定的包（及其子包）下的所有 Bean 定义，并将其加入到 Spring 容器中。</p></li></ul><p>通过使用  <code>AnnotationConfigRegistry</code>  接口，开发者可以更加灵活地管理基于注解的配置类，并将其注册为 Spring Bean，从而实现更加方便、简单、快捷的配置方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Spring Boot启动时，它会通过SpringApplication类的createApplicationContext方法来创建Spring应用程序上下文。如果设置了ApplicationContextFactory，它将使用该工厂来创建Spring应用程序上下文，否则将根据应用程序的类型自动选择创建相应的ApplicationContext实现类。</p><p>Spring Boot基于注解的配置方式的实现原理是基于ApplicationContextFactory接口和AnnotationConfigRegistry接口结合实现的。ApplicationContextFactory接口用于创建Spring应用程序上下文的工厂，而AnnotationConfigRegistry接口则是用于注册基于注解的配置类的接口。这两者的结合使得Spring Boot能够使用基于注解的配置方式，从而简化了应用程序的配置过程。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们在使用Spring注册Bean时，有很多方式，其中两种常用的配置方式如下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于注解的配置&lt;/strong&gt;：使用注解来定义 bean，如  &lt;code&gt;@Component&lt;/code&gt; 、 &lt;code&gt;@Autowired&lt;/code&gt; 、 &lt;code&gt;@Configuration&lt;/code&gt;  等。这种方式相比于基于 XML 的配置更加简洁、易于阅读和维护，也是目前比较流行的一种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于 Java 配置类的配置&lt;/strong&gt;：使用 Java 类来定义 bean 和它们之间的依赖关系，如  &lt;code&gt;@Bean&lt;/code&gt; 、 &lt;code&gt;@Configuration&lt;/code&gt; 、 &lt;code&gt;@Import&lt;/code&gt;  等。这种方式也是基于注解的配置方式的一种扩展形式，它允许我们使用 Java 代码来定义 bean，从而更加灵活地控制应用程序的配置。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不难发现，上述两种配置方式的核心都是基于注解实现的，只是应用场景不同。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而我在使用基于Java配置类的配置时，发现在Spring中需要直接或间接实现&lt;code&gt;AnnotationConfigRegistry&lt;/code&gt;接口时才能应用基于注解的配置方式；于是我便开始思考：Spring Boot是怎么实现的呢？通过查阅资料以及源码后，以下是我的拙见。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="https://minster.top/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="https://minster.top/tags/Spring-Boot/"/>
    
    <category term="底层原理" scheme="https://minster.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>懒汉式单例模式下的双检锁机制的理解</title>
    <link href="https://minster.top/2022/05/26/%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%8F%8C%E6%A3%80%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://minster.top/2022/05/26/%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%8F%8C%E6%A3%80%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2022-05-26T11:39:13.000Z</published>
    <updated>2023-08-16T00:37:46.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在学习懒汉式单例模式时，发现了懒汉双检锁的实现方式，当时不是很理解，查阅资料后得出以下结论</p><span id="more"></span><h2 id="双检锁机制"><a href="#双检锁机制" class="headerlink" title="双检锁机制"></a>双检锁机制</h2><p>在多个线程同时请求一个获取一个懒汉式单例对象时，可能会导致创建多个对象的问题，为了确保只有一个对象被创建，可以使用双检锁机制。（双检锁机制不是创建两个锁实现，而是再方法内部实现两种检锁）</p><p>双检锁机制基于懒汉模式，在第一次获取单例对象时才创建它；</p><p>为了提高程序的性能，我们不在方法前使用syschronized关键字，而是在方法内部使用，同时也在方法内部实现了双重检查锁定机制。</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//第一重检锁</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//第二重检锁，只有uniqueInstance为null时才会生效</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在双检锁机制中，我们使用了synchronized关键字来创建一个锁，确保只有一个线程能进入if语句块内部。在此之前，我们首先检查uniqueInstance变量是否为null。如果为null我们才进入if语句块，获取锁，并再次检查uniqueInstance变量是否为null。这是因为在多线程环境下，可能会有多个线程同时进入第一个if语句块，如果不在此检查uniqueInstance变量是否为null，就有可能会创建多个Singleton对象，违反了单例模式的原则。</p><p>一旦我们进入了if语句块，获取了锁，就可以创建唯一的Singleton对象。其他线程尝试进入if语句块时，由于uniqueInstance变量已经不为null，所以它们不会执行if语句块内的代码，而是直接返回uniqueInstance变量的值。</p><p>在整个过程中，synchronized关键字可以确保只有一个线程能够访问if一句话内的代码，在这之前和之后，uniqueInstance变量由于是用volatile关键字进行了修饰，可以被确保它在多线程环境下的可见性，从而避免了问题的发生。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>除了单例模式之外，它还可以用于其他需要保证线程安全的场景。例如，我们可以使用双检锁机制来确保在多线程环境下只创建一个实例化某个对象的方法。<br>双检锁机制在多线程环境下会有比较好的性能表现，因为它只在第一次创建对象时使用synchronized关键字来获取锁，在之后的访问中不需要获取锁，因此避免了不必要的开销。如果在多线程环境下需要频繁创建对象，使用双检锁机制会比使用简单的synchronized关键字更加高效。<br>需要注意的是，虽然双检锁机制可以确保在多线程环境下只创建一个对象，但是如果对象的初始化操作耗时较长，可能会造成性能问题。此外，还需要注意正确使用volatile关键字，确保变量的可见性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，双检锁机制是一种比较常见的保证线程安全的方式，可以用于单例模式等需要确保只有一个对象被创建的场景。在使用双检锁机制时，需要注意并发情况下的安全性和性能问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我在学习懒汉式单例模式时，发现了懒汉双检锁的实现方式，当时不是很理解，查阅资料后得出以下结论&lt;/p&gt;</summary>
    
    
    
    <category term="Design Patterns" scheme="https://minster.top/categories/Design-Patterns/"/>
    
    
    <category term="Singleton Pattern" scheme="https://minster.top/tags/Singleton-Pattern/"/>
    
    <category term="Lazy Singleton" scheme="https://minster.top/tags/Lazy-Singleton/"/>
    
    <category term="Design Patterns" scheme="https://minster.top/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>My First Blog</title>
    <link href="https://minster.top/2022/05/26/My-First-Blog/"/>
    <id>https://minster.top/2022/05/26/My-First-Blog/</id>
    <published>2022-05-26T09:08:15.000Z</published>
    <updated>2023-08-16T00:37:28.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我一直都想搭建一个用于记录生活和学习的博客，但是碍于懒惰，一直拖延到现在。直到昨天我在浏览Github的开源项目时，看到很多大神的博客，所以我也决定重新搭建一个博客来记录自己在工作中遇到的问题以及自己学习技术的一个理解等。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我是一名Java菜鸟程序员，我在学习Java的时候一直有使用MarkDown去记录笔记。而我在之前也搭建一个基于<a href="https://minster77.github.io/">Hugo的博客</a>，上面的文章都是一些学习笔记，比较合适于初学Java的朋友们。</p><h2 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h2><p>在这个博客中，我将主要分享关于Java技术的一些知识和个人理解，也会分享一些编程技巧和异常排查。</p><p>同时我也会分享一些个人的学习方法和年度总结，希望通过这个博客能够为大家提供有价值的信息和帮助，输出一些有意义的内容！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我搭建这个博客的初衷是为了记录一下自己的程序员生涯的故事，毕竟来都来了，怎么也得留下些什么吧！其次是希望能有大神能在这个过程中指出我的错误，能让我学习到更多！</p><p>在最后，祝你好运，也祝我好运！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我一直都想搭建一个用于记录生活和学习的博客，但是碍于懒惰，一直拖延到现在。直到昨天我在浏览Github的开源项目时，看到很多大神的博客，所以我也决定重新搭建一个博客来记录自己在工作中遇到的问题以及自己学习技术的一个理解等。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://minster.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="LifeNode" scheme="https://minster.top/tags/LifeNode/"/>
    
  </entry>
  
  <entry>
    <title>Map集合的用法及源码解析</title>
    <link href="https://minster.top/2022/04/24/JavaCollections_03/"/>
    <id>https://minster.top/2022/04/24/JavaCollections_03/</id>
    <published>2022-04-24T00:49:12.000Z</published>
    <updated>2023-09-04T12:33:31.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java集合类-三"><a href="#Java集合类-三" class="headerlink" title="Java集合类(三)"></a>Java集合类(三)</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章内容为Java集合中的Map集合的常见用法和源码解析~</p><span id="more"></span><hr><ol><li>Map接口实现类的特点和常用方法</li><li>Map接口的六大遍历方式</li><li>Map小结及HashMap底层源码分析</li><li>Hashtable基本介绍</li></ol><hr><h3 id="Map接口实现类的特点和常用方法"><a href="#Map接口实现类的特点和常用方法" class="headerlink" title="Map接口实现类的特点和常用方法"></a>Map接口实现类的特点和常用方法</h3><h4 id="Map接口的特点"><a href="#Map接口的特点" class="headerlink" title="Map接口的特点"></a>Map接口的特点</h4><p>注意：这里讲的是Jdk8的Map接口特点</p><ul><li><p>Map与Collection并列存在。用于保存具有映射关系的数据：key-value</p></li><li><p>Map中的key和value可以是任何引用类型的数据，会封装到HashMao$Node对象中</p></li><li><p>Map中的key不允许重复，原因和HashSet一样</p></li><li><p>Map中的value可以重复</p></li><li><p>Map的key可以为null，value也可以为null，但是key为null的结点只能有一个，value为null的结点可以有多个</p></li><li><p>常用String类作为Map的key</p></li><li><p>key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</p><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Map_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key不可以重复，重复的会被等价替换</span></span><br><span class="line">        <span class="comment">//value可以重复</span></span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;成志恒&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">        map.put(<span class="string">&quot;no2&quot;</span>,<span class="string">&quot;张无忌&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;张三丰&quot;</span>);<span class="comment">//当有相同的key，就等于等价替换</span></span><br><span class="line">        map.put(<span class="string">&quot;no3&quot;</span>,<span class="string">&quot;成志恒&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">        <span class="comment">//key只能有一个null</span></span><br><span class="line">        map.put(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>,<span class="string">&quot;abc&quot;</span>);<span class="comment">//等价替换</span></span><br><span class="line">        <span class="comment">//value可以多个为null</span></span><br><span class="line">        map.put(<span class="string">&quot;no4&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no5&quot;</span>,<span class="literal">null</span>);<span class="comment">//value可以多个为null</span></span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过get方法，传入key，会返回对应的value</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;no3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;map = &quot;</span> + map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202307801.png" alt="image-20230903202307801"></p></li></ul><p><strong>Map接口k-v详解</strong></p><ul><li><p>Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的。因为Node实现了Entry接口，所以有些书上也说一对k-v就是一个Entry。</p></li><li><p>k-v 数据最后是存放在HashMap$Node node &#x3D; newNode(hash,key,value,null) 这个对象里面的。</p></li><li><p>k-v 为了方便程序员的遍历，还会创建EntrySet集合，该集合存放的元素的类型是Entry。而一个Entry对象本身就具有key，value值。所以有EntrySet&lt;Entry&lt;K,V&gt;&gt;，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure></li><li><p>EntrySet中，定义的类型是Map.Entry，但是实际上存放的还是HashMap$Node。原因如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; </span><br></pre></td></tr></table></figure></li><li><p>由于Map.Entry提供了两个重要的方法：K getKey(); V getValue() ，所以当我们把HashMap$Node对象存放到EntrySet就可以方便我们的遍历。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202314025.png" alt="image-20230903202314025"></p><p>程序演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;成志恒&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">        map.put(<span class="string">&quot;no2&quot;</span>,<span class="string">&quot;张无忌&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Object obj:set) &#123;</span><br><span class="line">            <span class="comment">//向下转型</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry)obj;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;-&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Map = &quot;</span> + map);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202320236.png" alt="image-20230903202320236"></p><p>keySet()：与Node封装到EntrySet集合一样，不过他是封装到Set集合，利用该方法可以单独遍历Key值</p><p>values：与Node封装到EntrySet集合一样，不过他是封装到Collection集合，利用该方法可以单独遍历Value值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">set1</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">System.out.println(set1);</span><br><span class="line"></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">System.out.println(values);</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202325337.png" alt="image-20230903202325337"></p></li></ul><h4 id="Map接口的常用方法"><a href="#Map接口的常用方法" class="headerlink" title="Map接口的常用方法"></a>Map接口的常用方法</h4><ol><li><p>put()：添加元素</p></li><li><p>remove()：根据键删除映射关系</p></li><li><p>get()：根据键获取值</p></li><li><p>size()：获取元素的个数</p></li><li><p>isEmpty()：判断元素个数是否为0</p></li><li><p>clear()：清除集合键值对</p></li><li><p>containsKey()：查找键是否存在</p><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//        1. put()：添加元素</span></span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;小王子&quot;</span>,<span class="number">100</span>));</span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;成志恒&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no2&quot;</span>,<span class="string">&quot;史森明&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no3&quot;</span>,<span class="string">&quot;李元浩&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no4&quot;</span>,<span class="string">&quot;李元浩&quot;</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>,<span class="string">&quot;小虎&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no5&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;map = &quot;</span> + map);</span><br><span class="line"><span class="comment">//        2. remove()：根据键删除映射关系</span></span><br><span class="line">        map.remove(<span class="string">&quot;no3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;map = &quot;</span> + map);</span><br><span class="line"><span class="comment">//        3. get()：根据键获取值</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;no1&quot;</span>));</span><br><span class="line"><span class="comment">//        4. size()：获取元素的个数</span></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line"><span class="comment">//        5. isEmpty()：判断元素个数是否为0</span></span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line"><span class="comment">//        6. clear()：清除集合键值对</span></span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line"><span class="comment">//        7. containsKey()：查找键是否存在</span></span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;小王子&quot;</span>,<span class="number">100</span>));</span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;no1&quot;</span>));</span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;no5&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202332540.png" alt="image-20230903202332540"></p></li></ol><h3 id="Map接口的六大遍历方式"><a href="#Map接口的六大遍历方式" class="headerlink" title="Map接口的六大遍历方式"></a>Map接口的六大遍历方式</h3><ul><li><p>遍历以下Map接口的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;成志恒&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no2&quot;</span>,<span class="string">&quot;史森明&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no3&quot;</span>,<span class="string">&quot;李元浩&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no4&quot;</span>,<span class="string">&quot;李元浩&quot;</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>,<span class="string">&quot;小虎&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no5&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>使用keySet()+增强for遍历k-v</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=====第一种遍历方式=====&quot;</span>);</span><br><span class="line"><span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object key : keySet) &#123;</span><br><span class="line">    System.out.println(key+<span class="string">&quot;=&quot;</span>+map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202338785.png" alt="image-20230903202338785"></p></li><li><p>使用keySet()+迭代器遍历k-v</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=====第二种遍历方式=====&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">    System.out.println(next+<span class="string">&quot;=&quot;</span>+map.get(next));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202344106.png" alt="image-20230903202344106"></p></li><li><p>使用values()+增强for遍历value（因为value不能映射key，所以只能遍历value）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=====第三种遍历方式=====&quot;</span>);</span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202349163.png" alt="image-20230903202349163"></p></li><li><p>使用values()+迭代器遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=====第四种遍历方式=====&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator1.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202355067.png" alt="image-20230903202355067"></p></li><li><p>使用EntrySet()+增强for遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=====第五种遍历方式=====&quot;</span>);</span><br><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object obj : entrySet) &#123;</span><br><span class="line">    <span class="comment">//将obj转成Map.Entry</span></span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry)obj;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;-&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202400634.png" alt="image-20230903202400634"></p></li><li><p>使用EntrySet()+迭代器遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=====第六种遍历方式=====&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator2.next();</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry)next;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;-&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202404812.png" alt="image-20230903202404812"></p></li></ol><h4 id="HashMap练习题"><a href="#HashMap练习题" class="headerlink" title="HashMap练习题"></a>HashMap练习题</h4><ul><li><p>使用HashMap添加三个元素对象，要求：</p><ul><li>键：员工ID，值：员工对象</li><li>遍历显示工资&gt;18000的员工（遍历方法两种）</li><li>员工类：姓名、工资、员工id</li></ul><p>员工类Staff代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Staff</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> wages;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Staff</span><span class="params">(String name, <span class="type">double</span> wages, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.wages = wages;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWages</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWages</span><span class="params">(<span class="type">double</span> wages)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wages = wages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Staff&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, wages=&quot;</span> + wages +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类MapExercise代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapExercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;01&quot;</span>,<span class="keyword">new</span> <span class="title class_">Staff</span>(<span class="string">&quot;成志恒&quot;</span>,<span class="number">19000</span>,<span class="number">01</span>));</span><br><span class="line">        map.put(<span class="string">&quot;02&quot;</span>,<span class="keyword">new</span> <span class="title class_">Staff</span>(<span class="string">&quot;史森明&quot;</span>,<span class="number">20000</span>,<span class="number">02</span>));</span><br><span class="line">        map.put(<span class="string">&quot;03&quot;</span>,<span class="keyword">new</span> <span class="title class_">Staff</span>(<span class="string">&quot;小虎&quot;</span>,<span class="number">17000</span>,<span class="number">03</span>));</span><br><span class="line">        map.put(<span class="string">&quot;04&quot;</span>,<span class="keyword">new</span> <span class="title class_">Staff</span>(<span class="string">&quot;李元浩&quot;</span>,<span class="number">18000</span>,<span class="number">04</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===第一种方式===&quot;</span>);</span><br><span class="line">        <span class="comment">//使用entrySet方法返回映射中包含的映射的 Set 视图</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">        <span class="comment">//利用增强for循环遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : entrySet) &#123;</span><br><span class="line">            <span class="comment">//向下转型，为了能调用父类的方法</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry)o;</span><br><span class="line">            <span class="comment">//把value对象指向从entry集中取出来的value</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="comment">//向下转型，这样可以使用Staff对象的getWages方法。</span></span><br><span class="line">            <span class="type">Staff</span> <span class="variable">staff</span> <span class="operator">=</span> (Staff) value;</span><br><span class="line">            <span class="keyword">if</span>(staff.getWages()&gt;<span class="number">18000</span>)&#123;</span><br><span class="line">                System.out.println(staff.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===第二种方式===&quot;</span>);</span><br><span class="line">        <span class="comment">//使用keySet()方法返回封装到Map封装到Set里面的结点的Key值</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">        <span class="comment">//创建迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//获取迭代器中的数据</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            <span class="comment">//向下转型，吧staff对象指向从map里面取到的value对象。</span></span><br><span class="line">            <span class="type">Staff</span> <span class="variable">staff1</span> <span class="operator">=</span> (Staff) map.get(next);</span><br><span class="line">            <span class="keyword">if</span> (staff1.getWages()&gt;<span class="number">18000</span>)&#123;</span><br><span class="line">               System.out.println(staff1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202413552.png" alt="image-20230903202413552"></p><p>上述题目中，数据的封装情况如下图</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202418564.png" alt="image-20230903202418564"></p><p>所以当我们需要取出value值时，我们需要先通过EntrySet取出Entry，然后通过Entry的指向取到HashSet$Node的值。</p></li></ul><h3 id="Map小结及HashMap底层源码分析"><a href="#Map小结及HashMap底层源码分析" class="headerlink" title="Map小结及HashMap底层源码分析"></a>Map小结及HashMap底层源码分析</h3><h4 id="Map小结"><a href="#Map小结" class="headerlink" title="Map小结"></a>Map小结</h4><ol><li><p>Map接口的常用实现类：HashMap、Hashtable和Properties</p></li><li><p>HashMap是Map接口使用频率最高的实现类</p></li><li><p>HashMap是以key-value对的方式来存储数据的</p></li><li><p>key不能重复，但是value可以重复，允许使用null键（只能有一个）和null值（可以多个）</p></li><li><p>如果添加相同的可以，则会覆盖原来的key-value，等同于修改。（key不会替换，value会替换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//此处e指向替换前的Node，所以 e.value = value;即可完成替换</span></span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。</p></li><li><p>HashMap没有实现同步，因此线程是不安全的。方法没有做同步互斥的操作，没有synchronize</p></li></ol><h4 id="HashMap底层机制及源码剖析"><a href="#HashMap底层机制及源码剖析" class="headerlink" title="HashMap底层机制及源码剖析"></a>HashMap底层机制及源码剖析</h4><ul><li><p>HashMap底层机制示意图</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202425448.png" alt="image-20230903202425448"></p><p>（key，value）是一个Node实现了Map$Entry&lt;K,V&gt;</p></li><li><p>HashMap的扩容机制[和<a href="https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%BA%8C/#hashset%E5%BA%95%E5%B1%82%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">HashSet扩容机制</a>相同]</p><ul><li>HashMap底层维护了Node类型的数组table，默认为null</li><li>当创建对象时，将加载因子(loadfactor)初始化为0.75</li><li>当添加key-value是，通过<strong>key</strong>的hash值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换<strong>value</strong>；<strong>如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。</strong></li><li>第一次添加时，会将需要扩容的table容量扩容到16，临界值(threshold)为12</li><li>如果需要再次扩容，会将需要扩容的table容量扩容到原来的2倍（32），临界值为原来的2倍（24） 依次类推。</li><li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），<strong>否则任然采用数组扩容机制</strong></li></ul><p><strong>源码分析</strong></p><p>创建MapSource类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;成志恒&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">        map.put(<span class="string">&quot;no2&quot;</span>,<span class="string">&quot;张无忌&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;张无忌&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试程序，执行HashMap的无参构造器，&#x3D;。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将负载因子(loadFactor)初始化并且创建一个空的table。</p><p>向HashMap集合添加元素，执行put方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过hash方法计算key的Hash值，然后返回给putVal方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行putVal方法，程序首先判断table是否为null，如果为null就table的容量扩容到16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">n = (tab = resize()).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现扩容的方法为risize()方法。</p><p>继续调试，程序会判断当前hash值对应的table索引位置上是否已经存在值，如果不存在值，就把当前Hash值的结点赋值进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后modCount++（记录修改的次数），size++（记录已添加元素的个数）；</p><p>倘若当前hash值对应的table索引位置上已存在值，首先会判断<strong>当前索引位置上的hash值</strong>是否与需要添加的key值对应的hash值相同且满足以下两个条件之一：</p><ul><li>准备添加的key值与p指向的Node结点的key是同一个对象</li><li>p指向的Node结点的key的equals()和准备假如的key比较后相同。</li></ul><p>如果上述条件皆成立，直接让e指向p（p为当前索引位置上的结点）,e为辅助变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">    ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">    e = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后继续执行，把需要添加的key值对应的value值替换掉原先存在的key值的value值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回修改后的value值。</p><p>倘若上述条件不成立，程序会继续进行判断，判断需要添加的结点是否为树结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是树结点，会执行putTreeVal()方法，把需要添加的树节点添加到红黑树上。</p><p>如果不是树节点，程序会继续调试，进入到下一个else。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此处程序会进入一个死循环，直至找到对应索引位置上的尾结点或者找到key相同的结点才会退出。详细见<a href="https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%BA%8C/#hashset%E5%BA%95%E5%B1%82%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">HashSet底层添加元素源码分析</a>的最后一步。</p></li></ul><h4 id="模拟HashMap触发扩容、树化情况，并debug验证"><a href="#模拟HashMap触发扩容、树化情况，并debug验证" class="headerlink" title="模拟HashMap触发扩容、树化情况，并debug验证"></a>模拟HashMap触发扩容、树化情况，并debug验证</h4><ul><li><p>创建测试类MapSource01</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapSource01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">          map.put(<span class="keyword">new</span> <span class="title class_">A</span>(i),<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建A类，重写HashCode方法，让他们有统一的Hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\nA&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行调试，直至添加到第9个元素，因为达到树化的条件（一条链表的元素个数到达8个），但table的大小&lt;MIN_TREEIFY_CAPACITY(默认是64)，所以table会扩容。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202438888.png" alt="image-20230903202438888"></p><p>继续调试，table再次扩容，直至table扩容到容量为64时，该链表会发生树化</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202443604.png" alt="image-20230903202443604"></p></li></ul><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><h4 id="Hashtable的基本介绍"><a href="#Hashtable的基本介绍" class="headerlink" title="Hashtable的基本介绍"></a>Hashtable的基本介绍</h4><ul><li><p>Hashtable存放的元素时键值对：即K-V</p></li><li><p>Hashtable的键和值都不能为null，否则会抛出NullPointerException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Hashtable使用方法基本上和HashMap一样</p></li><li><p>Hashtable是线程安全的（synchronize），HashMap是线程不安全的</p></li></ul><p><strong>Hashtable底层的简单剖析</strong></p><ul><li><p>底层有数组 Hashtable$Entry[]，初始化大小为11</p></li><li><p>临界值 threshold &#x3D; 8 （11*0.75）</p><p>创建HashtableSource类调试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashtableSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"></span><br><span class="line">        hashtable.put(<span class="string">&quot;john&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;jack&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;mary&quot;</span>,<span class="number">200</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;tom&quot;</span>,<span class="number">300</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;smith&quot;</span>,<span class="number">500</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;minster&quot;</span>,<span class="number">600</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;chris&quot;</span>,<span class="number">200</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;ssm&quot;</span>,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hashtable = &quot;</span> + hashtable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试程序，我们可以发现</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202449965.png" alt="image-20230903202449965"></p></li><li><p>Hashtable按照自己的扩容机制进行扩容</p><p>继续调试HashtableSource，执行put方法，可以发现该接口添加元素时执行了addEntry方法把添加的K-V封装到Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">//当增加的元素数量大于或等于临界值时，执行rehash方法进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行rehash方法进行扩容。下面截取部分rehash源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//进行扩容</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指向扩容后的Entry</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[newCapacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，当容量达到临界值时，rehash方法会通过 **int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;*<em>这条语句进行扩容。所以hashtable第一次扩容后的容量为23（11</em>2+1）；</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202457113.png" alt="image-20230903202457113"></p></li></ul><h4 id="HashMap与Hashtable对比"><a href="#HashMap与Hashtable对比" class="headerlink" title="HashMap与Hashtable对比"></a>HashMap与Hashtable对比</h4><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202502018.png" alt="image-20230903202502018"></p><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ul><li><p>Properties类继承于Hashtable类并实现了Map接口，也是使用一种键值对的形式来保存数据</p></li><li><p>他的使用特点和Hashtable类似</p></li><li><p>Properties还可以用了从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</p></li><li><p>xxx.properties文件通常作为配置文件，详解见<a href="https://www.cnblogs.com/xudong-bupt/p/3758136.html">Java读取properties配置文件</a></p><p>Properties的简单使用</p><p>Properties_类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Properties 继承了Hashtable</span></span><br><span class="line">        <span class="comment">//Properties 也是通过k-v存储数据，当然key与value都不能为null</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        properties.put(<span class="string">&quot;jack&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;john&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;properties = &quot;</span>+properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除元素</span></span><br><span class="line">        properties.remove(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;properties = &quot;</span>+properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改元素</span></span><br><span class="line">        properties.put(<span class="string">&quot;jack&quot;</span>,<span class="number">3</span>);<span class="comment">//替换</span></span><br><span class="line">        System.out.println(<span class="string">&quot;properties = &quot;</span>+properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找元素</span></span><br><span class="line">        System.out.println(properties.get(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202509619.png" alt="image-20230903202509619"></p><p>需要注意的是，使用getPeoperties时，当put进去的值不是String类型的时候，会返回null</p><p>例如在Properties类中添加以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">properties.put(<span class="string">&quot;jack&quot;</span>,<span class="number">1</span>);</span><br><span class="line">System.out.println(properties.getProperty(<span class="string">&quot;jack&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202515034.png" alt="image-20230903202515034"></p><p>阅读getProperty源码，我们可以发现其中原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">//把oval指向key对应的value</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">oval</span> <span class="operator">=</span> <span class="built_in">super</span>.get(key);</span><br><span class="line">    <span class="comment">//使用三目运算符，当oval是String类型时，返回强转为String类型的oval，否则为null</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sval</span> <span class="operator">=</span> (oval <span class="keyword">instanceof</span> String) ? (String)oval : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//当sval为null，且设定了defaults的值时，返回defaultsValue，否则返回sval</span></span><br><span class="line">    <span class="keyword">return</span> ((sval == <span class="literal">null</span>) &amp;&amp; (defaults != <span class="literal">null</span>)) ? defaults.getProperty(key) : sval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java集合类-三&quot;&gt;&lt;a href=&quot;#Java集合类-三&quot; class=&quot;headerlink&quot; title=&quot;Java集合类(三)&quot;&gt;&lt;/a&gt;Java集合类(三)&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本章内容为Java集合中的Map集合的常见用法和源码解析~&lt;/p&gt;</summary>
    
    
    
    <category term="Map" scheme="https://minster.top/categories/Map/"/>
    
    
    <category term="Java" scheme="https://minster.top/tags/Java/"/>
    
    <category term="Map" scheme="https://minster.top/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>集合总结</title>
    <link href="https://minster.top/2022/04/24/JavaCollections_04/"/>
    <id>https://minster.top/2022/04/24/JavaCollections_04/</id>
    <published>2022-04-24T00:49:12.000Z</published>
    <updated>2023-09-04T12:29:21.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java集合类-四"><a href="#Java集合类-四" class="headerlink" title="Java集合类(四)"></a>Java集合类(四)</h2><hr><ol><li>开发中如何选择集合实现类</li><li>TreeSet底层源码剖析</li><li>TreeMap底层源码剖析</li><li>Collections工具类</li><li>集合章节练习题</li></ol><hr><h3 id="开发中如何选择集合实现类"><a href="#开发中如何选择集合实现类" class="headerlink" title="开发中如何选择集合实现类"></a>开发中如何选择集合实现类</h3><ul><li>在开发中，选择什么集合实现类，主要取决于<strong>业务操作特点</strong>，然后根据集合实现类特性进行选择，分析如下：</li></ul><ol><li>先判断存储的类型（一组对象[单列]或一组键值对[双列]）</li><li>一组对象[单列]：Collection接口<ul><li>允许重复：List<ul><li>增删多：LinkedLike（底层维护了一个双向链表）</li><li>改查多：ArrayList（底层维护了Object类型的可变数组）</li></ul></li><li>不允许重复：Set<ul><li>无序：HashSet（底层是HashMap，维护了一个哈希表【数组+链表+红黑树】）</li><li>排序：TreeSet</li><li>插入和取出顺序一致：LinkeHashSet（底层是LinkedHashMap），维护了数组+双向链表</li></ul></li></ul></li><li>一对键值对：Map<ul><li>键无序：HashMap（底层是哈希表，jdk7：数组+链表，jdk8：数组+链表+红黑树）</li><li>键排序：TreeMap</li><li>键插入和取出顺序一致：LinkedHashMap（底层是HashMap）</li><li>读取文件：Properties</li></ul></li></ol><h3 id="TreeSet底层源码剖析"><a href="#TreeSet底层源码剖析" class="headerlink" title="TreeSet底层源码剖析"></a>TreeSet底层源码剖析</h3><ul><li><p>TreeSet的底层就是TreeMap</p><ul><li>key不允许重复。</li></ul></li><li><p>TreeSet可以实现有序排序，但是当我们使用其无参构造器时，仍然是无序的。要使用TreeSet提供的一个构造器，传入一个比较器（匿名内部类）才能实现排序</p><p>下面使用TreeSet对数据进行排序（按字符串长度比较）</p><p>创建测试类TreeSet_</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="comment">//按字符串长度进行比较</span></span><br><span class="line">                <span class="keyword">return</span> ((String)o1).length() - ((String)o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        treeSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;ha&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;xiaohu&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;treeSet = &quot;</span> +treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>debug调试，我们可以看到TreeSet此时使用的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，该构造器把我们的一个比较器（匿名内部类）对象传到了TreeSet的底层TreeMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且把比较器对象赋给了TreeMap的属性comparator。</p><p>在调用treeSet.add(“tom”);时，在底层会执行put的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下走，可以发现程序执行以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cmp;</span><br><span class="line">Entry&lt;K,V&gt; parent;</span><br><span class="line"><span class="comment">// split comparator and comparable paths</span></span><br><span class="line"><span class="comment">//cpr为我们传进去的匿名内部类</span></span><br><span class="line">Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        <span class="comment">//动态绑定到我们的匿名内部类对象，且调用了其compare方法。</span></span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果两个元素比较后相等，即返回0，这个key就不能加入进去</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的treeSet集合如下</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202546547.png" alt="image-20230903202546547"></p><p>运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202554294.png" alt="image-20230903202554294"></p><p>需要注意的是，排序规则可以自己定义，按照需求来定义。</p></li></ul><h3 id="TreeMap底层源码剖析"><a href="#TreeMap底层源码剖析" class="headerlink" title="TreeMap底层源码剖析"></a>TreeMap底层源码剖析</h3><ul><li><p>TreeMap机制与TreeSet大体一致，但TreeMap是键值对方式存储数据</p></li><li><p>TreeMap底层实现的是Entry数组</p><p>创建TreeMap_测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用有参构造，重写比较器</span></span><br><span class="line">        <span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="comment">//按照字符串长度进行比较</span></span><br><span class="line">                <span class="keyword">return</span> ((String)o1).length()-((String)o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;杰克&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;xiaohu&quot;</span>,<span class="string">&quot;小虎&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;mary&quot;</span>,<span class="string">&quot;玛丽&quot;</span>);<span class="comment">//替换杰克</span></span><br><span class="line">        System.out.println(<span class="string">&quot;treeMap = &quot;</span>+ treeMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试程序，执行put方法，首次添加时会进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; t = root;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">    compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">    root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为此时只有一个元素，不能进行比较，所以就直接添加到Entry里面了</p><p>继续添加元素，程序执行以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cmp;</span><br><span class="line">Entry&lt;K,V&gt; parent;</span><br><span class="line"><span class="comment">// split comparator and comparable paths</span></span><br><span class="line">Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会调动到比较器进行比较，与TreeSet不同的是当key值比较结果相同时，程序会把新增的key的value值替换掉原来的key的value值。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202600859.png" alt="image-20230903202600859"></p><p>需要注意的是，key不能为null</p></li></ul><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><ul><li><p>Collections是一个操作Set、List和Map等集合的工具类</p></li><li><p>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</p></li><li><p>排序操作（均为static方法）</p><ol><li>reverse(List)：反转List中元素的顺序</li><li>shuffle(List)：对List集合元素进行随机排序</li><li>sort(List)：根据元素的自然顺序对指定List集合元素按升序排序</li><li>sort(List,Comparator)：根据指定的Comparator产生的顺序对List元素进行排序</li><li>swap(List,int,int)：将指定List集合中的i处元素和j处元素进行交换</li></ol><p>代码演示</p><p>创建Collections01测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.collections_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span>+list);</span><br><span class="line"><span class="comment">//        1. reverse(List)：反转List中元素的顺序</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;将list反转后&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span>+list);</span><br><span class="line"><span class="comment">//        2. shuffle(List)：对List集合元素进行随机排序</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;将list元素进行随机排序后&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span>+list);</span><br><span class="line"><span class="comment">//        3. sort(List)：根据元素的自然顺序对指定List集合元素按升序排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;自然排序后&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span>+list);</span><br><span class="line"><span class="comment">//        4. sort(List,Comparator)：根据指定的Comparator产生的顺序对List元素进行排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="comment">//按字符串长度排序</span></span><br><span class="line">                <span class="comment">//可以加入一些校验代码，提高严谨性</span></span><br><span class="line">                <span class="keyword">return</span> ((String)o1).length()-((String)o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;按字符串长度排序后&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span>+list);</span><br><span class="line"><span class="comment">//        5. swap(List,int,int)：将指定List集合中的i处元素和j处元素进行交换</span></span><br><span class="line">        Collections.swap(list,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;将下标为1的元素与下标为3的元素互换&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202607869.png" alt="image-20230903202607869"></p></li><li><p>查找、替换</p><ol><li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</li><li>Object max(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最大元素</li><li>Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素</li><li>Object min(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最小元素</li><li>int frequency(Collection,Object)：返回指定集合中指定元素的出现次数</li><li>void copy(List dest,List src)：将src中的内容复制到dest中</li><li>boolean replaceAll(List list,Object oldVal,Object newVal)：使用新值替换List对象的所有旧值</li></ol><p>代码演示</p><p>创建Collections02测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.collections_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;h&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;List = &quot;</span>+list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;返回自然顺序中的最大元素&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;然顺序中的最大元素是&quot;</span>+Collections.max(list));</span><br><span class="line"><span class="comment">//        2. Object max(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最大元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;返回Comparator指定的顺序中的最大元素&quot;</span>);</span><br><span class="line">        <span class="comment">//比如返回字符串长度最长元素</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">maxObject</span> <span class="operator">=</span> Collections.max(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ((String)o1).length() - ((String) o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度最长元素是&quot;</span> + maxObject);</span><br><span class="line"><span class="comment">//        3. Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素</span></span><br><span class="line"><span class="comment">//        4. Object min(Collection,Comparator)：根据Comparator指定的顺序。返回给定集合中的最小元素</span></span><br><span class="line"><span class="comment">//        5. int frequency(Collection,Object)：返回指定集合中指定元素的出现次数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;tom出现的次数为&quot;</span> + Collections.frequency(list, <span class="string">&quot;tom&quot;</span>));</span><br><span class="line"><span class="comment">//        6. void copy(List dest,List src)：将src中的内容复制到dest中</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            dest.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.copy(dest,list);</span><br><span class="line">        System.out.println(<span class="string">&quot;dest = &quot;</span>+ dest);</span><br><span class="line"><span class="comment">//        7. boolean replaceAll(List list,Object oldVal,Object newVal)：使用新值替换List对象的所有旧值</span></span><br><span class="line">        Collections.replaceAll(list,<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;替换后&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202716543.png" alt="image-20230903202716543"></p><p>需要注意的是，使用copy时，dest数组的大小必须大于src数组，否则会报数组越界异常</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202619957.png" alt="image-20230903202619957"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">srcSize</span> <span class="operator">=</span> src.size();</span><br><span class="line"><span class="keyword">if</span> (srcSize &gt; dest.size())&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Source does not fit in dest&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="本章练习题"><a href="#本章练习题" class="headerlink" title="本章练习题"></a>本章练习题</h3><ol><li><p>试分析HashSet和TreeSet分别如何实现去重的</p><ul><li><p>HashSet去重机制：HashSet是通过hashCode()+equals()方法实现去重的。底层先通过hashCode方法计算出key对应的hash值，然后通过hash值查找在table表上对应索引位置上是否已经存在值。如果该位置上不存在值，则直接把key添加进去。否则通过equals方法遍历比较新增的key与已存在的key是否相同，相同就把key加入到已存在的key的后面，否则不添加。equals方法可以自定义比较的内容。</p></li><li><p>TreeSet去重机制：如果你在定义TreeSet时传入了一个Comparator匿名内部类（比较器），就使用该比较器中定义的compare方法实现去重。如果返回是0，则说明添加元素相同，不添加。如果你没有传入一个Comparator匿名内部类，系统会通过你添加的对象实现的Comprareable接口的compareTo实现去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">     <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">     <span class="comment">//把k指向key对象的类型实现的Comparable接口</span></span><br><span class="line">     Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        <span class="comment">//动态绑定compareTo方法</span></span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">     &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>分析下面代码运行会不会抛出异常，并从源码层面说明原因</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会抛出ClassCastException异常</p><p>因为在定义TreeSet时没有传进去一个Comparator匿名类，所以在执行add的时候，程序会进入下述代码中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">     <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">     <span class="comment">//把k指向key对象的类型实现的Comparable接口</span></span><br><span class="line">     Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        <span class="comment">//动态绑定compareTo方法</span></span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">     &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又因为Person类并没有实现Comparable接口，所以运行到第6行代码处时会抛出ClassCastException异常。</p></li><li><p>已知：Person类按照id和name重写了hashCode与equals方法。下面代码会输出什么？</p><p>Exercises04测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.collections_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercises04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">System.out.println(set);</span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">        set.remove(p1);</span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> id == person.id &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202625931.png" alt="image-20230903202625931"></p><p><strong>为什么set.remove(p1);执行了却没有remove成功呢？</strong></p><p>因为在执行remove方法之前，我们把p1的name值改变了**p1.name &#x3D; “CC”;**而且我们在Person类中重写了hashCode方法，所以我们把name值改变的同时导致p1对应的hash值也发生改变。而我们观看remove的源码可以知道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span></span><br></pre></td></tr></table></figure><p>此处传进去的hash值为p1更改后hash值<img src="/image/JavaCollections04/image08.jpg" alt="image08"></p><p>而辅助变量p却指向了table表中的p1，即hash值为table的hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) </span><br></pre></td></tr></table></figure><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202635079.png" alt="image-20230903202635079"></p><p>因为两个hash值不同，所以在接下来的几个if判断中结果都为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))<span class="comment">//False</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;<span class="comment">//False</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//False</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最后只能return null；然后回到remove方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为removeNode方法return null，所以返回到remove也只能return null 即修改失败。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903203133937.png" alt="image-20230903203133937"></p><p>而后面添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));</span><br></pre></td></tr></table></figure><p>可以成功，原理跟上述图示一样</p><p><strong>因为后面添加的Person(1001,”AA”)同上面一样是指向索引为3处（该处为null），所以添加成功</strong></p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903203139887.png" alt="image-20230903203139887"></p><p><strong>而Person(1001,”AA”)添加成功是因为此时索引为1出的Person值的name已发生改变。且计算出来的Hash值与索引为1处对应。所以该Person添加到索引为1处的Person后面</strong></p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903203145298.png" alt="image-20230903203145298"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java集合类-四&quot;&gt;&lt;a href=&quot;#Java集合类-四&quot; class=&quot;headerlink&quot; title=&quot;Java集合类(四)&quot;&gt;&lt;/a&gt;Java集合类(四)&lt;/h2&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;开发中如何选择集合实现类&lt;/li&gt;
&lt;li&gt;TreeSet</summary>
      
    
    
    
    <category term="Collection" scheme="https://minster.top/categories/Collection/"/>
    
    
    <category term="Java" scheme="https://minster.top/tags/Java/"/>
    
    <category term="集合" scheme="https://minster.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Set集合的用法及源码解析</title>
    <link href="https://minster.top/2022/04/23/JavaCollections_02/"/>
    <id>https://minster.top/2022/04/23/JavaCollections_02/</id>
    <published>2022-04-23T00:49:12.000Z</published>
    <updated>2023-09-04T13:20:33.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章内容为Java集合中的Set集合的常见用法和源码解析~</p><span id="more"></span><hr><ol><li>Set接口和常用方法</li><li>HashSet全面说明<ol><li>思考</li><li>HashSet底层解析</li><li>HashSet底层添加元素源码分析</li><li>HashSet扩容机制和转换红黑树机制源码解析</li><li>threshold补充说明</li></ol></li><li>LinkedHashSet说明及源码分析<ol><li>LinkedHashSet全面说明</li><li>LinkedHashSet底层机制示意图</li><li>LinkedHashSet底层源码分析</li></ol></li></ol><hr><h3 id="Set接口和常用方法"><a href="#Set接口和常用方法" class="headerlink" title="Set接口和常用方法"></a>Set接口和常用方法</h3><ul><li><p>Set接口基本介绍</p><ol><li>无序（添加和取出的顺序不一致），没有索引</li><li>不允许重复元素，所以最多包含一个null</li><li>JDK API中Set接口常用的实现类有：HashSet、TreeSet等</li></ol></li><li><p>Set接口的常用方法</p><ul><li>和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样。（详情见Java集合类(一)）</li></ul></li><li><p>以Set接口的实现类HashSet来讲解Set接口的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;set = &quot;</span> + set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202003956.png" alt="image-20230903202003956"></p><p>结论：</p><ol><li>set接口的实现类的对象（set接口对象），不能存放重复的元素，可以添加null</li><li>set接口对象存放数据是无序（即添加的顺序和取出的顺序不一致）</li><li>取出的顺序虽然不是添加的属性，但是顺序是固定的！</li></ol></li><li><p>Set接口的遍历方式</p><p>同Collection的便利方式一样，因为Set接口是Collection接口的子接口。</p><ul><li><p>使用迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;===迭代器遍历===&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;set = &quot;</span>+next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增强for</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;增强for遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object o: set) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;set = &quot;</span>+o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>不能使用</strong>索引的方式来获取</p></li></ul></li></ul><h3 id="HashSet全面说明"><a href="#HashSet全面说明" class="headerlink" title="HashSet全面说明"></a>HashSet全面说明</h3><ol><li><p>HashSet实现了Set接口</p></li><li><p>HashSet实际上是HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以存放null值，但是只能有一个</p></li><li><p>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果（即不保证存放元素的顺序与取出顺序一致）</p></li><li><p>不能有重复元素或对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Set</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="comment">/*说明</span></span><br><span class="line"><span class="comment">        * 1. 在执行add方法后，会返回一个Boolean值</span></span><br><span class="line"><span class="comment">        * 2. 如果添加成功，返回true，否则返回false</span></span><br><span class="line"><span class="comment">        * 3. 可以通过remove指定删除哪个对象</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;mary&quot;</span>));<span class="comment">//T</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;mary&quot;</span>));<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line">        hashSet.add(<span class="string">&quot;jack&quot;</span>);<span class="comment">//可以添加</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;jack&quot;</span>);<span class="comment">//添加失败</span></span><br><span class="line">        <span class="comment">//由于下面每一次add都新建了一个Dog对象</span></span><br><span class="line">        <span class="comment">//所以下面两个Dog对象都会添加成功</span></span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;HashSet = &quot;</span>+ hashSet);</span><br><span class="line">        hashSet.remove(<span class="string">&quot;mary&quot;</span>);<span class="comment">//删除mary</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;HashSet = &quot;</span>+ hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202014398.png" alt="image-20230903202014398"></p></li></ol><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul><li><p><strong>下面两个String对象都会被添加到HashSet集合里面去吗？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;czh&quot;</span>));</span><br><span class="line">hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;czh&quot;</span>));</span><br></pre></td></tr></table></figure><p>运行的结果是仅有一个数据被添加，为什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">    ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure><p>因为此时String类型重写的equals()方法是比较其字符串内容是否相同，所以此时添加的两个“czh”数据只有一个能被添加进去。</p><p>而上述Dog对象的添加原理也是类似。</p><p>下面我们通过解读HashSet的底层结构解决这个问题！</p></li></ul><h4 id="HashSet底层解析"><a href="#HashSet底层解析" class="headerlink" title="HashSet底层解析"></a>HashSet底层解析</h4><ul><li><p>因为HashSet的底层是HashMap，所以分析HashMap底层是（数组+链表+红黑树）即可</p><p>为了更好理解HashMap的底层，下面模拟一个简单的数组+链表结构</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202020462.png" alt="image-20230903202020462"></p><p>创建Node结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点Node，item存储数据，next指向下一个结点，可以形成链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Object item;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object item, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建HashSetStructure类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetStructure</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建一个类型为Node的数组</span></span><br><span class="line">        Node[] nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="comment">//2. 创建结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">john</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;john&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        nodes[<span class="number">2</span>] = john;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;jack&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        john.next = jack;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">mary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;mary&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        jack.next = mary;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">lucy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;lucy&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        nodes[<span class="number">3</span>] = lucy;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;node = &quot;</span>+nodes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202027186.png" alt="image-20230903202027186"></p></li></ul><h4 id="HashSet底层添加元素源码分析"><a href="#HashSet底层添加元素源码分析" class="headerlink" title="HashSet底层添加元素源码分析"></a>HashSet底层添加元素源码分析</h4><ul><li><p>分析HashSet添加元素的底层是如何实现的（hash()+equals()）</p><ol><li>HashSet底层就是HashMap</li><li>添加一个元素时，先通过hash()得到hash值，然后转换成索引值</li><li>找到存储数据表table，看这个索引位置是否已经存放了元素<ol><li>如果没有，直接添加</li><li>如果有元素，调用equals比较，如果元素内容相同，就放弃添加，如果不相同，则添加到最后</li></ol></li><li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8），并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树）。</li><li>当元素个数到达TREEIFY_THRESHOLD但table的大小小于MIN_TREEIFY_CAPACITY(默认64)时，系统会把table表填扩容到64，然后进行树化。</li></ol></li><li><p>HashSet添加元素的源码解读</p><p>创建HashSetSource类，用于debug</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        hashSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;set = &quot;</span> + hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>执行构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以清晰地知道HashSet的底层就是HashMap</p></li><li><p>执行add()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;<span class="comment">//e=&quot;jack&quot;</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PRESENT是hashSet为了能使用hashMap而定义的一个常量（定值），无论添加了多少的元素它都不会变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure></li><li><p>执行put()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;<span class="comment">//key = &quot;jack&quot;</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value为PRESENT,是共享的。</p></li><li><p>执行hash方法，计算key的hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果key !&#x3D; null，程序会执行Object类中的hashCode()方法来获取key的值，并将它进行无符号右移16位（为了防止key的hashCode值发生冲突），最后得到的h为key对应的hash值。</p><p><strong>hash值并不是hashCode，因为(h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16)</strong></p></li><li><p>获取到hash值后，执行putVal方法（<strong>重要！</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;<span class="comment">//定义了辅助变量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此方法中，因为辅助变量tab的初始值为null，所以进入到resize()方法，给tab表赋予初始大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的table为hashMap的一个属性，类型为Node[]</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202036032.png" alt="image-20230903202036032"></p><p>因为初始的table为null，所以执行resize()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面代码为resize()方法的一些初始赋值</span></span><br><span class="line">Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//结点oleTab表示原先的表</span></span><br><span class="line"><span class="comment">//oldCap表示初始表的容量大小</span></span><br><span class="line"><span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"><span class="comment">//oldThr为当前表的一个临界值，当达到临界值时会扩容</span></span><br><span class="line"><span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line"><span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>因为初始的table为null，所以oldCap为0，所以进入到下述语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;        <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DEFAULT_INITIAL_CAPACITY为hashMap定义的常量，大小为16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>所以newCap&#x3D; 16，即第一次扩容大小为16</p><p>newThr为表的一个临界值，是使用负载因子DEFAULT_LOAD_FACTOR乘以初始大小等到的一个值。</p><blockquote><p>默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</p></blockquote><p>使用newThr是为了减少冲突，增加一个缓冲区，避免在多线程向表中增加数据时，表的内存不够而导致死锁。</p><p>初始化tap的大小之后，会判断**(p &#x3D; tab[i &#x3D; (n - 1) &amp; hash])**是否为null，(n - 1) &amp; hash是位运算，详解见<a href="https://minster77.github.io/p/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%9B%86%E5%90%88%E7%AF%87%E4%BA%8C/">HashMap数学原理</a>。计算出来的i为该key值在table表中的索引位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果p&#x3D;null，表示还没有存放元素，执行**tab[i] &#x3D; newNode(hash, key, value, null);**创建一个Node（key&#x3D;“jack”,value&#x3D;PRESENT）把hash也放进Node是为了下次添加元素时比较。</p><p>执行完毕，此时我们可以发现此时table表中已经在刚刚计算出来的索引值上添加了“jack”。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202054144.png" alt="image-20230903202054144"></p><p>到此为止，HashMap的<strong>第一次</strong>添加元素分析完毕。</p><p>当我们向HashMap集合表再次添加数据时，系统会计算其hash值，然后通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法判断该hash值对应的索引位置上是否已经存在值，<strong>如果不存在</strong>，即把新增的key添加到表中的该索引位置上。</p><p>此时可以发现，table表上多了一个数据</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202059520.png" alt="image-20230903202059520"></p><p>如果该hash值对应的索引位置上已经存在值，程序会跳到下面语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p为当前索引位置上对应的链表的第一个元素，即已经添加的值</span></span><br><span class="line"><span class="comment">//所以p.hash为已存在值得hash值，p.key为已存在值得key值</span></span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">    ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">    e = p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果<strong>当前索引位置上对应的链表的第一个元素的hash值</strong>与需要添加的key的hash值一样</p><p>且满足以下两个条件之一：</p><ul><li>准备添加的key值与p指向的Node结点的key是同一个对象</li><li>p指向的Node结点的key的equals()和准备假如的key比较后相同。</li></ul><p><strong>需要注意的是，此时equals()方法不能理解为只比较字符串内容是否相同，因为每一个类都会有其对应的equals()方法，所以equals()方法的比较内容可以由程序员所重写的方法来决定！</strong></p><p>此时说明新增加的key值已存在，所以该key值不会被添加到table中。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202111028.png" alt="image-20230903202111028"></p><p>若不满足上述条件，程序会继续往下走，执行下面语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述语句会判断p是否为红黑树，如果是红黑树，就调用putTreeVal进行添加。</p><p>如果p不是红黑树，执行以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//这是条件1</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这是条件2</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在可以执行上述代码时，说明此时<strong>table表中是使用链表的方式来存储数据</strong> 。</p><p>此时进入一个死循环，退出的条件：</p><ol><li><p>条件1：在要加入的位置i &#x3D; (n - 1) &amp; hash处所形成的链表没有一个结点与要加入的结点相同时，退出循环，此时就加在最末尾。添加成功</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202118999.png" alt="image-20230903202118999"></p></li><li><p>条件2 :在要加入的位置i &#x3D; (n - 1) &amp; hash处所形成的链表有结点与要加入的结点相同，此时退出循环，添加失败</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202124154.png" alt="image-20230903202124154"></p></li></ol><p>两个条件结合起来使用</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202129297.png" alt="image-20230903202129297"></p><p>需要注意的是当我们把元素添加到聊表后，会进行以下判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)&#123; <span class="comment">// -1 for 1st</span></span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断链表是否<strong>已经达到</strong>8个结点（TREEIFY_THRESHOLD&#x3D;8）。如果到达，则调用treeifyBin(tab, hash)方法对当前链表进行树化（转换成红黑树）。</p><p>注意，在转换成红黑树时，treeifyBin(tab, hash)方法会进行判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)&#123;</span><br><span class="line">    resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断table表大小是否&lt;64，如果小于64，会先将table表进行扩容，再进行树化。</p></li></ol></li></ul><h4 id="HashSet扩容机制和转换红黑树机制源码解析"><a href="#HashSet扩容机制和转换红黑树机制源码解析" class="headerlink" title="HashSet扩容机制和转换红黑树机制源码解析"></a>HashSet扩容机制和转换红黑树机制源码解析</h4><ol><li><p>HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）&#x3D;16*负载因子（loadFactor）0.75 &#x3D; 12</p></li><li><p>如果数组使用到了临界值12，就会扩容到16*2&#x3D;32，新的临界值就是 32 * 0.75 &#x3D; 24，依次类推</p></li><li><p>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），<strong>否则任然采用数组扩容机制</strong></p><p>创建测试类HashSetIncrement.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetIncrement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">12</span>; i++) &#123;</span><br><span class="line">            hashSet.add(<span class="keyword">new</span> <span class="title class_">A</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hashSet = &quot;</span>+ hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class A</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HashSetIncrement类中的for循环处加一个断点，debug。可以发现，当i&#x3D;9时，即满足一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，此时触发转换红黑树机制。</p><p>但是此时不满足table表大小&gt;&#x3D;64</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)&#123;</span><br><span class="line">    resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以此时table表会进行扩容。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202138380.png" alt="image-20230903202138380"></p><p>继续执行，可以发现table再次扩容。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202143829.png" alt="image-20230903202143829"></p><p>再继续执行，可以发现此时链表已经发生树化（转换成红黑树）</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202148947.png" alt="image-20230903202148947"></p><p>树化过程的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.prev = tl;</span><br><span class="line">            tl.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">        hd.treeify(tab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细解释见<a href="https://blog.csdn.net/weixin_40255793/article/details/80748946">Jdk1.8集合框架之HashMap源码解析</a></p></li></ol><h4 id="threshold补充说明"><a href="#threshold补充说明" class="headerlink" title="threshold补充说明"></a>threshold补充说明</h4><ul><li><p>在putVal方法中，有这么一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">++modCount;</span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">    resize();</span><br><span class="line">&#125;</span><br><span class="line">afterNodeInsertion(evict);</span><br></pre></td></tr></table></figure><p>modCount代表我们对table表修改的次数。</p><p>其中size是每当我们加入一个结点Node(key,value,hash,next)，size++。</p><p>所以当我们想table表中加入指定数量的Node结点是，也会触发扩容机制。</p><p>代码演示HashSetIncrement类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetIncrement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">7</span>; i++) &#123;</span><br><span class="line">            hashSet.add(<span class="keyword">new</span> <span class="title class_">A</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">7</span>; i++) &#123;</span><br><span class="line">            hashSet.add(<span class="keyword">new</span> <span class="title class_">B</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hashSet = &quot;</span>+ hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class A 与 Class B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行调试，可以发现，虽然我们在一条链表上增加了7个元素，然后第二条链表增加到第五个元素时size&#x3D;12，也触发了扩容机制</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202158573.png" alt="image-20230903202158573"></p><p>所以触发扩容机制的前提是累积添加元素到达threshold。</p></li></ul><p>​</p><h3 id="LinkedHashSet说明及源码分析"><a href="#LinkedHashSet说明及源码分析" class="headerlink" title="LinkedHashSet说明及源码分析"></a>LinkedHashSet说明及源码分析</h3><h4 id="LinkedHashSet全面说明"><a href="#LinkedHashSet全面说明" class="headerlink" title="LinkedHashSet全面说明"></a>LinkedHashSet全面说明</h4><ol><li>LinkedHashSet是HashSet的子类。</li><li>LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表。</li><li>LinkedHashSet根据元素的HashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是一插入顺序保存的。</li><li>LinkedHashSet不允许添加重复元素。</li></ol><h4 id="LinkedHashSet底层机制示意图"><a href="#LinkedHashSet底层机制示意图" class="headerlink" title="LinkedHashSet底层机制示意图"></a>LinkedHashSet底层机制示意图</h4><ul><li><p>示意图</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202212222.png" alt="image-20230903202212222"></p></li><li><p>双向链表具体机制与<a href="https://minster77.github.io/p/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%80/#linkedlist%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">LinkedList底层结构</a>类似。</p></li></ul><h4 id="LinkedHashSet底层源码分析"><a href="#LinkedHashSet底层源码分析" class="headerlink" title="LinkedHashSet底层源码分析"></a>LinkedHashSet底层源码分析</h4><p><strong>说明</strong></p><ul><li><p>在LInkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）</p></li><li><p>每个节点有before和after属性，这样可以形成双向链表</p></li><li><p>在添加一个元素时，先求hash值，再求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加；原则跟hashset一样）</p></li><li><p>所以，我们遍历LinkedHash可以确定插入顺序和取出顺序一致</p><p>创建LinkedHashSetSource类，用于分析源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.sets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        set.add(<span class="number">456</span>);</span><br><span class="line">        set.add(<span class="number">456</span>);</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="string">&quot;czh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedHashSet = &quot;</span> + set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以知道，添加第一次时，系统会将数组table扩容到16，存放的结点类型是LinkedHashMap$Entry</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202221500.png" alt="image-20230903202221500"></p><p>为什么数组时HashMap$Node[]类型，而存放的元素&#x2F;数据却是LinkedHashMap$​​​​Entry呢？</p><p>下面我们查看LinkedHashMap底层源码来解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现上面这个在LinkedHashMap源码中的静态内部类Entry继承了HashMap.Node。即数组的多态。双向链表实现的关键也是在这里。</p><p>继续往下调试</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202227394.png" alt="image-20230903202227394"></p><p>此时的map与hashSet的不一样，多了几个属性。其中head表示双向链表中的头结点，tail表示尾结点。</p><p>而每一个结点又有before与after属性，指向上一个结点与下一个结点。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903202233135.png" alt="image-20230903202233135"></p><p>所以LinkedHashSet可以实现按顺序插入及取出。</p><p>进入add()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以知道LinkedHashSet添加元素底层就是<a href="#HashSet%E5%BA%95%E5%B1%82%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">HashSet添加元素</a>的底层（<strong>因为LinkedHashSet是HashSet的实现子类</strong>）</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本章内容为Java集合中的Set集合的常见用法和源码解析~&lt;/p&gt;</summary>
    
    
    
    <category term="Collection" scheme="https://minster.top/categories/Collection/"/>
    
    
    <category term="Java" scheme="https://minster.top/tags/Java/"/>
    
    <category term="Set" scheme="https://minster.top/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>List集合的用法及源码解析</title>
    <link href="https://minster.top/2022/04/22/JavaCollections_01/"/>
    <id>https://minster.top/2022/04/22/JavaCollections_01/</id>
    <published>2022-04-22T00:49:12.000Z</published>
    <updated>2023-09-04T13:20:34.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章内容为Java集合中的List集合的常见用法和源码解析~</p><span id="more"></span><hr><ol><li><p>集合的概念</p></li><li><p>Collection接口和常用方法</p></li><li><p>List接口和常用方法</p></li><li><p>ArrayList底层源码即注意事项</p></li><li><p>Vector底层结构和源码解析</p></li><li><p>LinkedList底层结构和源码解析</p></li></ol><hr><h3 id="集合的概念"><a href="#集合的概念" class="headerlink" title="集合的概念"></a>集合的概念</h3><ul><li><p>由于前面保存多个数据使用的是数组，而数组保存数据会有一些不足的地方。</p><ol><li>长度开始时必须指定，而且一旦指定，不能更改</li><li>保存的必须为同一类型的元素</li><li>使用数组进行增加元素&#x2F;删除会比较麻烦</li></ol></li><li><p>若使用集合来处理数据的话，这类问题将会减少。集合的好处如下：</p><ul><li>可以动态保存任意多个对象，使用比较方便！</li><li>提供了一系列方便操作对象的方法：add、remove、set、get等</li><li>使用集合添加、删除新元素的代码更加简洁了</li></ul></li><li><p>集合的框架体系</p><p>Collection接口实现子类：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201549150.png" alt="image-20230903201549150"></p><p>Map接口实现子类：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201558897.png" alt="image-20230903201558897"></p></li><li><p>集合主要有两种（单列集合，双列集合）</p><ul><li><p>Collection接口有两个重要的子接口List、Set，他们的实现子类都是单列集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;tom&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>Map接口的实现子类是双列集合，即以K-V形式存放数据的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">hashMap.put(<span class="string">&quot;No1&quot;</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;No2&quot;</span>,<span class="string">&quot;tom&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Collection接口和常用方法"><a href="#Collection接口和常用方法" class="headerlink" title="Collection接口和常用方法"></a>Collection接口和常用方法</h3><ul><li><p>Collection接口的特征</p><ol><li><p>Collection实现子类可以存放多个元素，每个元素可以是Object</p></li><li><p>有些Collection的实现类，可以存放重复的元素，有些不可以</p></li><li><p>Collection实现类有些是有序的（List），有些不是有序的（Set）</p></li><li><p>Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的</p></li></ol></li><li><p>Collection接口的常用方法 </p><ul><li>add：添加单个元素</li><li>remove：删除指定元素</li><li>contains：查找元素是否存在</li><li>size：获取元素个数</li><li>isEmpty：判断是否为空</li><li>clear：清空</li><li>addAll：增加多个元素</li><li>containsAll：查找多个元素是否都存在</li><li>removeAll：删除多个元素</li></ul><p>以Collection的实现子类演示上述方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collecyion_</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">List</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//add：添加单个元素</span></span><br><span class="line">        List.add(<span class="number">10</span>);</span><br><span class="line">        List.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        List.add(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;List=&quot;</span>+List);</span><br><span class="line">        <span class="comment">//remove：删除指定元素</span></span><br><span class="line">        List.remove(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;List=&quot;</span>+List);</span><br><span class="line">        <span class="comment">//contains：查找元素是否存在</span></span><br><span class="line">        System.out.println(List.contains(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//size：获取元素个数</span></span><br><span class="line">        System.out.println(List.size());</span><br><span class="line">        <span class="comment">//isEmpty：判断是否为空</span></span><br><span class="line">        System.out.println(List.isEmpty());</span><br><span class="line">        <span class="comment">//clear：清空</span></span><br><span class="line">        List.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;List=&quot;</span>+List);</span><br><span class="line">        <span class="comment">//addAll:增加多个元素</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">List2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        List2.add(<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line">        List2.add(<span class="string">&quot;三国演义&quot;</span>);</span><br><span class="line">        List2.add(<span class="string">&quot;水浒传&quot;</span>);</span><br><span class="line">        List.addAll(List2);</span><br><span class="line">        System.out.println(<span class="string">&quot;List=&quot;</span>+List);</span><br><span class="line">        <span class="comment">//containsAll：查找多个元素是否都存在</span></span><br><span class="line">     System.out.println(List.containsAll(List2));</span><br><span class="line">        <span class="comment">//removeAll：删除多个元素</span></span><br><span class="line">        List.removeAll(List2);</span><br><span class="line">        System.out.println(<span class="string">&quot;List=&quot;</span>+List);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201609533.png" alt="image-20230903201609533"></p></li><li><p>Collection接口使用Iterator(迭代器)遍历元素</p><ul><li>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素</li><li>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器</li><li>Iterator仅用于遍历集合，Iterator本身并不存放对象</li><li>hasNext()：判断是否还有下一个元素</li><li>next()：将下移以后集合位置上的元素返回</li></ul><p>代码演示：</p><p><strong>Collection_Book</strong>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collection_Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Collection_Book</span><span class="params">(String name, String author, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Collection_Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Collection_Iterator</strong>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.conllection_.Collection_Book;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collection_Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Collection_Book</span>(<span class="string">&quot;三国演义&quot;</span>,<span class="string">&quot;罗贯中&quot;</span>,<span class="number">10.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Collection_Book</span>(<span class="string">&quot;红楼梦&quot;</span>,<span class="string">&quot;曹雪芹&quot;</span>,<span class="number">15.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Collection_Book</span>(<span class="string">&quot;小李飞刀&quot;</span>,<span class="string">&quot;古龙&quot;</span>,<span class="number">8.1</span>));</span><br><span class="line"><span class="comment">//创建col对应的迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> col.iterator();</span><br><span class="line">        <span class="comment">//使用while遍历循环</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="comment">//因为迭代器取到的数据可以是任意类型的，所以用Object</span></span><br><span class="line">            Object obj= iterator.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201618945.png" alt="image-20230903201618945"></p><blockquote><p>hasNext()的返回值为Boolean，</p><p>next()的返回值可以为任意类型</p></blockquote><p>注意：当退出while循环后，这是iterator迭代器指向最后一个元素，此时再使用iterator.next()系统会报错。</p><p>如果要再次遍历，我们需要<strong>重置迭代器</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator = col.iterator();<span class="comment">//重置迭代器</span></span><br></pre></td></tr></table></figure></li><li><p>在IDEA中可以使用itit快捷生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    Object obj= iterator.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ctrl+j可以看到所有快捷键</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201626588.png" alt="image-20230903201626588"></p></li><li><p>Collection接口使用增强for循环来遍历元素</p><ul><li>增强for就是简化版的iterator，本质一样，只能用于遍历集合或素组</li></ul><p>基本语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object object : col)&#123;</span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码演示</p><p><strong>Collection_For</strong>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collection_For</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Collection_Book</span>(<span class="string">&quot;三国演义&quot;</span>,<span class="string">&quot;罗贯中&quot;</span>,<span class="number">10.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Collection_Book</span>(<span class="string">&quot;红楼梦&quot;</span>,<span class="string">&quot;曹雪芹&quot;</span>,<span class="number">15.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Collection_Book</span>(<span class="string">&quot;小李飞刀&quot;</span>,<span class="string">&quot;古龙&quot;</span>,<span class="number">8.1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Object object : col)&#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果与使用迭代器的一致。</p><p>我们在**for(Object object : col)**这行代码加一个断点，通过Debug，可以发现增强for会依次调用迭代器的底层方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们可以得知，增强for的底层仍然是<strong>迭代器</strong>！</p></li></ul><h3 id="List接口和常用方法"><a href="#List接口和常用方法" class="headerlink" title="List接口和常用方法"></a>List接口和常用方法</h3><p>List接口是Collection接口的子接口</p><ol><li><p>List集合类中元素有序(即添加顺序与取出顺序一致)、且可重复</p></li><li><p>List集合中的每个元素都有其对应的顺序索引，即支持索引</p></li><li><p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p></li><li><p>List接口常用的实现类有:ArrayList、LinkedList、Vector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.lists;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List_</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//1. List集合类中元素有序(即添加顺序与取出顺序一致)、且可重复</span></span><br><span class="line">           list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">           list.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">           list.add(<span class="string">&quot;heng&quot;</span>);</span><br><span class="line">           list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">           list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">           list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;list=&quot;</span>+list);</span><br><span class="line">           <span class="comment">//2. List集合中的每个元素都有其对应的顺序索引，即支持索引</span></span><br><span class="line">           <span class="comment">//   索引从0开始</span></span><br><span class="line">           System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201636750.png" alt="image-20230903201636750"></p></li></ol><p>List接口的常用方法</p><ol><li><p>void add(int index,Object ele)：在index位置插入ele元素。</p></li><li><p>bollean addAll(int index,Collection eles)：在index位置开始讲eles中的所有元素添加进来。</p></li><li><p>Object get(int index)：获取指定index位置的元素。</p></li><li><p>int indexOf(Object obj)：返回obj在集合中首次出现的位置。</p></li><li><p>int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置。</p></li><li><p>Object remove(int index)：移除指定index位置的元素，并返回此元素。</p></li><li><p>Object set(int index,Object ele)：设置指定index位置的元素为ele，相当于是替换。</p></li><li><p>List subList(int formIndex,int toIndex)：返回从formIndex到tolIndex位置的子集合。</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list1 = &quot;</span>+list1);</span><br><span class="line">       <span class="comment">// 1. void add(int index,Object ele)：在index位置插入ele元素。</span></span><br><span class="line">        list1.add(<span class="number">2</span>,<span class="string">&quot;nancy&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list1 = &quot;</span>+list1);</span><br><span class="line">       <span class="comment">// 2. bollean addAll(int index,Collection eles)：在index位置开始讲eles中的所有元素添加进来。</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;heng&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;minster&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list2 = &quot;</span>+list2);</span><br><span class="line">        list1.addAll(<span class="number">3</span>,list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list1 = &quot;</span>+list1);</span><br><span class="line">       <span class="comment">// 3. Object get(int index)：获取指定index位置的元素。</span></span><br><span class="line">        System.out.println(list1.get(<span class="number">3</span>));</span><br><span class="line">       <span class="comment">// 4. int indexOf(Object obj)：返回obj在集合中首次出现的位置。</span></span><br><span class="line">        System.out.println(list1.indexOf(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">       <span class="comment">// 5. int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置。</span></span><br><span class="line">        System.out.println(list1.lastIndexOf(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">       <span class="comment">// 6. Object remove(int index)：移除指定index位置的元素，并返回此元素。</span></span><br><span class="line">        System.out.println(list1.remove(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;list1 = &quot;</span>+list1);</span><br><span class="line">       <span class="comment">// 7. Object set(int index,Object ele)：设置指定index位置的元素为ele，相当于是替换。</span></span><br><span class="line">        <span class="comment">//index必须是存在的下标，越界会报错！</span></span><br><span class="line">        <span class="comment">//返回被替换的值</span></span><br><span class="line">        System.out.println(list1.set(<span class="number">3</span>,<span class="string">&quot;rui&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;list1 = &quot;</span>+ list1);</span><br><span class="line">       <span class="comment">// 8. List subList(int formIndex,int toIndex)：返回从formIndex到tolIndex位置的子集合。</span></span><br><span class="line">        <span class="comment">//返回的子集合为前闭后开区间！ forIndex &lt;= subList &lt; toIndexE</span></span><br><span class="line">        System.out.println(list1.subList(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201644405.png" alt="image-20230903201644405"></p></li></ol><ul><li><p>List的三种遍历方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;成志恒&quot;</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====迭代器遍历====&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.迭代器遍历</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span>+obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====增强for遍历====&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.增强For</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : list)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span>+o);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;====普通For遍历====&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.普通For</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i&lt; list.size();i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span>+list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201656273.png" alt="image-20230903201656273"></p><p>List的其他实现子类（LinkedList、Vector）也可以使用上述三种方式进行遍历</p></li></ul><h3 id="ArrayList底层源码及注意事项"><a href="#ArrayList底层源码及注意事项" class="headerlink" title="ArrayList底层源码及注意事项"></a>ArrayList底层源码及注意事项</h3><ul><li><p>注意事项</p><ol><li><p>ArrayList可以加入任意元素，包括null（或者是多个null）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        arrayList.add(<span class="literal">null</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201746974.png" alt="image-20230903201746974"></p></li><li><p>ArrayList是由数组来实现数据存储的</p></li><li><p>ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）。在多线程情况下，不建议使用ArrayList。</p><p>ArrayList.add() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList.add()的源码没有修饰词synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="comment">//Increments modCount!!</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于该集合的方法没有用synchronized修饰，我们可以知道ArrayList是线程不安全的！下面可以跟Vector的源码进行比较</p><p>Vector.add() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>ArrayList的底层源码分析（先说结论，再分析源码）</p><ol><li><p>ArrayList中维护了一个Object类型的数组elementData。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transient 表示瞬间，短暂的，表示该属性不会被序列化</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></li><li><p>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如果需要再次扩容，则扩容elementData为1.5倍（<strong>即初始化数组elementData的大小为0，初次添加数据时扩容成10，等到添加的数据达到容量极限时，继续扩容为elementData的1.5倍</strong>）。</p></li><li><p>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容则直接扩容elementData为1.5倍</p></li></ol><ul><li><p>扩容机制源码分析</p><ol><li><p>创建ArrayListSource类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//利用无参构造创建了ArrayList</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//利用有参构造创建了ArrayList</span></span><br><span class="line">        <span class="comment">//ArrayList list = new ArrayList(8); </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            arrayList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>; i &lt; <span class="number">15</span> ; i++) &#123;</span><br><span class="line">            arrayList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arrayList.add(<span class="number">100</span>);</span><br><span class="line">        arrayList.add(<span class="number">200</span>);</span><br><span class="line">        arrayList.add(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在ArrayList arrayList &#x3D; new ArrayList();出添加断点，debug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DEFAULTCAPACITY_EMPTY_ELEMENTDATA为空数组，其定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>可以知道此时创建了一个空的elementData数组&#x3D;{}！</p></li><li><p>下一步 执行arrayList.add()。add源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>先确定是否需要扩容（ensureCapacityInternal）</li><li>然后再执行，赋值</li></ol></blockquote></li><li><p>进入ensureCapacityInternal方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(</span><br><span class="line">        calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法调用了ensureExplicitCapacity与calculateCapacity方法。</p><p>calculateCapacity方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//DEFAULT_CAPACITY为常量，定义为10</span></span><br><span class="line">        <span class="comment">//minCapacity为集合所需的最小容量</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensureExplicitCapacity方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// modCount为当前集合被修改的次数</span></span><br><span class="line">    <span class="comment">//用来防止多个线程操作产生的异常。</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensureCapacityInternal方法在这一步中首先调用了<strong>calculateCapacity</strong>方法来确定<strong>minCapacity</strong>(最小容量)然后把最小容量返回到<strong>ensureExplicitCapacity</strong>方法中，判断elementData的大小是够足够，如果不够会使用<strong>grow()方法去扩容</strong>。</p></li><li><p>然后通过调用grow方法 完成扩容。grow源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//按原来大小的1.5倍扩容</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始值扩容</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//判断容量是否超过数组最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// Arrays.copyOf可以把原先数组copy到新的elementData！</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一步完成了：</p><ol><li>实现扩容</li><li>使用扩容机制来确定要扩容到多大</li><li>第一次newCapacity &#x3D; 10</li><li>第二次及其以后，按照1.5倍扩容</li><li>扩容使用的是Arrays.copyOf()实现，可以把原来elementData的数据copy到扩容后的elementData中</li><li>完成后把扩容后的数组逐层返回到add方法里面</li></ol><p>扩容后的elementData：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201758729.png" alt="image-20230903201758729"></p></li></ol></li><li><p>当使用有参构造器创建与使用ArrayList时，扩容机制与上述基本一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.elementData &#x3D; new Object[initialCapacity]创建了指定大小的elementData数组。</p><p>initialCapacity为构造器传入的初始参数，即为elementData数组的初始大小。</p><p>需要注意的是，有参构造器扩容时<strong>第一次扩容为elementData的1.5倍，并不是初始为10！</strong></p><blockquote><p>因为calculateCapacity方法中只有elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA时才会把常量DEFAULT_CAPACITY的值返回到ensureExplicitCapacity。而DEFAULTCAPACITY_EMPTY_ELEMENTDATA为空数组。由于有参构造创建的elementData必不为空，所以初次扩容时的newCapaCity为elementData大小的1.5倍。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容后的elementData：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201805459.png" alt="image-20230903201805459"></p><p><strong>剩下的扩容步骤与无参的一样！</strong></p></li></ul></li></ul><h3 id="Vector底层结构和源码解析"><a href="#Vector底层结构和源码解析" class="headerlink" title="Vector底层结构和源码解析"></a>Vector底层结构和源码解析</h3><ul><li><p>Vector的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure></li><li><p>ector底层也是一个数组，protected Object[] elementData；</p></li><li><p>Vector是线程同步的，即线程安全，Vector类的操作方法都带有synchronize</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Vector与ArrayList比较</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201813742.png" alt="image-20230903201813742"></p></li><li><p>Vector扩容的底层源码</p><p>创建Vector_类，使用无参构造器来创建Vector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vector</span> <span class="variable">vector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector.add(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vecto的无参创建初始化elementData大小为10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到add方法，通过ensureCapacityHelper判断是否需要扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensureCapacityHelper方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//如果最小容量大于数组的实际长度，则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果minCapacity - elementData.length &gt; 0满足，则通过grow方法扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又因为capacityIncrement&#x3D;0，所以newCapacity&#x3D;oldCapacity+oldCapacity，即为原来的两倍！</p><p>扩容后的Vector：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201822673.png" alt="image-20230903201822673"></p></li></ul><p>​</p><h3 id="LinkedList底层结构和源码解析"><a href="#LinkedList底层结构和源码解析" class="headerlink" title="LinkedList底层结构和源码解析"></a>LinkedList底层结构和源码解析</h3><ol><li>LinkedList底层实现了双向链表和双端队列特点</li><li>可以添加任意元素（元素可以重复），包括null</li><li>LinkedList也是线程不安全的，没有实现同步</li></ol><ul><li><p>LinkedList的底层操作机制</p><ul><li><p>LinkedList底层维护了一个双向链表。</p></li><li><p>LinkedList中维护了两个属性first和last分别指向首节点和尾结点。</p></li><li><p>每个节点（Node对象），里面又包含prev、next、item三个属性，其中通过prev指向前一个节点，通过next指向后一个节点。最终实现双向链表。</p></li><li><p>所以LinkedList的元素添加和删除，不是通过数组完成的，相对来说效率较高。</p></li><li><p>LinkedList链表示意图：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201831149.png" alt="image-20230903201831149"></p></li></ul></li><li><p>双向链表的创建使用演示</p><p>创建Note类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.lists;</span><br><span class="line"><span class="comment">//定义一个Note类，Note对象表示双向链表的一个节点。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Note</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object item;<span class="comment">//存放数据</span></span><br><span class="line">    <span class="keyword">public</span> Note pre;<span class="comment">//指向上一个节点</span></span><br><span class="line">    <span class="keyword">public</span> Note next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Note</span><span class="params">(Object name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.item=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Note&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&quot;</span> + item +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在LinkedList类中模拟建立一个双向链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//模拟一个简单的双向链表</span></span><br><span class="line">        <span class="comment">//首先创建三个结点 jack、mary、tom</span></span><br><span class="line">        <span class="type">Note</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Note</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">Note</span> <span class="variable">mary</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Note</span>(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        <span class="type">Note</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Note</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="comment">//连接三个结点形成双向链表</span></span><br><span class="line">        <span class="comment">//jack-&gt;mary-&gt;tom</span></span><br><span class="line">        jack.next = mary;</span><br><span class="line">        mary.next = tom;</span><br><span class="line">        <span class="comment">//tom-&gt;mary-&gt;jack</span></span><br><span class="line">        tom.pre = mary;</span><br><span class="line">        mary.pre = jack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建头结点与尾结点</span></span><br><span class="line">        <span class="comment">//让first引用指向jack，就是双向链表的头结点</span></span><br><span class="line">        <span class="type">Note</span> <span class="variable">first</span> <span class="operator">=</span> jack;</span><br><span class="line">        <span class="comment">//让last引用指向tom，就是双向链表的尾结点</span></span><br><span class="line">        <span class="type">Note</span> <span class="variable">last</span> <span class="operator">=</span> tom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用头结点遍历，遍历链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头结点遍历</span></span><br><span class="line">System.out.println(<span class="string">&quot;==头结点遍历==&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(first == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(first);</span><br><span class="line">    first = first.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用尾结点遍历，遍历链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;==尾结点遍历==&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(last == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(last);</span><br><span class="line">    last = last.pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mary结点与tom结点之间增加一个smith结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在mary与tom之间增加一个smith结点</span></span><br><span class="line">        <span class="type">Note</span> <span class="variable">smith</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Note</span>(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line"></span><br><span class="line">        smith.pre = mary;</span><br><span class="line">        smith.next = tom;</span><br><span class="line">        mary.next = smith;</span><br><span class="line">        tom.pre = smith;</span><br><span class="line">        first = jack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//头结点遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==头结点遍历==&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(first);</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>删除smith结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除smith结点</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;删除smith结点&quot;</span>);</span><br><span class="line">mary.next = tom;</span><br><span class="line">tom.pre = mary;</span><br><span class="line">first = jack;</span><br><span class="line"><span class="comment">//头结点遍历</span></span><br><span class="line">System.out.println(<span class="string">&quot;==头结点遍历==&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(first == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(first);</span><br><span class="line">    first = first.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201840941.png" alt="image-20230903201840941"></p></li><li><p>利用LinkedList的CRUD来查看其底层源码</p><p>LinkedListCRUD.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListCRUD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        linkedList.add(<span class="number">100</span>);</span><br><span class="line">        linkedList.add(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在LinkedList linkedList &#x3D; new LinkedList();处添加断点，debug。</p><p>可以知道此时LinkedList只初始化了一个空的linkedList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>此时linkedList的属性 first &#x3D; null，last &#x3D; null</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201847470.png" alt="image-20230903201847470"></p><p>然后查看add方法的源码，我们可以发现add方法调用了方法linkLast</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看linkLast方法的源码，我们可以发现此时创建了一个newNode结点，并将其加入到双向链表的最后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//初始last为null，所以l=null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是第一个结点，所以newNode的next与last均为空。此时LinkedList的first与last均指向了newNode。此时链表的状态为：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201853837.png" alt="image-20230903201853837"></p><p>当我们再次往LinkedList集合中添加元素时，会再次进入到底层的linkLast方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//l = last 即指向了第一个newNode</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//此时新的newNode有prev = l 即新的newNode指向了第一个结点！</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//因为l = last 所以l不为null</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//modCount记录集合修改的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为此时的last不再为空，所以结点l指向了last结点，即第一个newNode。此时链表的状态为：</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201901917.png" alt="image-20230903201901917"></p></li><li><p>上述代码为LinkedList集合添加元素时的源码展示，下面我们看一下LinkedList集合删除指定索引的元素时的源码：</p><p>LinkedListCURD类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.conllection_.lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListCRUD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        linkedList.add(<span class="number">100</span>);</span><br><span class="line">        linkedList.add(<span class="number">200</span>);</span><br><span class="line">        linkedList.add(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;linkedList = &quot;</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        linkedList.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;linkedList = &quot;</span> + linkedList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看linkedList.remove(int index)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以知道该方法首先通过checkElementIndex(index);检查索引是否合法，不合法会抛出异常。</p><p>checkElementIndex(index);方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述isElementIndex方法的作用用来判断元素的索引范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当索引在元素的合法范围时，进入到了node(int index)方法。该方法可以返回指定元素索引处的（非空）结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"><span class="comment">//如果index小于size的一半，从头到尾遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果index大于size的一半，从尾到头遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再通过unlink(Node x)方法删除指定索引集合元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">//把要删除的元素数据赋值给element，以便删除后返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="comment">//新建一个结点next指向x.next</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">//新建一个结点prev指向x.prev</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"><span class="comment">//如果prev == null 说明x结点为头结点。</span></span><br><span class="line">    <span class="comment">//此时把first指向next，即说明x的下一个结点为新的头结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则x的上一个节点的next值指向x的下一个结点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">//因为x已经删除，所以把prev置为null</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果next == null 说明该节点为尾结点</span></span><br><span class="line">    <span class="comment">//此时吧last指向prev，即说明x的上一个结点为新的尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则把x的下一个结点的prev指向x的上一个结点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">//因为x已经删除，next</span></span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//集合的大小减一</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">//修改次数+1次</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//最后返回被删除的元素</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面为删除two结点的图解</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201910187.png" alt="image-20230903201910187"></p><p>删除后的链表状态为</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201917456.png" alt="image-20230903201917456"></p></li><li><p>ArrayList和LinkedList比较</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230903201922904.png" alt="image-20230903201922904"></p></li><li><p>如何选择ArrayList和LinkedList</p><ul><li>如果我们改查的操作多，就选ArrayList</li><li>如果我们增删操作多，就选择LinkedList</li><li>一般来说，在程序中，80%—90%都是查询，因此大部分情况下会选择ArrayList</li><li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另一个模块使用的是LinkedList</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本章内容为Java集合中的List集合的常见用法和源码解析~&lt;/p&gt;</summary>
    
    
    
    <category term="Collection" scheme="https://minster.top/categories/Collection/"/>
    
    
    <category term="Java" scheme="https://minster.top/tags/Java/"/>
    
    <category term="List" scheme="https://minster.top/tags/List/"/>
    
  </entry>
  
</feed>
