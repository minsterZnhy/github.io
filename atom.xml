<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>minster&#39;s Blog</title>
  
  <subtitle>记录学习以及生活~</subtitle>
  <link href="https://minster.top/atom.xml" rel="self"/>
  
  <link href="https://minster.top/"/>
  <updated>2023-05-27T02:56:37.430Z</updated>
  <id>https://minster.top/</id>
  
  <author>
    <name>Minster</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 多线程编程中的等待和休眠：wait() 和 sleep() 方法解析</title>
    <link href="https://minster.top/2023/05/27/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E4%BC%91%E7%9C%A0%EF%BC%9Await-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <id>https://minster.top/2023/05/27/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E4%BC%91%E7%9C%A0%EF%BC%9Await-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/</id>
    <published>2023-05-27T00:49:12.000Z</published>
    <updated>2023-05-27T02:56:37.430Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/640.png" alt="640"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在Java多线程中，线程的状态如上图所示（图来自<a href="https://javaguide.cn/">JavaGuide</a>），可以发现，当前线程调用<code>wait(long time)</code>方法或者执行<code>Thread.sleep(long time)</code>方法都会进入到一个<code>TIMED_WAITING</code>的状态。那么，这个状态下的线程的锁资源是怎么样的呢？</p><span id="more"></span><h2 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h2><p>在多线程环境下，如果当前线程调用了wait()方法，那么该方法会进入到<code>WAITING</code>状态，并释放它所持有的锁，等待其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法来唤醒它。如果没有其唤醒操作，当前线程会处于一个无限等待的状态。</p><p>如果当前线程在调用的是<code>wait(long time)</code>方法时，线程会进入到一个<code>TIMED_WAITING</code>状态，同时会释放锁资源，等待其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法来唤醒它，或者等待指定的时间过期后自动唤醒。在等待期间，该线程不会占用 CPU 资源，因此其他线程可以执行。</p><p>代码演示：</p><p><strong>WaitingThread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WaitingThread</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;获取到了锁资源&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待2秒钟，释放锁资源</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() +<span class="string">&quot;线程等待2s.....释放锁&quot;</span>);</span><br><span class="line">                lock.wait(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 等待时间过去，唤醒，尝试重新获取锁资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>WaitingTest类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">WaitingThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitingThread</span>(lock);</span><br><span class="line">        <span class="type">WaitingThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitingThread</span>(lock);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230527102116952.png" alt="image-20230527102116952"></p><p>上述代码中，我们创建了两个线程，并将它们传递给同一个锁对象。在<code>run()</code>方法中，线程首先使用<code>synchronized</code>关键字获取锁对象，然后调用<code>wait(long time)</code>方法进入<code>TIMED_WAITING</code>状态，等待2秒钟后会自动唤醒，此时，锁对象已经被释放，线程需要重新获取锁才能继续执行。可以看到，在线程重新获取锁之后，它就可以继续执行对共享数据的操作了。</p><h2 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h2><p>当线程调用<code>sleep(long time)</code>方法时，该线程也会进入到<code>TIMED_WAITING</code>状态，但是当前线程对象并不会释放锁资源，因此其他线程对象也无法获取到锁资源，会进入阻塞状态。</p><p>当指定的休眠时间过期之后，当前线程会主动唤醒，并且该线程仍然持有锁资源，可以继续执行。</p><p>代码演示：</p><p><strong>SleepingThread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SleepingThread</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;获取到了锁资源&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() +<span class="string">&quot;线程休眠2s.....仍持有锁&quot;</span>);</span><br><span class="line">                <span class="comment">// 线程休眠2秒钟，进入TIMED_WAITING状态</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 休眠时间过去，自动唤醒，继续执行&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SleepingTest类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepingTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">SleepingThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepingThread</span>(lock);</span><br><span class="line">        <span class="type">SleepingThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepingThread</span>(lock);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230527105237869.png" alt="image-20230527105237869"></p><p>在上面的代码中，我们创建了两个线程，并将它们传递给同一个锁对象。在线程的run()方法中，我们首先使用synchronized关键字来获取锁对象，然后让线程进入TIMED_WAITING状态。在这里，线程会休眠2秒钟，然后再输出一条消息。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当线程调用<code>wait()</code>方法时，线程会进入一个<code>WAITING</code>状态，并且释放锁资源，直至被唤醒才会进入到就绪状态，竞争锁资源。</p><p>当线程调用<code>wait(long time)</code>方法时（指定一个等待时间），线程会进入到一个<code>TIMED_WAITING</code>状态，同时释放锁资源，只有当线程被通知或者等待时间结束后才会重新去获取锁资源。</p><p>当线程调用的是<code>sleep(long time)</code>方法，线程虽然也会进入到一个<code>TIMED_WAITING</code>状态，但是不会释放锁资源，其他线程会处于阻塞状态直至当前线程释放锁资源</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/640.png&quot; alt=&quot;640&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在Java多线程中，线程的状态如上图所示（图来自&lt;a href=&quot;https://javaguide.cn/&quot;&gt;JavaGuide&lt;/a&gt;），可以发现，当前线程调用&lt;code&gt;wait(long time)&lt;/code&gt;方法或者执行&lt;code&gt;Thread.sleep(long time)&lt;/code&gt;方法都会进入到一个&lt;code&gt;TIMED_WAITING&lt;/code&gt;的状态。那么，这个状态下的线程的锁资源是怎么样的呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Java多线程" scheme="https://minster.top/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://minster.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Thread" scheme="https://minster.top/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot如何实现基于注解配置</title>
    <link href="https://minster.top/2023/05/26/Spring-Boot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE/"/>
    <id>https://minster.top/2023/05/26/Spring-Boot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-26T11:46:12.000Z</published>
    <updated>2023-05-26T13:04:21.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在使用Spring注册Bean时，有很多方式，其中两种常用的配置方式如下</p><p><strong>基于注解的配置</strong>：使用注解来定义 bean，如  <code>@Component</code> 、 <code>@Autowired</code> 、 <code>@Configuration</code>  等。这种方式相比于基于 XML 的配置更加简洁、易于阅读和维护，也是目前比较流行的一种方式。</p><p><strong>基于 Java 配置类的配置</strong>：使用 Java 类来定义 bean 和它们之间的依赖关系，如  <code>@Bean</code> 、 <code>@Configuration</code> 、 <code>@Import</code>  等。这种方式也是基于注解的配置方式的一种扩展形式，它允许我们使用 Java 代码来定义 bean，从而更加灵活地控制应用程序的配置。 </p><p><strong>不难发现，上述两种配置方式的核心都是基于注解实现的，只是应用场景不同。</strong></p><p>而我在使用基于Java配置类的配置时，发现在Spring中需要直接或间接实现<code>AnnotationConfigRegistry</code>接口时才能应用基于注解的配置方式；于是我便开始思考：Spring Boot是怎么实现的呢？通过查阅资料以及源码后，以下是我的拙见。</p><span id="more"></span><h2 id="Spring使用注解-Java配置类-配置Bean"><a href="#Spring使用注解-Java配置类-配置Bean" class="headerlink" title="Spring使用注解(Java配置类)配置Bean"></a>Spring使用注解(Java配置类)配置Bean</h2><p>在Spring中，我们若想简单使用基于注解的配置方式，需要完成以下几步：</p><ol><li><p>创建SpringConfig配置类作为传递参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;org.heng.dao&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring创建容器时或根据该配置类上的注解信息来配置和创建引用程序上下文中的Bean。这样做可以省去XML配置的繁琐过程。</p><p><strong>JdbcConfig</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc:mysql://localhost:3306//spring_db&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;123456&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(BookDao BookDao)</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Application启动类上使用<code>AnnotationConfigApplicationContext</code>类来创建容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> context.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中我们将SpringConfig配置类作为参数传入到<code>AnnotationConfigApplicationContext</code>类中，该类会根据接收到的参数来创建容器</p></li><li><p>通过上述代码，我们如果有其他Java配置类，只需要在配置类中写好配置信息后在SpringConfig类中的<code>@Import</code>注解上导入即可，不需要在XML中配置了。</p></li></ol><h2 id="Spring-Boot为什么可以使用基于注解的配置方式？"><a href="#Spring-Boot为什么可以使用基于注解的配置方式？" class="headerlink" title="Spring Boot为什么可以使用基于注解的配置方式？"></a>Spring Boot为什么可以使用基于注解的配置方式？</h2><p>在完成上述的Spring使用基于注解的配置方式完成配置之后，我在想SpringBoot是如何实现的呢，于是乎我去查看了一下SpringBoot的源码</p><p>在启动类中，我进入到SpringBootApplication类中，发现它没有继承任何类，于是我找到run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我本来以为un()方法中返回的<code>ConfigurableApplicationContext</code>会直接或者间接实现<code>AnnotationConfigRegistry</code>接口的，从而实现Spring Boot基于注解的配置的。于是我查看<code>ConfigurableApplicationContext</code>的类图，发现其并没有直接或间接实现上述的接口。</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520162648142.png" alt="image-20230520162648142"></p><p>然后我继续查阅源码，找到了创建创建Spring应用上下文的方法<code>createApplicationContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title function_">createApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.applicationContextFactory.create(<span class="built_in">this</span>.webApplicationType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看不出来什么端倪，于是乎我看到方法上面的注释</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520163608571.png" alt="image-20230520163608571"></p><p>这段注释的大概内容为</p><blockquote><p>这个方法使用了一个策略模式，它会根据应用程序上下文工厂（ApplicationContextFactory）来创建应用程序上下文。如果应用程序上下文工厂被设置了，它会使用这个工厂来创建应用程序上下文；否则，它会使用适当的默认实现来创建应用程序上下文。</p></blockquote><p>然后注释底部链接跳转了一个方法<code>setApplicationContextFactory</code>，我们继续追踪源码，查看该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContextFactory</span><span class="params">(ApplicationContextFactory applicationContextFactory)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.applicationContextFactory = (applicationContextFactory != <span class="literal">null</span>) ? applicationContextFactory</span><br><span class="line">         : ApplicationContextFactory.DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现<code>setApplicationContextFactory</code>方法是用来设置<strong>ApplicationContextFactory</strong>的，查看该方法的注释</p><p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520164231835.png" alt="image-20230520164231835"></p><p>我们可以发现我们在创建Spring应用程序上下文时，如果设置了ApplicationContextFactory，则根据设置的Factory来创建Spring应用程序上下文。如果没有设置，根据应用程序的类型自动选择创建相应的ApplicationContext实现类，其中包括</p><ul><li><p><strong>对于基于Servlet的Web应用程序</strong></p><p>创建<code>AnnotationConfigServletWebServerApplicationContext</code>实例。</p></li><li><p><strong>对于基于Reactive的Web应用程序</strong></p><p>创建<code>AnnotationConfigReactiveWebServerApplicationContext</code>实例。</p></li><li><p><strong>对于非Web应用程序</strong></p><p>创建<code>AnnotationConfigApplicationContext</code>实例。</p></li></ul><p>而上述三个实现类，都实现了<code>AnnotationConfigRegistry</code>接口！所以，Spring Boot可以使用基于注解的配置方式的原因就在这里！</p><h3 id="在开发中怎么设置ApplicationContextFactory"><a href="#在开发中怎么设置ApplicationContextFactory" class="headerlink" title="在开发中怎么设置ApplicationContextFactory"></a>在开发中怎么设置ApplicationContextFactory</h3><p>在Spring Boot应用程序中，可以通过继承SpringApplication类并重写其createApplicationContextFactory方法，来自定义应用程序上下文的创建过程，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">SpringApplication</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ApplicationContextFactory <span class="title function_">createApplicationContextFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> <span class="title class_">MyWebApplicationContext</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<strong>MyApplication类继承了SpringApplication类</strong>，并重写了其<strong>createApplicationContextFactory</strong>方法，返回一个lambda表达式，该表达式返回一个自定义的ApplicationContext实现类MyWebApplicationContext的实例。通过这种方式，可以在Spring Boot应用程序中自定义应用程序上下文的创建过程，满足不同的应用场景需求。</p><h2 id="AnnotationConfigRegistry接口的作用和意义（补充）"><a href="#AnnotationConfigRegistry接口的作用和意义（补充）" class="headerlink" title="AnnotationConfigRegistry接口的作用和意义（补充）"></a>AnnotationConfigRegistry接口的作用和意义（补充）</h2><p><code>AnnotationConfigRegistry</code>  接口是 Spring Framework 中的一个接口，它继承了  <code>BeanDefinitionRegistry</code>  接口，并增加了一些注册的方法。主要作用是用于注册基于注解的配置类（如  <code>@Configuration</code>  注解的类）。   </p><p>该接口的意义在于为开发者提供了一种便捷的方式，用于将基于注解的配置类注册到 Spring 容器中。在使用基于注解的配置时，开发者需要将其所在的类注册到 Spring 容器中，通常是通过  <code>AnnotationConfigApplicationContext</code>  或者其他类似的上下文来实现。而这些上下文都实现了  <code>AnnotationConfigRegistry</code>  接口，因此可以调用该接口中的方法来实现注册。  </p><p> <code>AnnotationConfigRegistry</code>  接口中的方法有：</p><ul><li><p><code>register(Class&lt;?&gt;... annotatedClasses)</code> ：注册一个或多个基于注解的配置类。 </p></li><li><p><code>scan(String... basePackages)</code> ：扫描指定的包（及其子包）下的所有 Bean 定义，并将其加入到 Spring 容器中。</p></li></ul><p>通过使用  <code>AnnotationConfigRegistry</code>  接口，开发者可以更加灵活地管理基于注解的配置类，并将其注册为 Spring Bean，从而实现更加方便、简单、快捷的配置方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Spring Boot启动时，它会通过SpringApplication类的createApplicationContext方法来创建Spring应用程序上下文。如果设置了ApplicationContextFactory，它将使用该工厂来创建Spring应用程序上下文，否则将根据应用程序的类型自动选择创建相应的ApplicationContext实现类。</p><p>Spring Boot基于注解的配置方式的实现原理是基于ApplicationContextFactory接口和AnnotationConfigRegistry接口结合实现的。ApplicationContextFactory接口用于创建Spring应用程序上下文的工厂，而AnnotationConfigRegistry接口则是用于注册基于注解的配置类的接口。这两者的结合使得Spring Boot能够使用基于注解的配置方式，从而简化了应用程序的配置过程。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们在使用Spring注册Bean时，有很多方式，其中两种常用的配置方式如下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于注解的配置&lt;/strong&gt;：使用注解来定义 bean，如  &lt;code&gt;@Component&lt;/code&gt; 、 &lt;code&gt;@Autowired&lt;/code&gt; 、 &lt;code&gt;@Configuration&lt;/code&gt;  等。这种方式相比于基于 XML 的配置更加简洁、易于阅读和维护，也是目前比较流行的一种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于 Java 配置类的配置&lt;/strong&gt;：使用 Java 类来定义 bean 和它们之间的依赖关系，如  &lt;code&gt;@Bean&lt;/code&gt; 、 &lt;code&gt;@Configuration&lt;/code&gt; 、 &lt;code&gt;@Import&lt;/code&gt;  等。这种方式也是基于注解的配置方式的一种扩展形式，它允许我们使用 Java 代码来定义 bean，从而更加灵活地控制应用程序的配置。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不难发现，上述两种配置方式的核心都是基于注解实现的，只是应用场景不同。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而我在使用基于Java配置类的配置时，发现在Spring中需要直接或间接实现&lt;code&gt;AnnotationConfigRegistry&lt;/code&gt;接口时才能应用基于注解的配置方式；于是我便开始思考：Spring Boot是怎么实现的呢？通过查阅资料以及源码后，以下是我的拙见。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="https://minster.top/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="https://minster.top/tags/Spring-Boot/"/>
    
    <category term="底层原理" scheme="https://minster.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>懒汉式单例模式下的双检锁机制的理解</title>
    <link href="https://minster.top/2023/05/26/%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%8F%8C%E6%A3%80%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://minster.top/2023/05/26/%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%8F%8C%E6%A3%80%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2023-05-26T11:39:13.000Z</published>
    <updated>2023-05-26T11:42:09.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在学习懒汉式单例模式时，发现了懒汉双检锁的实现方式，当时不是很理解，查阅资料后得出以下结论</p><span id="more"></span><h2 id="双检锁机制"><a href="#双检锁机制" class="headerlink" title="双检锁机制"></a>双检锁机制</h2><p>在多个线程同时请求一个获取一个懒汉式单例对象时，可能会导致创建多个对象的问题，为了确保只有一个对象被创建，可以使用双检锁机制。（双检锁机制不是创建两个锁实现，而是再方法内部实现两种检锁）</p><p>双检锁机制基于懒汉模式，在第一次获取单例对象时才创建它；</p><p>为了提高程序的性能，我们不在方法前使用syschronized关键字，而是在方法内部使用，同时也在方法内部实现了双重检查锁定机制。</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//第一重检锁</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//第二重检锁，只有uniqueInstance为null时才会生效</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在双检锁机制中，我们使用了synchronized关键字来创建一个锁，确保只有一个线程能进入if语句块内部。在此之前，我们首先检查uniqueInstance变量是否为null。如果为null我们才进入if语句块，获取锁，并再次检查uniqueInstance变量是否为null。这是因为在多线程环境下，可能会有多个线程同时进入第一个if语句块，如果不在此检查uniqueInstance变量是否为null，就有可能会创建多个Singleton对象，违反了单例模式的原则。</p><p>一旦我们进入了if语句块，获取了锁，就可以创建唯一的Singleton对象。其他线程尝试进入if语句块时，由于uniqueInstance变量已经不为null，所以它们不会执行if语句块内的代码，而是直接返回uniqueInstance变量的值。</p><p>在整个过程中，synchronized关键字可以确保只有一个线程能够访问if一句话内的代码，在这之前和之后，uniqueInstance变量由于是用volatile关键字进行了修饰，可以被确保它在多线程环境下的可见性，从而避免了问题的发生。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>除了单例模式之外，它还可以用于其他需要保证线程安全的场景。例如，我们可以使用双检锁机制来确保在多线程环境下只创建一个实例化某个对象的方法。<br>双检锁机制在多线程环境下会有比较好的性能表现，因为它只在第一次创建对象时使用synchronized关键字来获取锁，在之后的访问中不需要获取锁，因此避免了不必要的开销。如果在多线程环境下需要频繁创建对象，使用双检锁机制会比使用简单的synchronized关键字更加高效。<br>需要注意的是，虽然双检锁机制可以确保在多线程环境下只创建一个对象，但是如果对象的初始化操作耗时较长，可能会造成性能问题。此外，还需要注意正确使用volatile关键字，确保变量的可见性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，双检锁机制是一种比较常见的保证线程安全的方式，可以用于单例模式等需要确保只有一个对象被创建的场景。在使用双检锁机制时，需要注意并发情况下的安全性和性能问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我在学习懒汉式单例模式时，发现了懒汉双检锁的实现方式，当时不是很理解，查阅资料后得出以下结论&lt;/p&gt;</summary>
    
    
    
    <category term="Design Patterns" scheme="https://minster.top/categories/Design-Patterns/"/>
    
    
    <category term="Singleton Pattern" scheme="https://minster.top/tags/Singleton-Pattern/"/>
    
    <category term="Lazy Singleton" scheme="https://minster.top/tags/Lazy-Singleton/"/>
    
    <category term="Design Patterns" scheme="https://minster.top/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>My First Blog</title>
    <link href="https://minster.top/2023/05/26/My-First-Blog/"/>
    <id>https://minster.top/2023/05/26/My-First-Blog/</id>
    <published>2023-05-26T09:08:15.000Z</published>
    <updated>2023-05-26T11:29:16.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我一直都想搭建一个用于记录生活和学习的博客，但是碍于懒惰，一直拖延到现在。直到昨天我在浏览Github的开源项目时，我看到了<a href="https://crossoverjie.top/">杰哥</a>的个人博客，很佩服<a href="https://crossoverjie.top/">杰哥</a>的经历，所以我也决定搭建一个博客来记录自己在工作中遇到的问题以及自己学习技术的一个理解等。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我是一名Java菜鸟程序员，我在学习Java的时候一直有使用MarkDown去记录笔记。而我在之前也搭建一个基于<a href="https://minster77.github.io/">Hugo的博客</a>，上面的文章都是一些学习笔记，比较合适于初学Java的朋友们。</p><h2 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h2><p>在这个博客中，我将主要分享关于Java技术的一些知识和个人理解，也会分享一些编程技巧和实践经验。</p><p>同时我也会分享一些个人的学习方法和年度总结，希望通过这个博客能够为大家提供有价值的信息和帮助，输出一些有意义的内容！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我搭建这个博客的初衷是为了记录一下自己的程序员生涯的故事，毕竟来都来了，怎么也得留下些什么吧！其次是希望能有大神能在这个过程中指出我的错误，能让我学习到更多！</p><p>在最后，祝你好运，也祝我好运！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我一直都想搭建一个用于记录生活和学习的博客，但是碍于懒惰，一直拖延到现在。直到昨天我在浏览Github的开源项目时，我看到了&lt;a href=&quot;https://crossoverjie.top/&quot;&gt;杰哥&lt;/a&gt;的个人博客，很佩服&lt;a href=&quot;https://crossoverjie.top/&quot;&gt;杰哥&lt;/a&gt;的经历，所以我也决定搭建一个博客来记录自己在工作中遇到的问题以及自己学习技术的一个理解等。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://minster.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="LifeNode" scheme="https://minster.top/tags/LifeNode/"/>
    
  </entry>
  
</feed>
