<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Boot如何实现基于注解配置</title>
    <url>/2023/05/26/Spring-Boot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在使用Spring注册Bean时，有很多方式，其中两种常用的配置方式如下</p>
<p><strong>基于注解的配置</strong>：使用注解来定义 bean，如  <code>@Component</code> 、 <code>@Autowired</code> 、 <code>@Configuration</code>  等。这种方式相比于基于 XML 的配置更加简洁、易于阅读和维护，也是目前比较流行的一种方式。</p>
<p><strong>基于 Java 配置类的配置</strong>：使用 Java 类来定义 bean 和它们之间的依赖关系，如  <code>@Bean</code> 、 <code>@Configuration</code> 、 <code>@Import</code>  等。这种方式也是基于注解的配置方式的一种扩展形式，它允许我们使用 Java 代码来定义 bean，从而更加灵活地控制应用程序的配置。 </p>
<p><strong>不难发现，上述两种配置方式的核心都是基于注解实现的，只是应用场景不同。</strong></p>
<p>而我在使用基于Java配置类的配置时，发现在Spring中需要直接或间接实现<code>AnnotationConfigRegistry</code>接口时才能应用基于注解的配置方式；于是我便开始思考：Spring Boot是怎么实现的呢？通过查阅资料以及源码后，以下是我的拙见。</p>
<span id="more"></span>

<h2 id="Spring使用注解-Java配置类-配置Bean"><a href="#Spring使用注解-Java配置类-配置Bean" class="headerlink" title="Spring使用注解(Java配置类)配置Bean"></a>Spring使用注解(Java配置类)配置Bean</h2><p>在Spring中，我们若想简单使用基于注解的配置方式，需要完成以下几步：</p>
<ol>
<li><p>创建SpringConfig配置类作为传递参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;org.heng.dao&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring创建容器时或根据该配置类上的注解信息来配置和创建引用程序上下文中的Bean。这样做可以省去XML配置的繁琐过程。</p>
<p><strong>JdbcConfig</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc:mysql://localhost:3306//spring_db&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;123456&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(BookDao BookDao)</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Application启动类上使用<code>AnnotationConfigApplicationContext</code>类来创建容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> context.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中我们将SpringConfig配置类作为参数传入到<code>AnnotationConfigApplicationContext</code>类中，该类会根据接收到的参数来创建容器</p>
</li>
<li><p>通过上述代码，我们如果有其他Java配置类，只需要在配置类中写好配置信息后在SpringConfig类中的<code>@Import</code>注解上导入即可，不需要在XML中配置了。</p>
</li>
</ol>
<h2 id="Spring-Boot为什么可以使用基于注解的配置方式？"><a href="#Spring-Boot为什么可以使用基于注解的配置方式？" class="headerlink" title="Spring Boot为什么可以使用基于注解的配置方式？"></a>Spring Boot为什么可以使用基于注解的配置方式？</h2><p>在完成上述的Spring使用基于注解的配置方式完成配置之后，我在想SpringBoot是如何实现的呢，于是乎我去查看了一下SpringBoot的源码</p>
<p>在启动类中，我进入到SpringBootApplication类中，发现它没有继承任何类，于是我找到run方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我本来以为un()方法中返回的<code>ConfigurableApplicationContext</code>会直接或者间接实现<code>AnnotationConfigRegistry</code>接口的，从而实现Spring Boot基于注解的配置的。于是我查看<code>ConfigurableApplicationContext</code>的类图，发现其并没有直接或间接实现上述的接口。</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520162648142.png" alt="image-20230520162648142"></p>
<p>然后我继续查阅源码，找到了创建创建Spring应用上下文的方法<code>createApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title function_">createApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.applicationContextFactory.create(<span class="built_in">this</span>.webApplicationType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看不出来什么端倪，于是乎我看到方法上面的注释</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520163608571.png" alt="image-20230520163608571"></p>
<p>这段注释的大概内容为</p>
<blockquote>
<p>这个方法使用了一个策略模式，它会根据应用程序上下文工厂（ApplicationContextFactory）来创建应用程序上下文。如果应用程序上下文工厂被设置了，它会使用这个工厂来创建应用程序上下文；否则，它会使用适当的默认实现来创建应用程序上下文。</p>
</blockquote>
<p>然后注释底部链接跳转了一个方法<code>setApplicationContextFactory</code>，我们继续追踪源码，查看该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContextFactory</span><span class="params">(ApplicationContextFactory applicationContextFactory)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.applicationContextFactory = (applicationContextFactory != <span class="literal">null</span>) ? applicationContextFactory</span><br><span class="line">         : ApplicationContextFactory.DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难发现<code>setApplicationContextFactory</code>方法是用来设置<strong>ApplicationContextFactory</strong>的，查看该方法的注释</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230520164231835.png" alt="image-20230520164231835"></p>
<p>我们可以发现我们在创建Spring应用程序上下文时，如果设置了ApplicationContextFactory，则根据设置的Factory来创建Spring应用程序上下文。如果没有设置，根据应用程序的类型自动选择创建相应的ApplicationContext实现类，其中包括</p>
<ul>
<li><p><strong>对于基于Servlet的Web应用程序</strong></p>
<p>创建<code>AnnotationConfigServletWebServerApplicationContext</code>实例。</p>
</li>
<li><p><strong>对于基于Reactive的Web应用程序</strong></p>
<p>创建<code>AnnotationConfigReactiveWebServerApplicationContext</code>实例。</p>
</li>
<li><p><strong>对于非Web应用程序</strong></p>
<p>创建<code>AnnotationConfigApplicationContext</code>实例。</p>
</li>
</ul>
<p>而上述三个实现类，都实现了<code>AnnotationConfigRegistry</code>接口！所以，Spring Boot可以使用基于注解的配置方式的原因就在这里！</p>
<h3 id="在开发中怎么设置ApplicationContextFactory"><a href="#在开发中怎么设置ApplicationContextFactory" class="headerlink" title="在开发中怎么设置ApplicationContextFactory"></a>在开发中怎么设置ApplicationContextFactory</h3><p>在Spring Boot应用程序中，可以通过继承SpringApplication类并重写其createApplicationContextFactory方法，来自定义应用程序上下文的创建过程，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">SpringApplication</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ApplicationContextFactory <span class="title function_">createApplicationContextFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> <span class="title class_">MyWebApplicationContext</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<strong>MyApplication类继承了SpringApplication类</strong>，并重写了其<strong>createApplicationContextFactory</strong>方法，返回一个lambda表达式，该表达式返回一个自定义的ApplicationContext实现类MyWebApplicationContext的实例。通过这种方式，可以在Spring Boot应用程序中自定义应用程序上下文的创建过程，满足不同的应用场景需求。</p>
<h2 id="AnnotationConfigRegistry接口的作用和意义（补充）"><a href="#AnnotationConfigRegistry接口的作用和意义（补充）" class="headerlink" title="AnnotationConfigRegistry接口的作用和意义（补充）"></a>AnnotationConfigRegistry接口的作用和意义（补充）</h2><p><code>AnnotationConfigRegistry</code>  接口是 Spring Framework 中的一个接口，它继承了  <code>BeanDefinitionRegistry</code>  接口，并增加了一些注册的方法。主要作用是用于注册基于注解的配置类（如  <code>@Configuration</code>  注解的类）。   </p>
<p>该接口的意义在于为开发者提供了一种便捷的方式，用于将基于注解的配置类注册到 Spring 容器中。在使用基于注解的配置时，开发者需要将其所在的类注册到 Spring 容器中，通常是通过  <code>AnnotationConfigApplicationContext</code>  或者其他类似的上下文来实现。而这些上下文都实现了  <code>AnnotationConfigRegistry</code>  接口，因此可以调用该接口中的方法来实现注册。  </p>
<p> <code>AnnotationConfigRegistry</code>  接口中的方法有：</p>
<ul>
<li><p><code>register(Class&lt;?&gt;... annotatedClasses)</code> ：注册一个或多个基于注解的配置类。 </p>
</li>
<li><p><code>scan(String... basePackages)</code> ：扫描指定的包（及其子包）下的所有 Bean 定义，并将其加入到 Spring 容器中。</p>
</li>
</ul>
<p>通过使用  <code>AnnotationConfigRegistry</code>  接口，开发者可以更加灵活地管理基于注解的配置类，并将其注册为 Spring Bean，从而实现更加方便、简单、快捷的配置方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Spring Boot启动时，它会通过SpringApplication类的createApplicationContext方法来创建Spring应用程序上下文。如果设置了ApplicationContextFactory，它将使用该工厂来创建Spring应用程序上下文，否则将根据应用程序的类型自动选择创建相应的ApplicationContext实现类。</p>
<p>Spring Boot基于注解的配置方式的实现原理是基于ApplicationContextFactory接口和AnnotationConfigRegistry接口结合实现的。ApplicationContextFactory接口用于创建Spring应用程序上下文的工厂，而AnnotationConfigRegistry接口则是用于注册基于注解的配置类的接口。这两者的结合使得Spring Boot能够使用基于注解的配置方式，从而简化了应用程序的配置过程。</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程编程中的等待和休眠：wait() 和 sleep() 方法解析</title>
    <url>/2023/05/27/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E4%BC%91%E7%9C%A0%EF%BC%9Await-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/640.png" alt="640"></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在Java多线程中，线程的状态如上图所示（图来自<a href="https://javaguide.cn/">JavaGuide</a>），可以发现，当前线程调用<code>wait(long time)</code>方法或者执行<code>Thread.sleep(long time)</code>方法都会进入到一个<code>TIMED_WAITING</code>的状态。那么，这个状态下的线程的锁资源是怎么样的呢？</p>
<span id="more"></span>

<h2 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h2><p>在多线程环境下，如果当前线程调用了wait()方法，那么该方法会进入到<code>WAITING</code>状态，并释放它所持有的锁，等待其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法来唤醒它。如果没有其唤醒操作，当前线程会处于一个无限等待的状态。</p>
<p>如果当前线程在调用的是<code>wait(long time)</code>方法时，线程会进入到一个<code>TIMED_WAITING</code>状态，同时会释放锁资源，等待其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法来唤醒它，或者等待指定的时间过期后自动唤醒。在等待期间，该线程不会占用 CPU 资源，因此其他线程可以执行。</p>
<p>代码演示：</p>
<p><strong>WaitingThread类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WaitingThread</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;获取到了锁资源&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待2秒钟，释放锁资源</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() +<span class="string">&quot;线程等待2s.....释放锁&quot;</span>);</span><br><span class="line">                lock.wait(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 等待时间过去，唤醒，尝试重新获取锁资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>WaitingTest类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">WaitingThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitingThread</span>(lock);</span><br><span class="line">        <span class="type">WaitingThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitingThread</span>(lock);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示结果</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230527102116952.png" alt="image-20230527102116952"></p>
<p>上述代码中，我们创建了两个线程，并将它们传递给同一个锁对象。在<code>run()</code>方法中，线程首先使用<code>synchronized</code>关键字获取锁对象，然后调用<code>wait(long time)</code>方法进入<code>TIMED_WAITING</code>状态，等待2秒钟后会自动唤醒，此时，锁对象已经被释放，线程需要重新获取锁才能继续执行。可以看到，在线程重新获取锁之后，它就可以继续执行对共享数据的操作了。</p>
<h2 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h2><p>当线程调用<code>sleep(long time)</code>方法时，该线程也会进入到<code>TIMED_WAITING</code>状态，但是当前线程对象并不会释放锁资源，因此其他线程对象也无法获取到锁资源，会进入阻塞状态。</p>
<p>当指定的休眠时间过期之后，当前线程会主动唤醒，并且该线程仍然持有锁资源，可以继续执行。</p>
<p>代码演示：</p>
<p><strong>SleepingThread类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SleepingThread</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;获取到了锁资源&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() +<span class="string">&quot;线程休眠2s.....仍持有锁&quot;</span>);</span><br><span class="line">                <span class="comment">// 线程休眠2秒钟，进入TIMED_WAITING状态</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 休眠时间过去，自动唤醒，继续执行&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SleepingTest类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepingTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">SleepingThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepingThread</span>(lock);</span><br><span class="line">        <span class="type">SleepingThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepingThread</span>(lock);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230527105237869.png" alt="image-20230527105237869"></p>
<p>在上面的代码中，我们创建了两个线程，并将它们传递给同一个锁对象。在线程的run()方法中，我们首先使用synchronized关键字来获取锁对象，然后让线程进入TIMED_WAITING状态。在这里，线程会休眠2秒钟，然后再输出一条消息。 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当线程调用<code>wait()</code>方法时，线程会进入一个<code>WAITING</code>状态，并且释放锁资源，直至被唤醒才会进入到就绪状态，竞争锁资源。</p>
<p>当线程调用<code>wait(long time)</code>方法时（指定一个等待时间），线程会进入到一个<code>TIMED_WAITING</code>状态，同时释放锁资源，只有当线程被通知或者等待时间结束后才会重新去获取锁资源。</p>
<p>当线程调用的是<code>sleep(long time)</code>方法，线程虽然也会进入到一个<code>TIMED_WAITING</code>状态，但是不会释放锁资源，其他线程会处于阻塞状态直至当前线程释放锁资源</p>
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>My First Blog</title>
    <url>/2023/05/26/My-First-Blog/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我一直都想搭建一个用于记录生活和学习的博客，但是碍于懒惰，一直拖延到现在。直到昨天我在浏览Github的开源项目时，我看到了<a href="https://crossoverjie.top/">杰哥</a>的个人博客，很佩服<a href="https://crossoverjie.top/">杰哥</a>的经历，所以我也决定搭建一个博客来记录自己在工作中遇到的问题以及自己学习技术的一个理解等。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我是一名Java菜鸟程序员，我在学习Java的时候一直有使用MarkDown去记录笔记。而我在之前也搭建一个基于<a href="https://minster77.github.io/">Hugo的博客</a>，上面的文章都是一些学习笔记，比较合适于初学Java的朋友们。</p>
<h2 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h2><p>在这个博客中，我将主要分享关于Java技术的一些知识和个人理解，也会分享一些编程技巧和实践经验。</p>
<p>同时我也会分享一些个人的学习方法和年度总结，希望通过这个博客能够为大家提供有价值的信息和帮助，输出一些有意义的内容！</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我搭建这个博客的初衷是为了记录一下自己的程序员生涯的故事，毕竟来都来了，怎么也得留下些什么吧！其次是希望能有大神能在这个过程中指出我的错误，能让我学习到更多！</p>
<p>在最后，祝你好运，也祝我好运！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>LifeNode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试题汇总（持续更新！）</title>
    <url>/2023/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/</url>
    <content><![CDATA[<p><img src="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/moon-4919501_1920.jpg" alt="moon-4919501_1920"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下是我对Java高频面试题的一个总结，后面我会持续更新，希望对你有所帮助。<br>当然，如果有哪道题目我理解错误了，或者是你有更好的见解，非常欢迎你在评论区中留下宝贵的意见！</p>
<span id="more"></span>

<h2 id="JavaSE基础"><a href="#JavaSE基础" class="headerlink" title="JavaSE基础"></a>JavaSE基础</h2><h3 id="1-JDK、JRE、JVM分别是什么，有什么区别"><a href="#1-JDK、JRE、JVM分别是什么，有什么区别" class="headerlink" title="1. JDK、JRE、JVM分别是什么，有什么区别"></a>1. JDK、JRE、JVM分别是什么，有什么区别</h3><ul>
<li>**JDK(Java Development Kit)**是Java标准开发包，它提供了编译、运行Java所需要的各种工具和资源，包括Java编译器、Java运行环境、以及常用的类库等</li>
<li><strong>JRE(Java Runtime Enviroment)：</strong>Java的运行环境，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件</li>
<li><strong>JVM(Java Virtual Mechinal)：</strong>Java虚拟机，是JRE的一部分，它用于编译执行字节码文件，是可运行Java字节码文件的虚拟计算机</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>JDK用于开发，JRE用于运行Java程序，如果你只是为了运行一下Java程序的话，安装JRE即可，但是要开发Java程序的话，必须要安装JDK</li>
<li>JDK包含JRE，JDK、JRE中都有JVM</li>
<li>JVM是Java实现跨平台性的核心，它具有平台独立性能，它拥有类加载以及垃圾回收等机制。</li>
</ul>
<h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2. 重载和重写的区别"></a>2. 重载和重写的区别</h3><ul>
<li>重载发生在同一类中，当同一类中的两个或多个方法，方法名相同，参数列表不同，就构成了重载</li>
<li>重写发生在类的父子关系中，当一个类继承另一个类或者实现了某一个接口，就可以重写该类的非私有方法，从而实现功能的拓展；重写要求方法名、参数列表相同</li>
</ul>
<h3 id="3-x3D-x3D-和equals的区别是什么"><a href="#3-x3D-x3D-和equals的区别是什么" class="headerlink" title="3. &#x3D;&#x3D;和equals的区别是什么"></a>3. &#x3D;&#x3D;和equals的区别是什么</h3><p>&#x3D;&#x3D;对于基本类型来说就是值的比较，对于引用类型来说就是引用的比较。</p>
<p>而equals默认情况下是引用的比较，只是因为有很多类都重写了equals方法，比如String、Integer等类都把它变成了值的比较，所以一般情况下，equals是比较的是值是否相等，也就是值比较。</p>
<h3 id="4-什么是hashCode"><a href="#4-什么是hashCode" class="headerlink" title="4. 什么是hashCode()"></a>4. 什么是hashCode()</h3><p>hashCode()方法作用获取一个哈希码，即散列码，它实际上是一个int整数。哈希码可以确定该对象在哈希表中的索引位置。hashCode的定义在Object类中，所以java中任何类都包含了hashCode函数。</p>
<p>散列表其实就是用来存放键值对（key-value），我们可以通过key快速检索出对应的value。其中就使用了散列码。</p>
<h3 id="5-hashCode与equals有什么关系"><a href="#5-hashCode与equals有什么关系" class="headerlink" title="5. hashCode与equals有什么关系"></a>5. hashCode与equals有什么关系</h3><p>要搞清楚他们之间的关系，我们可以从hash表的结构出发，其实hash表是一个数组+链表或红黑树的结构，Java的集合容器就有使用到这种数据结构的，然后在我们要存储对象到容器时可以先通过hashCode方法返回了一个hash值，这个hash与数组长度取余之后就能获取到该对象的存放在数组结构的一个对应的下标，当两个对象有相同的hash值的时候，说明存放的数组下标是一样的，那么此时我们就需要通过equals方法判断这两个对象是不是相同的对象，如果是相同的对象会直接将原来的对象覆盖掉，如果不是则插入在链表中，所以我们可以得下面结论：</p>
<ol>
<li>当两个对象相同时，它们的hash值也相同，它们之间的互相调用equals方法结果为true</li>
<li>当两个对象有相同的hashCode的值，那么它们也不一定相等。</li>
</ol>
<h3 id="6-为什么重写equals方法必须重写hashCode方法呢"><a href="#6-为什么重写equals方法必须重写hashCode方法呢" class="headerlink" title="6. 为什么重写equals方法必须重写hashCode方法呢"></a>6. 为什么重写equals方法必须重写hashCode方法呢</h3><p>首先在java的一些容器中，是不允许存放两个相同的对象的，如果对象相同会覆盖掉，而在散列表中我们存放对象时，会首先判断两个对象的hash值是否相同，如果相同再通过equals方法来判断是否为相同对象，如果是相同对象就会在散列表中覆盖掉，否则就插入到相关链表中，那么如果我们只重写了equals方法，而不重写hashCode方法，那么那么相同对象的值就无法覆盖了。</p>
<h3 id="7-面向对象的特征"><a href="#7-面向对象的特征" class="headerlink" title="7. 面向对象的特征"></a>7. 面向对象的特征</h3><p>面向对象主要有三大特征：封装性、继承、多态</p>
<ol>
<li><p>封装性：封装性指的是我们在定义对象时，尽可能的把对象状态信息隐藏起来，只提供有限的接口的方法给外界交互使用，从而避免外界对对象内部属性进行破坏。</p>
</li>
<li><p>继承：继承其实就是一种能力，当一个类A继承了另外一个类B时，A类就可以使用B类公开的所有的属性和方法，并且可以在不修改父类的前提下对其功能进行拓展。当然，如果B类存在用private修饰的属性或方法，A类是无法使用的，这就是封装性的体现。</p>
</li>
<li><p>多态：多态是指同一对象的不同形式的展现，比如说我们到宠物店跟店说“我要一只宠物”，那么店员就可以给我一只小猫、小狗、或者小蜥蜴等等，那么此时我们所说的宠物对象就是多态一种展现了。</p>
<blockquote>
<p>多态是怎么形成的</p>
<p>其实java的引用变量有两种类型，一种是编译时类型、一种是运行时类型，而编译类型由引用变量在定义时的声明所决定，运行时类型由实际赋值给引用变量的类型所决定，当编译时类型与运行时类型不一样时，就会产生所谓的多态</p>
</blockquote>
</li>
</ol>
<h3 id="8-接口和抽象类的共同点和区别"><a href="#8-接口和抽象类的共同点和区别" class="headerlink" title="8. 接口和抽象类的共同点和区别"></a>8. 接口和抽象类的共同点和区别</h3><p><strong>共同点：</strong></p>
<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现的方法（在JDK1.8之后才可以用default定义接口中的默认方法的）</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>接口用于对类的行为进行约束，一个类实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系</li>
<li>一个类只能继承一个类，但是可以实现多个接口</li>
<li>抽象类中有构造方法，接口中没有构造方法</li>
<li>抽象类中的成员变量默认是default，可以被子类重新定义赋值，接口中的成员变量是常量，不能被修改且必须要有初始值</li>
</ul>
<h3 id="9-java中操作字符串的类有哪些？他们之间有什么区别"><a href="#9-java中操作字符串的类有哪些？他们之间有什么区别" class="headerlink" title="9. java中操作字符串的类有哪些？他们之间有什么区别"></a>9. java中操作字符串的类有哪些？他们之间有什么区别</h3><p>操作字符串的类有主要有String、StringBuffer、StringBuilder三种。</p>
<p>首先String、StringBuffer底层都是char数组，然后因为String类的char数组是由Final修饰的，所以String类的长度是不会变化，每当我们新建一个String类时都需要new一个对象，让指针指向新的对象。而StringBuffer维护的char数组以及在JDK1.5之后出现的StringBuilder维护的byte数组都没有使用Final修饰，所以他们存放的字符串内容是可变的。而且存在扩容机制。</p>
<blockquote>
<p>扩容机制：</p>
<p>因为他们都是继承了AbstractStirngBuilder类，而该类有一个方法会检测当前字符串类的char的容量是否足够来存放新的字符串，如果不能，进行扩容</p>
<p>扩容的逻辑就是new一个相同大小的char+2然后调用数组的copyOf方法将两个char数组合成一个新的。</p>
</blockquote>
<p>然后StringBuffer和StringBuilder之间是有线程是否安全的区别的。</p>
<p>StringBuffer因为加了同步锁synchronized所以线程安全，因为synchronized同步锁会有一个获取锁和释放锁的操作，所以StringBuffer的效率更低。</p>
<blockquote>
<p>为什么StringBuffer加了锁就效率更低呢？</p>
<p>因为synchronized锁其实是会有四种状态的升级和优化的。分别是：无锁、偏向锁、轻量级锁、重量级锁四种</p>
<p>偏向锁就是当一段同步代码或者是资源被同一个线程多次访问的时候，那么该线程就会自动获取锁，降低获取锁的代价。</p>
<p>而当锁是偏向锁时，如果有其他线程访问该锁时，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式来获取锁，不会阻塞，提高性能。</p>
<p>当前锁是轻量级锁时，另外一个线程不会一直自旋，当其自旋到一定次数后，轻量级锁会升级为重量级锁，其他线程进入阻塞状态，性能降低。因为线程自旋需要消耗cpu性能，所以自旋到一定次数后轻量级锁会膨胀成重量级锁。</p>
</blockquote>
<p>StringBuilde因为没有加入锁，所以效率更高，适合高并发时候使用。</p>
<h3 id="10-深克隆与浅克隆的区别（深拷贝和浅拷贝）"><a href="#10-深克隆与浅克隆的区别（深拷贝和浅拷贝）" class="headerlink" title="10. 深克隆与浅克隆的区别（深拷贝和浅拷贝）"></a>10. 深克隆与浅克隆的区别（深拷贝和浅拷贝）</h3><p>浅克隆（默认）</p>
<ul>
<li><p>拷贝出的新对象，与原对象中的数据一模一样（引用类型拷贝的是地址）</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230509175906576.png" alt="image-20230509175906576"></p>
</li>
</ul>
<p>深克隆（避免新对象修改其他对象内容时，影响原对象的对象内容）</p>
<ul>
<li><p>对象中基本类型的数据直接拷贝</p>
</li>
<li><p>对象中的字符串数据拷贝的还是地址</p>
</li>
<li><p>对象中还包含的其他对象，不会拷贝地址，会创建新对象</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230509175922784.png" alt="image-20230509175922784"></p>
</li>
</ul>
<h3 id="11-Java-是编译执行的语言，还是解释执行的语言"><a href="#11-Java-是编译执行的语言，还是解释执行的语言" class="headerlink" title="11. Java 是编译执行的语言，还是解释执行的语言?"></a>11. Java 是编译执行的语言，还是解释执行的语言?</h3><p><strong>Java即是编译型的，也是解释型语言，总的来说Java更接近解释型语言</strong></p>
<ul>
<li>可以说它是编译型的。因为所有的Java代码都是要编译的，Java不经过编译就什么用都没有。同时围绕JVM的效率问题，会涉及一些如JIT、AOT等优化技术，例如JIT技术，会将热点代码编异成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码</li>
<li>可以说它是解释型的。因为Java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的。</li>
</ul>
<h2 id="JavaSE进阶-集合"><a href="#JavaSE进阶-集合" class="headerlink" title="JavaSE进阶-集合"></a>JavaSE进阶-集合</h2><h3 id="1-Array-和-ArrayList-有什么区别？"><a href="#1-Array-和-ArrayList-有什么区别？" class="headerlink" title="1. Array 和 ArrayList 有什么区别？"></a>1. Array 和 ArrayList 有什么区别？</h3><ul>
<li><p>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</p>
</li>
<li><p>Array 大小是固定的，ArrayList 的大小是动态变化的。</p>
</li>
<li><p>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</p>
</li>
</ul>
<h3 id="2-常见的集合类有哪些"><a href="#2-常见的集合类有哪些" class="headerlink" title="2. 常见的集合类有哪些"></a>2. 常见的集合类有哪些</h3><p>Java的集合容器有单列集合和双列集合两种，单列集合指的是Collection接口下的派生类：List、Set、Queue（JDK5 新增的队列）；双列集合则是Map接口下的派生类。</p>
<blockquote>
<p><strong>注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口</strong>。</p>
</blockquote>
<p>在集合体系中，List集合代表了可重复集合，他们是有索引的；Set集合代表无序不可重复的集合，只能根据元素本身来访问（无索引）。Queue集合是一个队列集合。</p>
<p>Map集合时可以存放key-value键值对的集合，他的key是不可重复的，value是可以重复的。</p>
<p>List集合常用的有ArrayList、LinkedList</p>
<p>Set集合中常用的有HashSet、TreeSet</p>
<p>Queue集合常用的有ArrayQueue</p>
<p>Map集合中常用的有HashMap、TreeMap、ConcurrentHashMap</p>
<h3 id="3-ArrayList与LinkedList的异同"><a href="#3-ArrayList与LinkedList的异同" class="headerlink" title="3. ArrayList与LinkedList的异同"></a>3. ArrayList与LinkedList的异同</h3><ul>
<li><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> Arraylist 底层使用的是Object数组（动态数组）；LinkedList 底层使用的是双向循环链表数据结构；</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。  <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li>
<li><strong>是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h3 id="4-ArrayList的扩容机制"><a href="#4-ArrayList的扩容机制" class="headerlink" title="4. ArrayList的扩容机制"></a>4. ArrayList的扩容机制</h3><p>因为ArrayList底层维护的是一个数组，所以ArrayList的扩容机制是基于Arrays.copyOf方法实现的。</p>
<p>当我们用默认的无参构造方法创建ArrayList集合的时候，ArrayList的初始长度为0。<strong>当我们向集合添加第一个元素的时候，ArrayList集合的长度为10；</strong></p>
<p>当我们向集合添加元素时都会有一个判断，就是查看当前容量是否可以继续添加元素，<strong>如果集合的容量够就添加到集合中，如果容量不够则触发扩容机制，扩容的大小为原集合容量的1.5倍。</strong></p>
<blockquote>
<p>1.5倍是因为新的集合容量为<strong>原集合容量</strong>与<strong>其右移一位之后</strong>的和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当我们使用有参构造去创建ArrayList集合时，扩容机制也与上面的一样，不过需要注意的是他扩容的大小为你传进去的参数的1.5倍</p>
<h3 id="5-HashMap的底层数据结构是什么"><a href="#5-HashMap的底层数据结构是什么" class="headerlink" title="5. HashMap的底层数据结构是什么"></a>5. HashMap的底层数据结构是什么</h3><p><strong>在JDK1.8以前，HashMap底层维护的是一个”数组+链表“的结构</strong>，数组是HashMap的主体，链表是为了解决哈希冲突而存在的。</p>
<p><strong>在JDK1.8之后，HashMap的底层变成了”数组+链表+红黑树“的数据结构了</strong>。</p>
<p>在JDK1.8之前，如果我们使用HashMap存放大量数据时，会使HashMap的链表结构变得非常长，这样会导致我们的查询效率变慢，严重的影响了HashMap的性能。</p>
<p>因此，在JDK1.8之后对数据结构做了进一步的优化，引进了红黑树，链表和红黑树会在达到一定条件时会进行转换：</p>
<ul>
<li>当链表长度达到了8，且数组的长度达到64时才会发生转换</li>
<li>因为在触发树化机制的时候，HashMap的底层会进行判断，如果当前数组的长度没有达到64，会优先对数组进行扩容，而不是进行树化，这样可以节省查询时间。</li>
</ul>
<blockquote>
<p>面试官也许还会问：</p>
<p>如你上面所说，为什么HashMap在JDK8之后不直接采取数组+红黑树的结构，而是使用数组+链表+红黑树的数据结构呢？</p>
<p>首先因为红黑树会在每次添加元素时进行一个左旋、右旋、变色等操作来保持平衡，链表则不会，因此链表插入数据的效率会比红黑树快。</p>
<p>所以在数据量很少的时候，链表的效率会比红黑树高；</p>
<p>但是当数据量多了之后，因为红黑树搜索的时间复杂度为Olog(n)，而链表的是O(n)，因此选择红黑树可以增加的查询效率，但是新增的效率变慢了。</p>
<p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p>
</blockquote>
<h3 id="6-HashMap的扩容机制"><a href="#6-HashMap的扩容机制" class="headerlink" title="6. HashMap的扩容机制"></a>6. HashMap的扩容机制</h3><ul>
<li>HashMap底层维护了Node类型的数组table，默认为null，链表与红黑树是为了解决哈希冲突而存在的。</li>
<li>当创建对象时，将加载因子(loadfactor)初始化为0.75；</li>
<li>当添加key-value时，通过<strong>key</strong>的hash值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换<strong>value</strong>；<strong>如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。</strong></li>
<li>第一次添加时，会将需要扩容的table容量扩容到16，临界值(threshold)为12</li>
<li>如果需要再次扩容，会将需要扩容的table容量扩容到原来的2倍（32），临界值为原来的2倍（24） 依次类推。</li>
<li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），<strong>否则任然采用数组扩容机制</strong></li>
</ul>
<blockquote>
<p>HashSet的底层就是HashMap，唯一区别是HashSet的value值为一个常量，所以当同一hash值中的key相同时，会添加失败；而HashMap会替换掉key对应的value。</p>
</blockquote>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-描述一下jvm加载-class文件的过程吗？（类加载过程）"><a href="#1-描述一下jvm加载-class文件的过程吗？（类加载过程）" class="headerlink" title="1. 描述一下jvm加载.class文件的过程吗？（类加载过程）"></a>1. 描述一下jvm加载.class文件的过程吗？（类加载过程）</h3><p>因为Class文件需要加载到虚拟机中才能运行和使用，所以就有了类加载的过程</p>
<p>类在JVM中的生命周期主要有：<strong>加载、连接、初始化、使用、卸载五部分组成。</strong></p>
<p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong></p>
<p><strong>加载过程</strong>指的是JVM将经过javac编译的字节码文件加载到内存当中的过程。</p>
<p><strong>连接阶段分别由验证、准备、解析三个阶段组成。</strong></p>
<ul>
<li><p>验证阶段会对字节码文件的格式、元数据格式等进行验证，确保字节码文件没有损害JVM的内容，是保护JVM的一个阶段。</p>
</li>
<li><p>准备阶段会为class文件的静态变量分配内存，并赋予初始值，此时的初始值指的是0</p>
</li>
<li><p>解析阶段会将符号引用转换为直接引用</p>
</li>
</ul>
<p><strong>连接阶段完成之后会到初始化阶段</strong>，该阶段开始执行java中定义的代码，为变量赋予真正的初始值，指的是代码中程序员想要赋的值</p>
<blockquote>
<p>类加载是由类加载器完成的，类加载器分别有：启动类加载器、扩展类加载器、系统类加载器、自定义加载器等</p>
</blockquote>
<h3 id="2-什么是双亲委派模型，为什么要使用"><a href="#2-什么是双亲委派模型，为什么要使用" class="headerlink" title="2. 什么是双亲委派模型，为什么要使用"></a>2. 什么是双亲委派模型，为什么要使用</h3><p>双亲委派原则指的是类加载器在接收到类加载的一个请求时，不会立刻加载，会先委派该类的父类加载器去加载，只有当父类加载器在他的搜索范围内没有搜索到该类时，子类的加载器才会对该类进行加载。</p>
<p>这样做可以防止内存中出现多个相同的字节码；因为如果没有双亲委派模型的话，那么用户自己再定义了一个java.lang.String的类，就无法保证类的唯一性了。</p>
<h3 id="3-可达性算法"><a href="#3-可达性算法" class="headerlink" title="3. 可达性算法"></a>3. 可达性算法</h3><p>可达性算法的逻辑就是，在以一个GC Root为根节点的对象作为起点开始搜索，能遍历到的对象，也就是说该对象的引用还存在，就是可达的对象。而不能遍历到的对象，说明对象的引用已经不存在了，所以是不可达对象，也就是被GC回收的对象。</p>
<p>可以作为GC Roots的对象有哪些呢？</p>
<blockquote>
<ul>
<li>在栈帧的局部变量引用的对象</li>
<li>在本地方法区JNI引用的对象</li>
<li>在方法区（元空间）的静态变量或常量引用的对象</li>
</ul>
</blockquote>
<h3 id="4-你能说一下垃圾回收机制吗？"><a href="#4-你能说一下垃圾回收机制吗？" class="headerlink" title="4. 你能说一下垃圾回收机制吗？"></a>4. 你能说一下垃圾回收机制吗？</h3><p>首先我们要理解JVM的一个内存模型，因为JVM的内存模型是由栈、本地方法区、程序计算器、元空间、堆这5部分组成。</p>
<p>然后因为我们创建的对象，是存放在堆的，然后当我们一段代码执行完成之后，只有存放在栈的局部变量可以自动删除，而存放在堆的对象仍然存在，这时候就需要垃圾回收机制来回收堆的内存了。</p>
<p>然后垃圾回收的算法主要有三种</p>
<ul>
<li><p>标记清理法：就是先遍历一次堆里面的所有对象，把要删除的对象标记，然后再遍历一次，把第一次遍历标记的对象都删除掉，就完成了，但是有一个缺点，就是会存在内存碎片</p>
<blockquote>
<p>什么是内存碎片？</p>
<p>内存碎片我是这样理解的，比如我们在堆中的两个不相连的位置中分别有一个1KB大小的对象，然后我们通过标记清理法把他们删除了，那么堆中就挤出来2KB的内存空间了，如果我们这个时候新建一个2KB大小的对象，是无法存放在堆中的，因为上面清理出来的2KB空间不是连续的，所以就会产生内存碎片问题</p>
</blockquote>
</li>
<li><p>标记-整理法：他跟标记清理法原理是差不多的，但是他会在删除对象后，把后面的对象往前推，这样子就解决了内存碎片的问题，但是由于每删一个对象都需要移动一次后面的对象，会导致性能会有所降低，而且这样做的代价太大了。</p>
</li>
</ul>
<ul>
<li>复制法：复制法会把内存分成两块大小一样的内存，首先把其中一块内存通过GC ROOT标记，再把标记过后存活的对象复制到另一块内存中去，最后把存放垃圾对象的内存清理掉，缺点就是需要双倍的内存，太消耗内存了。</li>
</ul>
<p>所以GC综合了上面三个算法，创建了一个分代收集的算法出来</p>
<p>分代收集算法就是先把内存分为young区跟old区两块，分别代表年轻代和老年代。</p>
<p>然后再young区那一块内存中，又分为E空间、S0空间、S1空间；</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/hotspot-heap-structure.png" alt="hotspot-heap-structure"></p>
<p><strong>简单的概括就是：</strong></p>
<p>大部分情况，对象都会首先在 Eden 区域分配。</p>
<p>然后在一次GC之后，E空间和S0空间存活的对象会移到S1空间去，再回收E空间和S0空间的垃圾对象</p>
<p>在下一次GC完成后，E空间和S1空间存活的对象会移到S0空间去，然后回收E空间和S1空间的垃圾对象</p>
<p>每一次被标记存活的对象，都会有一个类似于age的变量，都会加一，当age&gt;一个阈值时，他会晋升到老年代去。需要注意的是，大对象（需要大量内存的对象，例如集合、数组）会直接存放在老年代</p>
<blockquote>
<p>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置），<strong>取这个年龄和 MaxTenuringThreshold 中更小的一个值</strong>，作为新的晋升年龄阈值”</p>
</blockquote>
<p><strong>补充：垃圾回收机制中会触发的几种GC方式的区别以及详解</strong></p>
<blockquote>
<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
</blockquote>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/rf-hotspot-vm-gc.png" alt="rf-hotspot-vm-gc"></p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="1-你能说一下创建线程的方法有哪些吗"><a href="#1-你能说一下创建线程的方法有哪些吗" class="headerlink" title="1. 你能说一下创建线程的方法有哪些吗"></a>1. 你能说一下创建线程的方法有哪些吗</h3><p>创建线程的方式有四种，分别是</p>
<ol>
<li>继承Thread类并重写run方法创建线程，虽然实现简单，但是不可以继承其他类</li>
<li>实现Runnable接口并重写run方法方法。避免了单继承的局限性，编程更加灵活，很好的实现了解耦合</li>
<li>实现Callable接口并重写call方法，创建线程，通过该方法可以获取线程执行结果的返回值，并且可以抛出异常。</li>
<li>通过线程池创建。（使用java.util.concurrent.Executor接口）</li>
</ol>
<h3 id="2-Runnable接口和Callable接口的区别"><a href="#2-Runnable接口和Callable接口的区别" class="headerlink" title="2. Runnable接口和Callable接口的区别"></a>2. Runnable接口和Callable接口的区别</h3><p>Runnable接口的run方法没有返回值，Callable接口的call方法有返回值，并且支持泛型</p>
<p>Runnable接口的run方法只能抛出运行时异常，且其他异常只能在内部处理异常，而Callable接口可以抛出所有的异常，以及在内部处理。</p>
<h3 id="3-sleep方法和yield方法有什么区别"><a href="#3-sleep方法和yield方法有什么区别" class="headerlink" title="3. sleep方法和yield方法有什么区别"></a>3. sleep方法和yield方法有什么区别</h3><ol>
<li>sleep方法不会考虑优先级问题，然后优先级低的线程也能拿到CPU资源，而yield方法会考虑优先级的问题，调用该方法只会给同等优先级或高优先级的线程CPU资源</li>
<li>Sleep方法有声明InterruptedExcetion异常抛出，yield是没有异常抛出的</li>
<li>sleep方法执行后线程会进入阻塞状态，而yield方法执行后会进入就绪状态</li>
<li>sleep比yield具有更好的移植性</li>
</ol>
<h3 id="4-线程中sleep和wait方法有什么区别"><a href="#4-线程中sleep和wait方法有什么区别" class="headerlink" title="4. 线程中sleep和wait方法有什么区别"></a>4. 线程中sleep和wait方法有什么区别</h3><p>首先sleep()方法是线程类的一个静态方法，调用该方法可以让线程暂停指定的一段时间，暂停的线程会把CPU资源让出来给其他线程使用，但是对象的锁依然保存，所以当暂停时间到后，该线程会自动恢复到就绪状态。而wait方法是Object类一个方法，调用对象的wait方法可以让当前线程放弃对象的锁，即进入暂停状态，然后当前线程会进入到对象的等待池，知道对象调用notice方法时才能唤醒等待池中的线程进入等锁池，如果线程重新获得对象的锁就可以进入到就绪状态。</p>
<h3 id="5-线程的run方法和start方法有什么区别"><a href="#5-线程的run方法和start方法有什么区别" class="headerlink" title="5. 线程的run方法和start方法有什么区别"></a>5. 线程的run方法和start方法有什么区别</h3><p>调用start()方法可以让启动一个线程，并进入到就绪状态，而调用run()方法只是调用了一个对象的方法，并没有开启新的线程。</p>
<p>就比如说你在主线程中调用了run()方法，那么你要等run()方法执行完之后才会继续执行下面的代码，而调用了start()方法，会开启一条线程去执行Thread对象中对应的run方法，即使run方法没有执行完，主线程中还会执行start()下面的代码。</p>
<h3 id="6-线程有哪几种状态？（线程的生命周期）"><a href="#6-线程有哪几种状态？（线程的生命周期）" class="headerlink" title="6. 线程有哪几种状态？（线程的生命周期）"></a>6. 线程有哪几种状态？（线程的生命周期）</h3><p>Java线程在运行的生命周期中的指定时刻只可能处于下面6中不同状态的其中一个状态</p>
<ul>
<li><strong>NEW</strong>：线程初始状态，线程被创建出来但没有被调用start()方法的状态</li>
<li><strong>RUNNABLE</strong>：运行状态，线程被调用了start()等待运行的状态。<code>RUNNABLE</code>状态细分一下会有一个<code>RUNNING</code>状态以及<code>READY</code>状态的</li>
<li><strong>BLOCKED</strong>：阻塞状态，需要等待锁释放。</li>
<li><strong>WAITING</strong>：等待状态，调用wait方法后的一个状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）</li>
<li><strong>TIME_WAITING</strong>：超时等待状态，调用wait方法并且传入了一个时间之后的状态，可以在指定的时间后自行返回而不是想WAITING那样一直等待。</li>
<li><strong>TERMINATED</strong>：终止状态，表示该线程已经运行完毕</li>
</ul>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间转换。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png" alt="Java 线程状态变迁图"></p>
<h3 id="7-线程相关的基本方法都有哪些"><a href="#7-线程相关的基本方法都有哪些" class="headerlink" title="7. 线程相关的基本方法都有哪些"></a>7. 线程相关的基本方法都有哪些</h3><p>线程相关的基本方法有6种，分别是wait、sleep、notifyAll、notify、join、yield</p>
<ol>
<li><p><strong>wait方法（线程等待）：</strong></p>
<p>线程调用<code>wait</code>方法并且没有传入参数时，会让该线程进入到一个<code>WAITING</code>状态，<strong>并且释放锁资源</strong>，直至被其他线程调用<code>notify</code>或<code>notifyAll</code>方法才会进入就绪状态重新竞争锁资源；如果调用<code>wait</code>方法并传入一个指定的时间，该线程会进入到<code>TIMED_WAITING</code>状态，如果指定超过的时间还没获取到锁资源，该线程就会直接返回到就绪状态，不会一直在等待通知</p>
</li>
<li><p><strong>sleep方法（线程睡眠）</strong>：</p>
<p>sleep方法会导致当前线程休眠，与wait方法不同的是<strong>sleep不会释放锁资源</strong>，然后sleep会导致线程进入TIMED_WAITING状态，当休眠时间过去之后，当前线程会自动唤醒并且继续执行。这个过程中其他线程处于阻塞状态</p>
</li>
<li><p><strong>yield方法（线程让步）</strong>：</p>
<p>yield方法会让当前线程让出CPU时间片（资源），同时让当前线程重新与其他线程竞争CPU时间片，一般来说优先级高的线程会比较容易获得CPU时间片。但不是绝对的，有一些操作系统对线程优先级不敏感。</p>
</li>
<li><p><strong>interrupt（线程中断）：</strong></p>
<p>该方法可以中断一个线程，该方法会将线程中的一个标识符设置为true，表示中断该线程，但是<strong>线程中断之后并不会释放锁资源</strong>，需要结合wait方法的使用才会释放锁资源。这个过程中线程的状态不会发生改变</p>
</li>
<li><p><strong>join方法（等待其他线程终止）：</strong></p>
<p>在当前线程调用另外一个线程的join()方法时，会让<strong>当前线程进入到阻塞状态，直到另一个线程执行结束</strong>，当前线程才会由阻塞状态转换为就绪状态并且重新竞争锁资源。</p>
</li>
<li><p><strong>notify方法（线程唤醒）：</strong></p>
<p>Object类上的notify方法，可以唤醒在此对象监视器上等待的线程（可以理解为在当前锁对象外面等待的资源），如果所有的线程都在这个对象上等待，则会唤醒任意一个线程。</p>
<p>在调用notify()方法之后，线程并不会立即释放该对象的锁。它会继续执行同步代码块，<strong>直到离开同步代码块或调用wait()方法时才会释放锁</strong>，从而使等待的线程有机会获取锁并执行。</p>
<p>在使用wait()和notify()方法进行线程间通信时，<strong>需要确保等待线程和唤醒线程都使用相同的对象作为锁</strong>，以避免死锁等问题。</p>
</li>
</ol>
<h3 id="8-wait-和sleep-的区别"><a href="#8-wait-和sleep-的区别" class="headerlink" title="8. wait() 和sleep()的区别"></a>8. wait() 和sleep()的区别</h3><p>wait()方法与sleep()方法的区别主要有一下四点</p>
<ol>
<li><p>它们来自不同的类</p>
<p>wait()来自Object类</p>
<p>sleep()来自Thread类</p>
</li>
<li><p>调用wait方法会释放锁资源，调用sleep方法不会释放锁资源</p>
</li>
<li><p>wait方法必须要在同步代码块中使用，sleep方法可以在任何地方使用</p>
</li>
<li><p>wait方法不需要捕获异常，sleep方法需要捕获异常</p>
</li>
</ol>
<h3 id="9-Java中常用的线程池有哪些"><a href="#9-Java中常用的线程池有哪些" class="headerlink" title="9. Java中常用的线程池有哪些"></a>9. Java中常用的线程池有哪些</h3><p>常用的线程池主要有6种，分别是：</p>
<ol>
<li>newFixedThreadPool：创建一个定长线程池（核心线程数与最大线程数都为指定参数的线程池），可以控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newCacheThreadPool：创建一个可缓存线程池（核心线程数为0，最大线程数为Integer.MAX_VALUE的线程池），如果线程池的长度超过处理需要，可以灵活的回收空闲线程，若无可回收，则创建新线程。这种方式可能会创建大量的线程，造成OOM。</li>
<li>newScheduledThreadPool：创建一个定长的线程池（核心线程数与最大线程数都为指定参数的线程池），支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor：创建一个单线程化的线程池（核心线程数与最大线程数都为1的线程池），它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行</li>
<li>newSingleScheduledThreadPool：创建一个单线程化的线程池（核心线程数为1、最大线程数为Integer.MAX_VALUE的线程池），它可安排在给定延迟后运行命令或者定期执行</li>
<li><strong>newWorkStealingPool</strong>：创建一个带并<strong>行级别的线程池</strong>，并行级别决定了同<strong>一时刻</strong>最多有<strong>多</strong>少个；线程在执行<strong>，如不传并行级别参数，将默认为当前系统的</strong>CPU<strong>核心数</strong>*<strong>2</strong>。该线程池是在JDK1.8才出现的，底层是基于一个工作窃取算法实现的，该算法的核心思想就是让空闲的线程从其他线程的任务队列中“窃取”任务来执行。</li>
</ol>
<h3 id="10-Java线程池的核心参数有哪些（创建的时候）"><a href="#10-Java线程池的核心参数有哪些（创建的时候）" class="headerlink" title="10. Java线程池的核心参数有哪些（创建的时候）"></a>10. Java线程池的核心参数有哪些（创建的时候）</h3><blockquote>
<p>corePoolSize：线程池的核心线程数量</p>
<p>maxNumPollSiza：线程池中最大的线程数</p>
<p>KeepAliveTime：当线程数大于核心线程数时，多余的空闲线程存活的最长时间</p>
<p>unit：时间单位</p>
<p>WorkQueue：阻塞队列&#x2F;任务队列，用来储存等待执行任务的队列</p>
<p>threadFartoty：线程工厂，用来创建线程，一般默认即可</p>
<p>handler：拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</p>
</blockquote>
<h3 id="11-线程池的执行流程"><a href="#11-线程池的执行流程" class="headerlink" title="11. 线程池的执行流程"></a>11. 线程池的执行流程</h3><p><img src="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230602143058557.png" alt="image-20230602143058557"></p>
<ol>
<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>
<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li>
<li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>
<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>
</ol>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="1-网络的7层架构"><a href="#1-网络的7层架构" class="headerlink" title="1. 网络的7层架构"></a>1. 网络的7层架构</h3><blockquote>
<p>OSI七层模型是什么？每一层的作用是什么？</p>
</blockquote>
<p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230603073012982.png" alt="image-20230603073012982"></p>
<h3 id="2-TCP与UDP的区别"><a href="#2-TCP与UDP的区别" class="headerlink" title="2. TCP与UDP的区别"></a>2. TCP与UDP的区别</h3><ol>
<li><strong>是否面向连接：</strong>UDP在传送数据之前不需要先建立连接。而TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接</li>
<li><strong>是否是可靠传输：</strong>远地主机在收到UDP报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP提供可靠的传输服务，TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制等机制。通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达</li>
<li><strong>是否有状态：</strong>与”是否可靠“相对应，TCP传输是有状态的，这个有状态说的是TCP会去记录自己发送消息的状态，比如消息是否发送了、是否被接收了等等。为此TCP需要维持复杂的连接状态表。而UDP是无状态服务，简单来说就是不管发出去之后的事情了（渣男行为）</li>
<li><strong>传输效率：</strong>TCP进行传输时多了连接、确认、重传等机制，所以TCP传输效率要比UDP低很多</li>
<li><strong>传输形式</strong>：TCP是面向字节流的，UDP是面向报文的</li>
<li><strong>首部开销</strong>：TCP首部开销（20~60字节）比UDP首部开销（8字节）要大</li>
<li><strong>是否提供广播或多播服务：</strong>TCP只支持点对点通信；UDP支持一对一、一对多、多对一、多对多通信。</li>
</ol>
<p>总结起来就是：</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>TCP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20 ～ 60 bytes</td>
<td>8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="3-TCP与UDP的运用场景"><a href="#3-TCP与UDP的运用场景" class="headerlink" title="3. TCP与UDP的运用场景"></a>3. TCP与UDP的运用场景</h3><ul>
<li><strong>UDP 一般用于即时通信</strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h3 id="4-TCP的三次握手和四次挥手"><a href="#4-TCP的三次握手和四次挥手" class="headerlink" title="4. TCP的三次握手和四次挥手"></a>4. TCP的三次握手和四次挥手</h3><blockquote>
<p>这个问题可以衍生出很多经典面试题，详细见下面链接</p>
<p><a href="https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/network/tcp-connection-and-disconnection">TCP 三次握手和四次挥手（传输层）</a></p>
</blockquote>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote>
<p>算法篇详情见</p>
<ul>
<li><a href="https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/algorithms/10-classical-sorting-algorithms">十大经典排序算法</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>interview</tag>
        <tag>持续更新</tag>
      </tags>
  </entry>
  <entry>
    <title>懒汉式单例模式下的双检锁机制的理解</title>
    <url>/2023/05/26/%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%8F%8C%E6%A3%80%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在学习懒汉式单例模式时，发现了懒汉双检锁的实现方式，当时不是很理解，查阅资料后得出以下结论</p>
<span id="more"></span>

<h2 id="双检锁机制"><a href="#双检锁机制" class="headerlink" title="双检锁机制"></a>双检锁机制</h2><p>在多个线程同时请求一个获取一个懒汉式单例对象时，可能会导致创建多个对象的问题，为了确保只有一个对象被创建，可以使用双检锁机制。（双检锁机制不是创建两个锁实现，而是再方法内部实现两种检锁）</p>
<p>双检锁机制基于懒汉模式，在第一次获取单例对象时才创建它；</p>
<p>为了提高程序的性能，我们不在方法前使用syschronized关键字，而是在方法内部使用，同时也在方法内部实现了双重检查锁定机制。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//第一重检锁</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//第二重检锁，只有uniqueInstance为null时才会生效</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在双检锁机制中，我们使用了synchronized关键字来创建一个锁，确保只有一个线程能进入if语句块内部。在此之前，我们首先检查uniqueInstance变量是否为null。如果为null我们才进入if语句块，获取锁，并再次检查uniqueInstance变量是否为null。这是因为在多线程环境下，可能会有多个线程同时进入第一个if语句块，如果不在此检查uniqueInstance变量是否为null，就有可能会创建多个Singleton对象，违反了单例模式的原则。</p>
<p>一旦我们进入了if语句块，获取了锁，就可以创建唯一的Singleton对象。其他线程尝试进入if语句块时，由于uniqueInstance变量已经不为null，所以它们不会执行if语句块内的代码，而是直接返回uniqueInstance变量的值。</p>
<p>在整个过程中，synchronized关键字可以确保只有一个线程能够访问if一句话内的代码，在这之前和之后，uniqueInstance变量由于是用volatile关键字进行了修饰，可以被确保它在多线程环境下的可见性，从而避免了问题的发生。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>除了单例模式之外，它还可以用于其他需要保证线程安全的场景。例如，我们可以使用双检锁机制来确保在多线程环境下只创建一个实例化某个对象的方法。<br>双检锁机制在多线程环境下会有比较好的性能表现，因为它只在第一次创建对象时使用synchronized关键字来获取锁，在之后的访问中不需要获取锁，因此避免了不必要的开销。如果在多线程环境下需要频繁创建对象，使用双检锁机制会比使用简单的synchronized关键字更加高效。<br>需要注意的是，虽然双检锁机制可以确保在多线程环境下只创建一个对象，但是如果对象的初始化操作耗时较长，可能会造成性能问题。此外，还需要注意正确使用volatile关键字，确保变量的可见性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，双检锁机制是一种比较常见的保证线程安全的方式，可以用于单例模式等需要确保只有一个对象被创建的场景。在使用双检锁机制时，需要注意并发情况下的安全性和性能问题。</p>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Singleton Pattern</tag>
        <tag>Lazy Singleton</tag>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
</search>
