<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"minster.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言![moon-4919501_1920 (2)](http:&#x2F;&#x2F;minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;moon-4919501_1920 (2).jpg) 以下是我对Java高频面试题的一个总结，后面我会持续更新，希望对你有所帮助。 当然，如果有哪道题目我理解错误了，或者是你有更好的见解，非常欢迎你在评论区中留下宝贵的意见">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题汇总（持续更新！）">
<meta property="og:url" content="https://minster.top/2023/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/index.html">
<meta property="og:site_name" content="minster&#39;s Blog">
<meta property="og:description" content="前言![moon-4919501_1920 (2)](http:&#x2F;&#x2F;minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;moon-4919501_1920 (2).jpg) 以下是我对Java高频面试题的一个总结，后面我会持续更新，希望对你有所帮助。 当然，如果有哪道题目我理解错误了，或者是你有更好的见解，非常欢迎你在评论区中留下宝贵的意见">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230509175906576.png">
<meta property="og:image" content="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230509175922784.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png">
<meta property="og:image" content="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230602143058557.png">
<meta property="og:image" content="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230603073012982.png">
<meta property="article:published_time" content="2023-06-03T13:21:04.000Z">
<meta property="article:modified_time" content="2023-06-03T13:45:16.157Z">
<meta property="article:author" content="Minster">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="interview">
<meta property="article:tag" content="持续更新">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230509175906576.png">


<link rel="canonical" href="https://minster.top/2023/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://minster.top/2023/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/","path":"2023/06/03/Java面试题汇总（持续更新！）/","title":"Java面试题汇总（持续更新！）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java面试题汇总（持续更新！） | minster's Blog</title>
  







<link rel="dns-prefetch" href="my-blog-comments-nine.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="minster's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">minster's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习以及生活~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">11</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">5</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">5</span></a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaSE%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">JavaSE基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JDK%E3%80%81JRE%E3%80%81JVM%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.</span> <span class="nav-text">1. JDK、JRE、JVM分别是什么，有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.</span> <span class="nav-text">2. 重载和重写的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-x3D-x3D-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.3.</span> <span class="nav-text">3. &#x3D;&#x3D;和equals的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AFhashCode"><span class="nav-number">2.4.</span> <span class="nav-text">4. 什么是hashCode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-hashCode%E4%B8%8Eequals%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="nav-number">2.5.</span> <span class="nav-text">5. hashCode与equals有什么关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95%E5%91%A2"><span class="nav-number">2.6.</span> <span class="nav-text">6. 为什么重写equals方法必须重写hashCode方法呢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">2.7.</span> <span class="nav-text">7. 面向对象的特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">2.8.</span> <span class="nav-text">8. 接口和抽象类的共同点和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-java%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">2.9.</span> <span class="nav-text">9. java中操作字符串的类有哪些？他们之间有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E6%B7%B1%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B5%85%E5%85%8B%E9%9A%86%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89"><span class="nav-number">2.10.</span> <span class="nav-text">10. 深克隆与浅克隆的区别（深拷贝和浅拷贝）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Java-%E6%98%AF%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E7%9A%84%E8%AF%AD%E8%A8%80%EF%BC%8C%E8%BF%98%E6%98%AF%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="nav-number">2.11.</span> <span class="nav-text">11. Java 是编译执行的语言，还是解释执行的语言?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaSE%E8%BF%9B%E9%98%B6-%E9%9B%86%E5%90%88"><span class="nav-number">3.</span> <span class="nav-text">JavaSE进阶-集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Array-%E5%92%8C-ArrayList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">1、Array 和 ArrayList 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.2.</span> <span class="nav-text">2、常见的集合类有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81ArrayList%E4%B8%8ELinkedList%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">3.3.</span> <span class="nav-text">3、ArrayList与LinkedList的异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">4、ArrayList的扩容机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.5.</span> <span class="nav-text">HashMap的底层数据结构是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">3.6.</span> <span class="nav-text">HashMap的扩容机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">4.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8Bjvm%E5%8A%A0%E8%BD%BD-class%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B%E5%90%97%EF%BC%9F%EF%BC%88%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">1. 描述一下jvm加载.class文件的过程吗？（类加载过程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">2. 什么是双亲委派模型，为什么要使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">3. 可达性算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BD%A0%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%90%97%EF%BC%9F"><span class="nav-number">4.4.</span> <span class="nav-text">4. 你能说一下垃圾回收机制吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%A0%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E5%90%97"><span class="nav-number">5.1.</span> <span class="nav-text">1. 你能说一下创建线程的方法有哪些吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Runnable%E6%8E%A5%E5%8F%A3%E5%92%8CCallable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.</span> <span class="nav-text">2. Runnable接口和Callable接口的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-sleep%E6%96%B9%E6%B3%95%E5%92%8Cyield%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.</span> <span class="nav-text">3. sleep方法和yield方法有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E4%B8%ADsleep%E5%92%8Cwait%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.4.</span> <span class="nav-text">4. 线程中sleep和wait方法有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%9A%84run%E6%96%B9%E6%B3%95%E5%92%8Cstart%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.5.</span> <span class="nav-text">5. 线程的run方法和start方法有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F%EF%BC%88%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89"><span class="nav-number">5.6.</span> <span class="nav-text">6. 线程有哪几种状态？（线程的生命周期）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">5.7.</span> <span class="nav-text">7. 线程相关的基本方法都有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-wait-%E5%92%8Csleep-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.8.</span> <span class="nav-text">8. wait() 和sleep()的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">5.9.</span> <span class="nav-text">9. Java中常用的线程池有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E5%88%9B%E5%BB%BA%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%89"><span class="nav-number">5.10.</span> <span class="nav-text">10. Java线程池的核心参数有哪些（创建的时候）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.11.</span> <span class="nav-text">11. 线程池的执行流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BD%91%E7%BB%9C%E7%9A%847%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">1. 网络的7层架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.</span> <span class="nav-text">2. TCP与UDP的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-TCP%E4%B8%8EUDP%E7%9A%84%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.3.</span> <span class="nav-text">3. TCP与UDP的运用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">6.4.</span> <span class="nav-text">4. TCP的三次握手和四次挥手</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">算法</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Minster"
      src="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/avatar.png">
  <p class="site-author-name" itemprop="name">Minster</p>
  <div class="site-description" itemprop="description">祝你好运</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/minsterZnhy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;minsterZnhy" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:minster8And24@outlook,com" title="E-Mail → mailto:minster8And24@outlook,com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://minster.top/2023/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/avatar.png">
      <meta itemprop="name" content="Minster">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="minster's Blog">
      <meta itemprop="description" content="祝你好运">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java面试题汇总（持续更新！） | minster's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java面试题汇总（持续更新！）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-06-03 21:21:04 / Modified: 21:45:16" itemprop="dateCreated datePublished" datetime="2023-06-03T21:21:04+08:00">2023-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java面试题</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline: </span>
  
    <a title="waline" href="/2023/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>13k</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>![moon-4919501_1920 (2)](<a target="_blank" rel="noopener" href="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/moon-4919501_1920">http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/moon-4919501_1920</a> (2).jpg)</p>
<p>以下是我对Java高频面试题的一个总结，后面我会持续更新，希望对你有所帮助。</p>
<p>当然，如果有哪道题目我理解错误了，或者是你有更好的见解，非常欢迎你在评论区中留下宝贵的意见！</p>
<p>本文有一些内容是参考<a target="_blank" rel="noopener" href="https://javaguide.cn/">Guide哥</a>的，有兴趣的可以去了解一下~</p>
<span id="more"></span>

<h2 id="JavaSE基础"><a href="#JavaSE基础" class="headerlink" title="JavaSE基础"></a>JavaSE基础</h2><h3 id="1-JDK、JRE、JVM分别是什么，有什么区别"><a href="#1-JDK、JRE、JVM分别是什么，有什么区别" class="headerlink" title="1. JDK、JRE、JVM分别是什么，有什么区别"></a>1. JDK、JRE、JVM分别是什么，有什么区别</h3><ul>
<li>**JDK(Java Development Kit)**是Java标准开发包，它提供了编译、运行Java所需要的各种工具和资源，包括Java编译器、Java运行环境、以及常用的类库等</li>
<li><strong>JRE(Java Runtime Enviroment)：</strong>Java的运行环境，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件</li>
<li><strong>JVM(Java Virtual Mechinal)：</strong>Java虚拟机，是JRE的一部分，它用于编译执行字节码文件，是可运行Java字节码文件的虚拟计算机</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>JDK用于开发，JRE用于运行Java程序，如果你只是为了运行一下Java程序的话，安装JRE即可，但是要开发Java程序的话，必须要安装JDK</li>
<li>JDK包含JRE，JDK、JRE中都有JVM</li>
<li>JVM是Java实现跨平台性的核心，它具有平台独立性能，它拥有类加载以及垃圾回收等机制。</li>
</ul>
<h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2. 重载和重写的区别"></a>2. 重载和重写的区别</h3><ul>
<li>重载发生在同一类中，当同一类中的两个或多个方法，方法名相同，参数列表不同，就构成了重载</li>
<li>重写发生在类的父子关系中，当一个类继承另一个类或者实现了某一个接口，就可以重写该类的非私有方法，从而实现功能的拓展；重写要求方法名、参数列表相同</li>
</ul>
<h3 id="3-x3D-x3D-和equals的区别是什么"><a href="#3-x3D-x3D-和equals的区别是什么" class="headerlink" title="3. &#x3D;&#x3D;和equals的区别是什么"></a>3. &#x3D;&#x3D;和equals的区别是什么</h3><p>&#x3D;&#x3D;对于基本类型来说就是值的比较，对于引用类型来说就是引用的比较。</p>
<p>而equals默认情况下是引用的比较，只是因为有很多类都重写了equals方法，比如String、Integer等类都把它变成了值的比较，所以一般情况下，equals是比较的是值是否相等，也就是值比较。</p>
<h3 id="4-什么是hashCode"><a href="#4-什么是hashCode" class="headerlink" title="4. 什么是hashCode()"></a>4. 什么是hashCode()</h3><p>hashCode()方法作用获取一个哈希码，即散列码，它实际上是一个int整数。哈希码可以确定该对象在哈希表中的索引位置。hashCode的定义在Object类中，所以java中任何类都包含了hashCode函数。</p>
<p>散列表其实就是用来存放键值对（key-value），我们可以通过key快速检索出对应的value。其中就使用了散列码。</p>
<h3 id="5-hashCode与equals有什么关系"><a href="#5-hashCode与equals有什么关系" class="headerlink" title="5. hashCode与equals有什么关系"></a>5. hashCode与equals有什么关系</h3><p>要搞清楚他们之间的关系，我们可以从hash表的结构出发，其实hash表是一个数组+链表或红黑树的结构，Java的集合容器就有使用到这种数据结构的，然后在我们要存储对象到容器时可以先通过hashCode方法返回了一个hash值，这个hash与数组长度取余之后就能获取到该对象的存放在数组结构的一个对应的下标，当两个对象有相同的hash值的时候，说明存放的数组下标是一样的，那么此时我们就需要通过equals方法判断这两个对象是不是相同的对象，如果是相同的对象会直接将原来的对象覆盖掉，如果不是则插入在链表中，所以我们可以得下面结论：</p>
<ol>
<li>当两个对象相同时，它们的hash值也相同，它们之间的互相调用equals方法结果为true</li>
<li>当两个对象有相同的hashCode的值，那么它们也不一定相等。</li>
</ol>
<h3 id="6-为什么重写equals方法必须重写hashCode方法呢"><a href="#6-为什么重写equals方法必须重写hashCode方法呢" class="headerlink" title="6. 为什么重写equals方法必须重写hashCode方法呢"></a>6. 为什么重写equals方法必须重写hashCode方法呢</h3><p>首先在java的一些容器中，是不允许存放两个相同的对象的，如果对象相同会覆盖掉，而在散列表中我们存放对象时，会首先判断两个对象的hash值是否相同，如果相同再通过equals方法来判断是否为相同对象，如果是相同对象就会在散列表中覆盖掉，否则就插入到相关链表中，那么如果我们只重写了equals方法，而不重写hashCode方法，那么那么相同对象的值就无法覆盖了。</p>
<h3 id="7-面向对象的特征"><a href="#7-面向对象的特征" class="headerlink" title="7. 面向对象的特征"></a>7. 面向对象的特征</h3><p>面向对象主要有三大特征：封装性、继承、多态</p>
<ol>
<li><p>封装性：封装性指的是我们在定义对象时，尽可能的把对象状态信息隐藏起来，只提供有限的接口的方法给外界交互使用，从而避免外界对对象内部属性进行破坏。</p>
</li>
<li><p>继承：继承其实就是一种能力，当一个类A继承了另外一个类B时，A类就可以使用B类公开的所有的属性和方法，并且可以在不修改父类的前提下对其功能进行拓展。当然，如果B类存在用private修饰的属性或方法，A类是无法使用的，这就是封装性的体现。</p>
</li>
<li><p>多态：多态是指同一对象的不同形式的展现，比如说我们到宠物店跟店说“我要一只宠物”，那么店员就可以给我一只小猫、小狗、或者小蜥蜴等等，那么此时我们所说的宠物对象就是多态一种展现了。</p>
<blockquote>
<p>多态是怎么形成的</p>
<p>其实java的引用变量有两种类型，一种是编译时类型、一种是运行时类型，而编译类型由引用变量在定义时的声明所决定，运行时类型由实际赋值给引用变量的类型所决定，当编译时类型与运行时类型不一样时，就会产生所谓的多态</p>
</blockquote>
</li>
</ol>
<h3 id="8-接口和抽象类的共同点和区别"><a href="#8-接口和抽象类的共同点和区别" class="headerlink" title="8. 接口和抽象类的共同点和区别"></a>8. 接口和抽象类的共同点和区别</h3><p><strong>共同点：</strong></p>
<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现的方法（在JDK1.8之后才可以用default定义接口中的默认方法的）</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>接口用于对类的行为进行约束，一个类实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系</li>
<li>一个类只能继承一个类，但是可以实现多个接口</li>
<li>抽象类中有构造方法，接口中没有构造方法</li>
<li>抽象类中的成员变量默认是default，可以被子类重新定义赋值，接口中的成员变量是常量，不能被修改且必须要有初始值</li>
</ul>
<h3 id="9-java中操作字符串的类有哪些？他们之间有什么区别"><a href="#9-java中操作字符串的类有哪些？他们之间有什么区别" class="headerlink" title="9. java中操作字符串的类有哪些？他们之间有什么区别"></a>9. java中操作字符串的类有哪些？他们之间有什么区别</h3><p>操作字符串的类有主要有String、StringBuffer、StringBuilder三种。</p>
<p>首先String、StringBuffer底层都是char数组，然后因为String类的char数组是由Final修饰的，所以String类的长度是不会变化，每当我们新建一个String类时都需要new一个对象，让指针指向新的对象。而StringBuffer维护的char数组以及在JDK1.5之后出现的StringBuilder维护的byte数组都没有使用Final修饰，所以他们存放的字符串内容是可变的。而且存在扩容机制。</p>
<blockquote>
<p>扩容机制：</p>
<p>因为他们都是继承了AbstractStirngBuilder类，而该类有一个方法会检测当前字符串类的char的容量是否足够来存放新的字符串，如果不能，进行扩容</p>
<p>扩容的逻辑就是new一个相同大小的char+2然后调用数组的copyOf方法将两个char数组合成一个新的。</p>
</blockquote>
<p>然后StringBuffer和StringBuilder之间是有线程是否安全的区别的。</p>
<p>StringBuffer因为加了同步锁synchronized所以线程安全，因为synchronized同步锁会有一个获取锁和释放锁的操作，所以StringBuffer的效率更低。</p>
<blockquote>
<p>为什么StringBuffer加了锁就效率更低呢？</p>
<p>因为synchronized锁其实是会有四种状态的升级和优化的。分别是：无锁、偏向锁、轻量级锁、重量级锁四种</p>
<p>偏向锁就是当一段同步代码或者是资源被同一个线程多次访问的时候，那么该线程就会自动获取锁，降低获取锁的代价。</p>
<p>而当锁是偏向锁时，如果有其他线程访问该锁时，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式来获取锁，不会阻塞，提高性能。</p>
<p>当前锁是轻量级锁时，另外一个线程不会一直自旋，当其自旋到一定次数后，轻量级锁会升级为重量级锁，其他线程进入阻塞状态，性能降低。因为线程自旋需要消耗cpu性能，所以自旋到一定次数后轻量级锁会膨胀成重量级锁。</p>
</blockquote>
<p>StringBuilde因为没有加入锁，所以效率更高，适合高并发时候使用。</p>
<h3 id="10-深克隆与浅克隆的区别（深拷贝和浅拷贝）"><a href="#10-深克隆与浅克隆的区别（深拷贝和浅拷贝）" class="headerlink" title="10. 深克隆与浅克隆的区别（深拷贝和浅拷贝）"></a>10. 深克隆与浅克隆的区别（深拷贝和浅拷贝）</h3><p>浅克隆（默认）</p>
<ul>
<li><p>拷贝出的新对象，与原对象中的数据一模一样（引用类型拷贝的是地址）</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230509175906576.png" alt="image-20230509175906576"></p>
</li>
</ul>
<p>深克隆（避免新对象修改其他对象内容时，影响原对象的对象内容）</p>
<ul>
<li><p>对象中基本类型的数据直接拷贝</p>
</li>
<li><p>对象中的字符串数据拷贝的还是地址</p>
</li>
<li><p>对象中还包含的其他对象，不会拷贝地址，会创建新对象</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230509175922784.png" alt="image-20230509175922784"></p>
</li>
</ul>
<h3 id="11-Java-是编译执行的语言，还是解释执行的语言"><a href="#11-Java-是编译执行的语言，还是解释执行的语言" class="headerlink" title="11. Java 是编译执行的语言，还是解释执行的语言?"></a>11. Java 是编译执行的语言，还是解释执行的语言?</h3><p><strong>Java即是编译型的，也是解释型语言，总的来说Java更接近解释型语言</strong></p>
<ul>
<li>可以说它是编译型的。因为所有的Java代码都是要编译的，Java不经过编译就什么用都没有。同时围绕JVM的效率问题，会涉及一些如JIT、AOT等优化技术，例如JIT技术，会将热点代码编异成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码</li>
<li>可以说它是解释型的。因为Java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的。</li>
</ul>
<h2 id="JavaSE进阶-集合"><a href="#JavaSE进阶-集合" class="headerlink" title="JavaSE进阶-集合"></a>JavaSE进阶-集合</h2><h3 id="1、Array-和-ArrayList-有什么区别？"><a href="#1、Array-和-ArrayList-有什么区别？" class="headerlink" title="1、Array 和 ArrayList 有什么区别？"></a>1、Array 和 ArrayList 有什么区别？</h3><ul>
<li><p>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</p>
</li>
<li><p>Array 大小是固定的，ArrayList 的大小是动态变化的。</p>
</li>
<li><p>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</p>
</li>
</ul>
<h3 id="2、常见的集合类有哪些"><a href="#2、常见的集合类有哪些" class="headerlink" title="2、常见的集合类有哪些"></a>2、常见的集合类有哪些</h3><p>Java的集合容器有单列集合和双列集合两种，单列集合指的是Collection接口下的派生类：List、Set、Queue（Jdk5 新增的队列）；双列集合则是Map接口下的派生类。</p>
<blockquote>
<p><strong>注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口</strong>。</p>
</blockquote>
<p>在集合体系中，List集合代表了由许可重复集合，他们是有索引的；Set集合代表无序不可重复的集合，只能根据元素本身来访问（无索引）。Queue集合时一个队列集合。</p>
<p>Map集合时可以存放key-value键值对的集合，他的key是不可重复的，value是可以重复的。</p>
<p>List集合常用的有ArrayList、LinkedList</p>
<p>Set集合中常用的有HashSet、TreeSet</p>
<p>Queue集合常用的有ArrayQueue</p>
<p>Map集合中常用的有HashMap、TreeMap、ConcurrentHashMap</p>
<h3 id="3、ArrayList与LinkedList的异同"><a href="#3、ArrayList与LinkedList的异同" class="headerlink" title="3、ArrayList与LinkedList的异同"></a>3、ArrayList与LinkedList的异同</h3><ul>
<li><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> Arraylist 底层使用的是Object数组（动态数组）；LinkedList 底层使用的是双向循环链表数据结构；</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。  <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li>
<li><strong>是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h3 id="4、ArrayList的扩容机制"><a href="#4、ArrayList的扩容机制" class="headerlink" title="4、ArrayList的扩容机制"></a>4、ArrayList的扩容机制</h3><p>因为ArrayList底层维护的是一个数组，所以ArrayList的扩容机制是基于Arrays.copyOf方法实现的。</p>
<p>当我们用默认的无参构造方法创建ArrayList集合的时候，ArrayList的初始长度为0。<strong>当我们向集合添加第一个元素的时候，ArrayList集合的长度为10；</strong></p>
<p>当我们向集合添加元素时都会有一个判断，就是查看当前容量是否可以继续添加元素，<strong>如果集合的容量够就添加到集合中，如果容量不够则触发扩容机制，扩容的大小为原集合容量的1.5倍。</strong></p>
<blockquote>
<p>1.5倍是因为新的集合容量为<strong>原集合容量</strong>与<strong>其右移一位之后</strong>的和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当我们使用有参构造去创建ArrayList集合时，扩容机制也与上面的一样，不过需要注意的是他扩容的大小为你传进去的参数的1.5倍</p>
<h3 id="HashMap的底层数据结构是什么"><a href="#HashMap的底层数据结构是什么" class="headerlink" title="HashMap的底层数据结构是什么"></a>HashMap的底层数据结构是什么</h3><p><strong>在JDK1.8以前，HashMap底层维护的是一个”数组+链表“的结构</strong>，数组是HashMap的主体，链表是为了解决哈希冲突而存在的。</p>
<p><strong>在JDK1.8之后，HashMap的底层数据结构变成了”数组+链表+红黑树“的结构了</strong>。</p>
<p>在JDK1.8之前，如果我们使用HashMap存放大量数据时，会使HashMap的链表结构变得非常长，这样会导致我们的查询效率变慢，严重的影响了HashMap的性能。</p>
<p>因此，在JDK1.8之后对数据结构做了进一步的优化，引进了红黑树，链表和红黑树会在达到一定条件时会进行转换：</p>
<ul>
<li>当链表长度达到了8，且数组的长度达到64时才会发生转换</li>
<li>因为在触发树化机制的时候，HashMap的底层会进行判断，如果当前数组的长度没有达到64，会优先对数组进行扩容，而不是进行树化，这样可以节省查询时间。</li>
</ul>
<blockquote>
<p>面试官也许还会问：</p>
<p>如你上面所说，为什么HashMap在JDK8之后不直接采取数组+红黑树的结构，而是使用数组+链表+红黑树的数据结构呢？</p>
<p>首先因为红黑树会在每次添加元素时进行一个左旋、右旋、变色等操作来保持平衡，链表则不会，因此链表插入数据的效率会比红黑树快。</p>
<p>所以在数据量很少的时候，链表的效率会比红黑树高；</p>
<p>但是当数据量多了之后，因为红黑树搜索的时间复杂度为Olog(n)，而链表的是O(n)，因此选择红黑树可以增加的查询效率，但是新增的效率变慢了。</p>
<p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p>
</blockquote>
<h3 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h3><ul>
<li>HashMap底层维护了Node类型的数组table，默认为null，链表与红黑树是为了解决哈希冲突而存在的。</li>
<li>当创建对象时，将加载因子(loadfactor)初始化为0.75；</li>
<li>当添加key-value时，通过<strong>key</strong>的hash值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换<strong>value</strong>；<strong>如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。</strong></li>
<li>第一次添加时，会将需要扩容的table容量扩容到16，临界值(threshold)为12</li>
<li>如果需要再次扩容，会将需要扩容的table容量扩容到原来的2倍（32），临界值为原来的2倍（24） 依次类推。</li>
<li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（转换红黑树），<strong>否则任然采用数组扩容机制</strong></li>
</ul>
<blockquote>
<p>HashSet的底层就是HashMap，唯一区别是HashSet的value值为一个常量，所以当同一hash值中的key相同时，会添加失败；而HashMap会替换掉key的值。</p>
</blockquote>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-描述一下jvm加载-class文件的过程吗？（类加载过程）"><a href="#1-描述一下jvm加载-class文件的过程吗？（类加载过程）" class="headerlink" title="1. 描述一下jvm加载.class文件的过程吗？（类加载过程）"></a>1. 描述一下jvm加载.class文件的过程吗？（类加载过程）</h3><p>因为Class文件需要加载到虚拟机中才能运行和使用，所以就有了类加载的过程</p>
<p>类在JVM中的生命周期主要有：<strong>加载、连接、初始化、使用、卸载五部分组成。</strong></p>
<p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong></p>
<p><strong>加载过程</strong>指的是JVM将经过javac编译的字节码文件加载到内存当中的过程。</p>
<p><strong>连接阶段分别由验证、准备、解析三个阶段组成。</strong></p>
<ul>
<li><p>验证阶段会对字节码文件的格式、元数据格式等进行验证，确保字节码文件没有损害JVM的内容，是保护JVM的一个阶段。</p>
</li>
<li><p>准备阶段会为class文件的静态变量分配内存，并赋予初始值，此时的初始值指的是0</p>
</li>
<li><p>解析阶段会将符号引用转换为直接引用</p>
</li>
</ul>
<p><strong>连接阶段完成之后会到初始化阶段</strong>，该阶段开始执行java中定义的代码，为变量赋予真正的初始值，指的是代码中程序员想要赋的值</p>
<blockquote>
<p>类加载是由类加载器完成的，类加载器分别有：启动类加载器、扩展类加载器、系统类加载器、自定义加载器等</p>
</blockquote>
<h3 id="2-什么是双亲委派模型，为什么要使用"><a href="#2-什么是双亲委派模型，为什么要使用" class="headerlink" title="2. 什么是双亲委派模型，为什么要使用"></a>2. 什么是双亲委派模型，为什么要使用</h3><p>双亲委派原则指的是类加载器在接收到类加载的一个请求时，不会立刻加载，会先委派该类的父类加载器去加载，只有当父类加载器在他的搜索范围内没有搜索到该类时，子类的加载器才会对该类进行加载。</p>
<p>这样做可以防止内存中出现多个相同的字节码；因为如果没有双亲委派模型的话，那么用户自己再定义了一个java.lang.String的类，就无法保证类的唯一性了。</p>
<h3 id="3-可达性算法"><a href="#3-可达性算法" class="headerlink" title="3. 可达性算法"></a>3. 可达性算法</h3><p>可达性算法的逻辑就是，在以一个GC Root为根节点的对象作为起点开始搜索，能遍历的对象其实就是可达的对象，亦就是说该对象还存在对他的引用，而不能遍历到的对象，就是不可达，也就是被GC回收的对象。</p>
<p>可以作为GC Roots的对象有哪些呢？</p>
<blockquote>
<ul>
<li>在栈帧的局部变量引用的对象</li>
<li>在本地方法区JNI引用的对象</li>
<li>在方法区（元空间）的静态变量或常量引用的对象</li>
</ul>
</blockquote>
<h3 id="4-你能说一下垃圾回收机制吗？"><a href="#4-你能说一下垃圾回收机制吗？" class="headerlink" title="4. 你能说一下垃圾回收机制吗？"></a>4. 你能说一下垃圾回收机制吗？</h3><p>首先我们要理解JVM的一个内存模型，因为JVM的内存模型是由栈、本地方法区、程序计算器、元空间、堆这5部分组成。</p>
<p>然后因为我们创建的对象，是存在在堆的，然后当我们一段代码执行完成之后，只有存放在栈的局部变量可以自动删除，而存放在堆的对象仍然存在，这时候就需要垃圾回收机制来回收堆的内存了。</p>
<p>然后垃圾回收的算法主要有三种</p>
<ul>
<li><p>标记清理法：就是先遍历一次堆里面的所有对象，把要删除的对象标记，然后再遍历一次，把第一次遍历的对象都删除掉，就完成了，但是有一个缺点，就是会存在内存碎片</p>
<blockquote>
<p>什么是内存碎片？</p>
<p>内存碎片我是这样理解的，比如我们在堆中的两个不相连的位置中分别有一个1KB大小的对象，然后我们通过标记清理法把他们删除了，那么堆中就挤出来2KB的内存空间了，如果我们这个时候新建一个2KB大小的对象，是无法存在在堆中的，因为上面清理出来的2KB空间不是连续的，所以就会产生内存碎片问题</p>
</blockquote>
</li>
<li><p>标记-整理法：他跟标记清理法原理是差不多的，但是他会在删除对象后，把后面的对象往前推，这样子就解决了内存碎片的问题，但是由于每删一个对象都需要移动一次后面的对象，缺点就是代价太大了。</p>
</li>
</ul>
<ul>
<li>复制法：复制法会把内存分成两块大小一样的内存，然后再其中一块内存通过GC ROOT标记，把存活的对象复制到另一块内存中去，然后再把存放垃圾对象的内存清理掉，缺点就是需要双倍的内存，太消耗内存了。</li>
</ul>
<p>所以GC综合了上面三个算法，创建了一个分代收集的算法出来</p>
<p>分代收集算法就是先把内存分为young跟old两块，分别代表年轻代和老年代。</p>
<p>然后再young那一块内存中，又分为E空间、S0空间、S1空间；</p>
<p>然后在一次GC之后，E空间和S0空间存活的对象会移到S1空间去，再回收E空间和S0空间的垃圾对象</p>
<p>在下一次GC完成后，E空间和S1空间存活的对象会移到S0空间去，然后回收E空间和S1空间的垃圾对象</p>
<p>每一次被标记存活的对象，都会有一个类似于age的变量，都会加一，当age&gt;一个阈值时，他会晋升到老年区去。</p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="1-你能说一下创建线程的方法有哪些吗"><a href="#1-你能说一下创建线程的方法有哪些吗" class="headerlink" title="1. 你能说一下创建线程的方法有哪些吗"></a>1. 你能说一下创建线程的方法有哪些吗</h3><p>创建线程的方式有四种，分别是</p>
<ol>
<li>继承Thread类并重写run方法创建线程，虽然实现简单，但是不可以继承其他类</li>
<li>实现Runnable接口并重写run方法方法。避免了单继承的局限性，编程更加灵活，很好的实现了解耦合</li>
<li>实现Callable接口并重写call方法，创建线程，通过该方法可以获取线程执行结果的返回值，并且可以抛出异常。</li>
<li>通过线程池创建。（使用java.util.concurrent.Executor接口）</li>
</ol>
<h3 id="2-Runnable接口和Callable接口的区别"><a href="#2-Runnable接口和Callable接口的区别" class="headerlink" title="2. Runnable接口和Callable接口的区别"></a>2. Runnable接口和Callable接口的区别</h3><p>Runnable接口的run方法没有返回值，Callable接口的call方法有返回值，并且支持泛型</p>
<p>Runnable接口的run方法只能抛出运行时异常，且只能在内部出了异常，而Callable接口可以抛出所有的异常，以及在内部处理。</p>
<h3 id="3-sleep方法和yield方法有什么区别"><a href="#3-sleep方法和yield方法有什么区别" class="headerlink" title="3. sleep方法和yield方法有什么区别"></a>3. sleep方法和yield方法有什么区别</h3><ol>
<li>sleep方法不会考虑优先级问题，然后优先级低的线程也能拿到CPU资源，而yield方法会考虑优先级的问题，调用该方法只会给同等优先级或高优先级的线程CPU资源</li>
<li>Sleep方法有声明InterruptedExcetion异常抛出，yield是没有异常抛出的</li>
<li>sleep方法执行后线程会进入阻塞状态，而yield方法执行后会进入就绪状态</li>
<li>sleep比yield具有更好的移植性</li>
</ol>
<h3 id="4-线程中sleep和wait方法有什么区别"><a href="#4-线程中sleep和wait方法有什么区别" class="headerlink" title="4. 线程中sleep和wait方法有什么区别"></a>4. 线程中sleep和wait方法有什么区别</h3><p>首先sleep()方法是线程类的一个静态方法，调用该方法可以让线程暂停指定的一段时间，暂停的线程会把CPU资源让出来给其他线程使用，但是对象的锁依然保存，所以当暂停时间到后，该线程会自动恢复到就绪状态。而wait方法是Object类一个方法，调用对象的wait方法可以让当前线程放弃对象的锁，即进入暂停状态，然后当前线程会进入到对象的等待池，知道对象调用notice方法时才能唤醒等待池中的线程进入等锁池，如果线程重新获得对象的锁就可以进入到就绪状态。</p>
<h3 id="5-线程的run方法和start方法有什么区别"><a href="#5-线程的run方法和start方法有什么区别" class="headerlink" title="5. 线程的run方法和start方法有什么区别"></a>5. 线程的run方法和start方法有什么区别</h3><p>调用start()方法可以让启动一个线程，并进入到就绪状态，而调用run()方法只是调用了一个对象的方法，并没有开启新的线程。</p>
<p>就比如说你在主线程中调用了run()方法，那么你要等run()方法执行完之后才会继续执行下面的代码，而调用了start()方法，会开启一条线程去执行Thread对象中对应的run方法，即使run方法没有执行完，主线程中还会执行start()下面的代码。</p>
<h3 id="6-线程有哪几种状态？（线程的生命周期）"><a href="#6-线程有哪几种状态？（线程的生命周期）" class="headerlink" title="6. 线程有哪几种状态？（线程的生命周期）"></a>6. 线程有哪几种状态？（线程的生命周期）</h3><p>Java线程在运行的生命周期中的指定时刻只可能处于下面6中不同状态的其中一个状态</p>
<ul>
<li>线程：初始状态，线程被创建出来但没有被调用start()方法的状态</li>
<li><strong>RUNNABLE</strong>：运行状态，线程被调用了start()等待运行的状态。<code>RUNNABLE</code>状态细分一下会有一个<code>RUNNING</code>状态以及<code>READY</code>状态的</li>
<li><strong>BLOCKED</strong>：阻塞状态，需要等待锁释放。</li>
<li><strong>WAITING</strong>：等待状态，调用wait方法后的一个状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）</li>
<li><strong>TIME_WAITING</strong>：超时等待状态，调用wait方法并且传入了一个时间之后的状态，可以在指定的时间后自行返回而不是想WAITING那样一直等待。</li>
<li><strong>TERMINATED</strong>：终止状态，表示该线程已经运行完毕</li>
</ul>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间转换。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png" alt="Java 线程状态变迁图"></p>
<h3 id="7-线程相关的基本方法都有哪些"><a href="#7-线程相关的基本方法都有哪些" class="headerlink" title="7. 线程相关的基本方法都有哪些"></a>7. 线程相关的基本方法都有哪些</h3><p>线程相关的基本方法有6种，分别是wait、sleep、notifyAll、notify、join、yield</p>
<ol>
<li><p><strong>wait方法（线程等待）：</strong></p>
<p>线程调用<code>wait</code>方法并且没有传入参数时，会让该线程进入到一个<code>WAITING</code>状态，<strong>并且释放锁资源</strong>，直至被其他线程调用<code>notify</code>或<code>notifyAll</code>方法才会进入就绪状态重新竞争锁资源；如果调用<code>wait</code>方法并传入一个指定的时间，该线程会进入到<code>TIMED_WAITING</code>状态，如果指定超过的时间还没获取到锁资源，该线程就会直接返回到就绪状态，不会一直在等待通知</p>
</li>
<li><p><strong>sleep方法（线程睡眠）</strong>：</p>
<p>sleep方法会导致当前线程休眠，与wait方法不同的是<strong>sleep不会释放锁资源</strong>，然后sleep会导致线程进入TIMED_WAITING状态，当休眠时间过去之后，当前线程会自动唤醒并且继续执行。这个过程中其他线程处于阻塞状态</p>
</li>
<li><p><strong>yield方法（线程让步）</strong>：</p>
<p>yield方法会让当前线程让出CPU时间片（资源），同时让当前线程重新与其他线程竞争CPU时间片，一般来说优先级高的线程会比较容易获得CPU时间片。但不是绝对的，有一些操作系统对线程优先级不敏感。</p>
</li>
<li><p><strong>interrupt（线程中断）：</strong></p>
<p>该方法可以中断一个线程，该方法会将线程中的一个标识符设置为true，表示中断该线程，但是<strong>线程中断之后并不会释放锁资源</strong>，需要结合wait方法的使用才会释放锁资源。这个过程中线程的状态不会发生改变</p>
</li>
<li><p><strong>join方法（等待其他线程终止）：</strong></p>
<p>在当前线程调用另外一个线程的join()方法时，会让<strong>当前线程进入到阻塞状态，直到另一个线程执行结束</strong>，当前线程才会由阻塞状态转换为就绪状态并且重新竞争锁资源。</p>
</li>
<li><p><strong>notify方法（线程唤醒）：</strong></p>
<p>Object类上的notify方法，可以唤醒在此对象监视器上等待的线程（可以理解为在当前锁对象外面等待的资源），如果所有的线程都在这个对象上等待，则会唤醒任意一个线程。</p>
<p>在调用notify()方法之后，线程并不会立即释放该对象的锁。它会继续执行同步代码块，<strong>直到离开同步代码块或调用wait()方法时才会释放锁</strong>，从而使等待的线程有机会获取锁并执行。</p>
<p>在使用wait()和notify()方法进行线程间通信时，<strong>需要确保等待线程和唤醒线程都使用相同的对象作为锁</strong>，以避免死锁等问题。</p>
</li>
</ol>
<h3 id="8-wait-和sleep-的区别"><a href="#8-wait-和sleep-的区别" class="headerlink" title="8. wait() 和sleep()的区别"></a>8. wait() 和sleep()的区别</h3><p>wait()方法与sleep()方法的区别主要有一下四点</p>
<ol>
<li><p>它们来自不同的类</p>
<p>wait()来自Object类</p>
<p>sleep()来自Thread类</p>
</li>
<li><p>调用wait方法会释放锁资源，调用sleep方法不会释放锁资源</p>
</li>
<li><p>wait方法必须要在同步代码块中使用，sleep方法可以在任何地方使用</p>
</li>
<li><p>wait方法不需要捕获异常，sleep方法需要捕获异常</p>
</li>
</ol>
<h3 id="9-Java中常用的线程池有哪些"><a href="#9-Java中常用的线程池有哪些" class="headerlink" title="9. Java中常用的线程池有哪些"></a>9. Java中常用的线程池有哪些</h3><p>常用的线程池主要有6种，分别是：</p>
<ol>
<li>newFixedThreadPool：创建一个定长线程池（核心线程数与最大线程数都为指定参数的线程池），可以控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newCacheThreadPool：创建一个可缓存线程池（核心线程数为0，最大线程数为Integer.MAX_VALUE的线程池），如果线程池的长度超过处理需要，可以灵活的回收空闲线程，若无可回收，则创建新线程。这种方式可能会创建大量的线程，造成OOM。</li>
<li>newScheduledThreadPool：创建一个定长的线程池（核心线程数与最大线程数都为指定参数的线程池），支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor：创建一个单线程化的线程池（核心线程数与最大线程数都为1的线程池），它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行</li>
<li>newSingleScheduledThreadPool：创建一个单线程化的线程池（核心线程数为1、最大线程数为Integer.MAX_VALUE的线程池），它可安排在给定延迟后运行命令或者定期执行</li>
<li><strong>newWorkStealingPool</strong>：创建一个带并<strong>行级别的线程池</strong>，并行级别决定了同<strong>一时刻</strong>最多有<strong>多</strong>少个；线程在执行<strong>，如不传并行级别参数，将默认为当前系统的</strong>CPU<strong>核心数</strong>*<strong>2</strong>。该线程池是在JDK1.8才出现的，底层是基于一个工作窃取算法实现的，该算法的核心思想就是让空闲的线程从其他线程的任务队列中“窃取”任务来执行。</li>
</ol>
<h3 id="10-Java线程池的核心参数有哪些（创建的时候）"><a href="#10-Java线程池的核心参数有哪些（创建的时候）" class="headerlink" title="10. Java线程池的核心参数有哪些（创建的时候）"></a>10. Java线程池的核心参数有哪些（创建的时候）</h3><blockquote>
<p>corePoolSize：线程池的核心线程数量</p>
<p>maxNumPollSiza：线程池中最大的线程数</p>
<p>KeepAliveTime：当线程数大于核心线程数时，多余的空闲线程存活的最长时间</p>
<p>unit：时间单位</p>
<p>WorkQueue：阻塞队列&#x2F;任务队列，用来储存等待执行任务的队列</p>
<p>threadFartoty：线程工厂，用来创建线程，一般默认即可</p>
<p>handler：拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</p>
</blockquote>
<h3 id="11-线程池的执行流程"><a href="#11-线程池的执行流程" class="headerlink" title="11. 线程池的执行流程"></a>11. 线程池的执行流程</h3><p><img src="https://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230602143058557.png" alt="image-20230602143058557"></p>
<ol>
<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>
<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li>
<li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>
<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>
</ol>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="1-网络的7层架构"><a href="#1-网络的7层架构" class="headerlink" title="1. 网络的7层架构"></a>1. 网络的7层架构</h3><blockquote>
<p>OSI七层模型是什么？每一层的作用是什么？</p>
</blockquote>
<p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p>
<p><img src="http://minsterznhy-blog-image.oss-cn-beijing.aliyuncs.com/img/image-20230603073012982.png" alt="image-20230603073012982"></p>
<h3 id="2-TCP与UDP的区别"><a href="#2-TCP与UDP的区别" class="headerlink" title="2. TCP与UDP的区别"></a>2. TCP与UDP的区别</h3><ol>
<li><strong>是否面向连接：</strong>UDP在传送数据之前不需要先建立连接。而TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接</li>
<li><strong>是否是可靠传输：</strong>远地主机在收到UDP报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP提供可靠的传输服务，TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制等机制。通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达</li>
<li><strong>是否有状态：</strong>与”是否可靠“相对应，TCP传输是有状态的，这个有状态说的是TCP会去记录自己发送消息的状态，比如消息是否发送了、是否被接收了等等。为此TCP需要维持复杂的连接状态表。而UDP是无状态服务，简单来说就是不管发出去之后的事情了（渣男行为）</li>
<li><strong>传输效率：</strong>TCP进行传输时多了连接、确认、重传等机制，所以TCP传输效率要比UDP低很多</li>
<li><strong>传输形式</strong>：TCP是面向字节流的，UDP是面向报文的</li>
<li><strong>首部开销</strong>：TCP首部开销（20~60字节）比UDP首部开销（8字节）要大</li>
<li><strong>是否提供广播或多播服务：</strong>TCP只支持点对点通信；UDP支持一对一、一对多、多对一、多对多通信。</li>
</ol>
<p>总结起来就是：</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>TCP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20 ～ 60 bytes</td>
<td>8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="3-TCP与UDP的运用场景"><a href="#3-TCP与UDP的运用场景" class="headerlink" title="3. TCP与UDP的运用场景"></a>3. TCP与UDP的运用场景</h3><ul>
<li><strong>UDP 一般用于即时通信</strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h3 id="4-TCP的三次握手和四次挥手"><a href="#4-TCP的三次握手和四次挥手" class="headerlink" title="4. TCP的三次握手和四次挥手"></a>4. TCP的三次握手和四次挥手</h3><blockquote>
<p>这个问题可以衍生出很多经典面试题，详细见下面链接</p>
<p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/network/tcp-connection-and-disconnection">TCP 三次握手和四次挥手（传输层）</a></p>
</blockquote>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote>
<p>算法篇详情见</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/algorithms/10-classical-sorting-algorithms">十大经典排序算法</a></li>
</ul>
</blockquote>

    </div>

    
    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/interview/" rel="tag"># interview</a>
              <a href="/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/" rel="tag"># 持续更新</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/05/27/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E4%BC%91%E7%9C%A0%EF%BC%9Await-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/" rel="prev" title="Java 多线程编程中的等待和休眠：wait() 和 sleep() 方法解析">
                  <i class="fa fa-chevron-left"></i> Java 多线程编程中的等待和休眠：wait() 和 sleep() 方法解析
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Minster</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Word count total: </span>
    <span title="Word count total">22k</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-blog-comments-nine.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"疑义相与析，畅所欲言，不登录也没关系~","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":["nick"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2023/06/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%81%EF%BC%89/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <script type="text/javascript" src="lib/clipboard/src/clipboard.js"></script>
<script type="text/javascript" src="js/src/custom.js"></script>
</body>
</html>
